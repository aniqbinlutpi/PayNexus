
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserProfile
 * 
 */
export type UserProfile = $Result.DefaultSelection<Prisma.$UserProfilePayload>
/**
 * Model LinkedAccount
 * 
 */
export type LinkedAccount = $Result.DefaultSelection<Prisma.$LinkedAccountPayload>
/**
 * Model PaymentRequest
 * 
 */
export type PaymentRequest = $Result.DefaultSelection<Prisma.$PaymentRequestPayload>
/**
 * Model PaymentTransaction
 * 
 */
export type PaymentTransaction = $Result.DefaultSelection<Prisma.$PaymentTransactionPayload>
/**
 * Model RoutingStep
 * 
 */
export type RoutingStep = $Result.DefaultSelection<Prisma.$RoutingStepPayload>
/**
 * Model TransactionFee
 * 
 */
export type TransactionFee = $Result.DefaultSelection<Prisma.$TransactionFeePayload>
/**
 * Model RoutingStepFee
 * 
 */
export type RoutingStepFee = $Result.DefaultSelection<Prisma.$RoutingStepFeePayload>
/**
 * Model RoutingRule
 * 
 */
export type RoutingRule = $Result.DefaultSelection<Prisma.$RoutingRulePayload>
/**
 * Model ExchangeRate
 * 
 */
export type ExchangeRate = $Result.DefaultSelection<Prisma.$ExchangeRatePayload>
/**
 * Model PaymentNetworkStatus
 * 
 */
export type PaymentNetworkStatus = $Result.DefaultSelection<Prisma.$PaymentNetworkStatusPayload>
/**
 * Model UserSession
 * 
 */
export type UserSession = $Result.DefaultSelection<Prisma.$UserSessionPayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const KYCStatus: {
  PENDING: 'PENDING',
  VERIFIED: 'VERIFIED',
  REJECTED: 'REJECTED',
  EXPIRED: 'EXPIRED'
};

export type KYCStatus = (typeof KYCStatus)[keyof typeof KYCStatus]


export const RiskProfile: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH'
};

export type RiskProfile = (typeof RiskProfile)[keyof typeof RiskProfile]


export const AccountType: {
  BANK_ACCOUNT: 'BANK_ACCOUNT',
  EWALLET: 'EWALLET',
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  CRYPTO_WALLET: 'CRYPTO_WALLET'
};

export type AccountType = (typeof AccountType)[keyof typeof AccountType]


export const PaymentProvider: {
  MAYBANK: 'MAYBANK',
  CIMB: 'CIMB',
  PUBLIC_BANK: 'PUBLIC_BANK',
  RHB: 'RHB',
  HONG_LEONG: 'HONG_LEONG',
  TOUCH_N_GO: 'TOUCH_N_GO',
  GRABPAY: 'GRABPAY',
  BOOST: 'BOOST',
  SHOPEE_PAY: 'SHOPEE_PAY',
  PROMPTPAY: 'PROMPTPAY',
  PAYNOW: 'PAYNOW',
  QRIS: 'QRIS',
  PAYPAL: 'PAYPAL',
  WISE: 'WISE'
};

export type PaymentProvider = (typeof PaymentProvider)[keyof typeof PaymentProvider]


export const TransactionStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  CANCELLED: 'CANCELLED',
  REFUNDED: 'REFUNDED'
};

export type TransactionStatus = (typeof TransactionStatus)[keyof typeof TransactionStatus]


export const RoutingAction: {
  DEBIT: 'DEBIT',
  CREDIT: 'CREDIT',
  CONVERT: 'CONVERT',
  ROUTE: 'ROUTE'
};

export type RoutingAction = (typeof RoutingAction)[keyof typeof RoutingAction]


export const StepStatus: {
  PENDING: 'PENDING',
  PROCESSING: 'PROCESSING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED'
};

export type StepStatus = (typeof StepStatus)[keyof typeof StepStatus]


export const FeeType: {
  PROCESSING: 'PROCESSING',
  FOREIGN_EXCHANGE: 'FOREIGN_EXCHANGE',
  NETWORK: 'NETWORK',
  CROSS_BORDER: 'CROSS_BORDER'
};

export type FeeType = (typeof FeeType)[keyof typeof FeeType]

}

export type KYCStatus = $Enums.KYCStatus

export const KYCStatus: typeof $Enums.KYCStatus

export type RiskProfile = $Enums.RiskProfile

export const RiskProfile: typeof $Enums.RiskProfile

export type AccountType = $Enums.AccountType

export const AccountType: typeof $Enums.AccountType

export type PaymentProvider = $Enums.PaymentProvider

export const PaymentProvider: typeof $Enums.PaymentProvider

export type TransactionStatus = $Enums.TransactionStatus

export const TransactionStatus: typeof $Enums.TransactionStatus

export type RoutingAction = $Enums.RoutingAction

export const RoutingAction: typeof $Enums.RoutingAction

export type StepStatus = $Enums.StepStatus

export const StepStatus: typeof $Enums.StepStatus

export type FeeType = $Enums.FeeType

export const FeeType: typeof $Enums.FeeType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userProfile`: Exposes CRUD operations for the **UserProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserProfiles
    * const userProfiles = await prisma.userProfile.findMany()
    * ```
    */
  get userProfile(): Prisma.UserProfileDelegate<ExtArgs>;

  /**
   * `prisma.linkedAccount`: Exposes CRUD operations for the **LinkedAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LinkedAccounts
    * const linkedAccounts = await prisma.linkedAccount.findMany()
    * ```
    */
  get linkedAccount(): Prisma.LinkedAccountDelegate<ExtArgs>;

  /**
   * `prisma.paymentRequest`: Exposes CRUD operations for the **PaymentRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentRequests
    * const paymentRequests = await prisma.paymentRequest.findMany()
    * ```
    */
  get paymentRequest(): Prisma.PaymentRequestDelegate<ExtArgs>;

  /**
   * `prisma.paymentTransaction`: Exposes CRUD operations for the **PaymentTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentTransactions
    * const paymentTransactions = await prisma.paymentTransaction.findMany()
    * ```
    */
  get paymentTransaction(): Prisma.PaymentTransactionDelegate<ExtArgs>;

  /**
   * `prisma.routingStep`: Exposes CRUD operations for the **RoutingStep** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoutingSteps
    * const routingSteps = await prisma.routingStep.findMany()
    * ```
    */
  get routingStep(): Prisma.RoutingStepDelegate<ExtArgs>;

  /**
   * `prisma.transactionFee`: Exposes CRUD operations for the **TransactionFee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransactionFees
    * const transactionFees = await prisma.transactionFee.findMany()
    * ```
    */
  get transactionFee(): Prisma.TransactionFeeDelegate<ExtArgs>;

  /**
   * `prisma.routingStepFee`: Exposes CRUD operations for the **RoutingStepFee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoutingStepFees
    * const routingStepFees = await prisma.routingStepFee.findMany()
    * ```
    */
  get routingStepFee(): Prisma.RoutingStepFeeDelegate<ExtArgs>;

  /**
   * `prisma.routingRule`: Exposes CRUD operations for the **RoutingRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoutingRules
    * const routingRules = await prisma.routingRule.findMany()
    * ```
    */
  get routingRule(): Prisma.RoutingRuleDelegate<ExtArgs>;

  /**
   * `prisma.exchangeRate`: Exposes CRUD operations for the **ExchangeRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ExchangeRates
    * const exchangeRates = await prisma.exchangeRate.findMany()
    * ```
    */
  get exchangeRate(): Prisma.ExchangeRateDelegate<ExtArgs>;

  /**
   * `prisma.paymentNetworkStatus`: Exposes CRUD operations for the **PaymentNetworkStatus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PaymentNetworkStatuses
    * const paymentNetworkStatuses = await prisma.paymentNetworkStatus.findMany()
    * ```
    */
  get paymentNetworkStatus(): Prisma.PaymentNetworkStatusDelegate<ExtArgs>;

  /**
   * `prisma.userSession`: Exposes CRUD operations for the **UserSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSessions
    * const userSessions = await prisma.userSession.findMany()
    * ```
    */
  get userSession(): Prisma.UserSessionDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserProfile: 'UserProfile',
    LinkedAccount: 'LinkedAccount',
    PaymentRequest: 'PaymentRequest',
    PaymentTransaction: 'PaymentTransaction',
    RoutingStep: 'RoutingStep',
    TransactionFee: 'TransactionFee',
    RoutingStepFee: 'RoutingStepFee',
    RoutingRule: 'RoutingRule',
    ExchangeRate: 'ExchangeRate',
    PaymentNetworkStatus: 'PaymentNetworkStatus',
    UserSession: 'UserSession',
    AuditLog: 'AuditLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "userProfile" | "linkedAccount" | "paymentRequest" | "paymentTransaction" | "routingStep" | "transactionFee" | "routingStepFee" | "routingRule" | "exchangeRate" | "paymentNetworkStatus" | "userSession" | "auditLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserProfile: {
        payload: Prisma.$UserProfilePayload<ExtArgs>
        fields: Prisma.UserProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findFirst: {
            args: Prisma.UserProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          findMany: {
            args: Prisma.UserProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          create: {
            args: Prisma.UserProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          createMany: {
            args: Prisma.UserProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>[]
          }
          delete: {
            args: Prisma.UserProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          update: {
            args: Prisma.UserProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          deleteMany: {
            args: Prisma.UserProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserProfilePayload>
          }
          aggregate: {
            args: Prisma.UserProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserProfile>
          }
          groupBy: {
            args: Prisma.UserProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserProfileCountArgs<ExtArgs>
            result: $Utils.Optional<UserProfileCountAggregateOutputType> | number
          }
        }
      }
      LinkedAccount: {
        payload: Prisma.$LinkedAccountPayload<ExtArgs>
        fields: Prisma.LinkedAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LinkedAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LinkedAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedAccountPayload>
          }
          findFirst: {
            args: Prisma.LinkedAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LinkedAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedAccountPayload>
          }
          findMany: {
            args: Prisma.LinkedAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedAccountPayload>[]
          }
          create: {
            args: Prisma.LinkedAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedAccountPayload>
          }
          createMany: {
            args: Prisma.LinkedAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LinkedAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedAccountPayload>[]
          }
          delete: {
            args: Prisma.LinkedAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedAccountPayload>
          }
          update: {
            args: Prisma.LinkedAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedAccountPayload>
          }
          deleteMany: {
            args: Prisma.LinkedAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LinkedAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LinkedAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LinkedAccountPayload>
          }
          aggregate: {
            args: Prisma.LinkedAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLinkedAccount>
          }
          groupBy: {
            args: Prisma.LinkedAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<LinkedAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.LinkedAccountCountArgs<ExtArgs>
            result: $Utils.Optional<LinkedAccountCountAggregateOutputType> | number
          }
        }
      }
      PaymentRequest: {
        payload: Prisma.$PaymentRequestPayload<ExtArgs>
        fields: Prisma.PaymentRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          findFirst: {
            args: Prisma.PaymentRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          findMany: {
            args: Prisma.PaymentRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>[]
          }
          create: {
            args: Prisma.PaymentRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          createMany: {
            args: Prisma.PaymentRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>[]
          }
          delete: {
            args: Prisma.PaymentRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          update: {
            args: Prisma.PaymentRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          deleteMany: {
            args: Prisma.PaymentRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentRequestPayload>
          }
          aggregate: {
            args: Prisma.PaymentRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentRequest>
          }
          groupBy: {
            args: Prisma.PaymentRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentRequestCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentRequestCountAggregateOutputType> | number
          }
        }
      }
      PaymentTransaction: {
        payload: Prisma.$PaymentTransactionPayload<ExtArgs>
        fields: Prisma.PaymentTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findFirst: {
            args: Prisma.PaymentTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          findMany: {
            args: Prisma.PaymentTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          create: {
            args: Prisma.PaymentTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          createMany: {
            args: Prisma.PaymentTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>[]
          }
          delete: {
            args: Prisma.PaymentTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          update: {
            args: Prisma.PaymentTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          deleteMany: {
            args: Prisma.PaymentTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentTransactionPayload>
          }
          aggregate: {
            args: Prisma.PaymentTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentTransaction>
          }
          groupBy: {
            args: Prisma.PaymentTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentTransactionCountAggregateOutputType> | number
          }
        }
      }
      RoutingStep: {
        payload: Prisma.$RoutingStepPayload<ExtArgs>
        fields: Prisma.RoutingStepFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoutingStepFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoutingStepFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepPayload>
          }
          findFirst: {
            args: Prisma.RoutingStepFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoutingStepFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepPayload>
          }
          findMany: {
            args: Prisma.RoutingStepFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepPayload>[]
          }
          create: {
            args: Prisma.RoutingStepCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepPayload>
          }
          createMany: {
            args: Prisma.RoutingStepCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoutingStepCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepPayload>[]
          }
          delete: {
            args: Prisma.RoutingStepDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepPayload>
          }
          update: {
            args: Prisma.RoutingStepUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepPayload>
          }
          deleteMany: {
            args: Prisma.RoutingStepDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoutingStepUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoutingStepUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepPayload>
          }
          aggregate: {
            args: Prisma.RoutingStepAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoutingStep>
          }
          groupBy: {
            args: Prisma.RoutingStepGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoutingStepGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoutingStepCountArgs<ExtArgs>
            result: $Utils.Optional<RoutingStepCountAggregateOutputType> | number
          }
        }
      }
      TransactionFee: {
        payload: Prisma.$TransactionFeePayload<ExtArgs>
        fields: Prisma.TransactionFeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          findFirst: {
            args: Prisma.TransactionFeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          findMany: {
            args: Prisma.TransactionFeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>[]
          }
          create: {
            args: Prisma.TransactionFeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          createMany: {
            args: Prisma.TransactionFeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionFeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>[]
          }
          delete: {
            args: Prisma.TransactionFeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          update: {
            args: Prisma.TransactionFeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          deleteMany: {
            args: Prisma.TransactionFeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionFeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TransactionFeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionFeePayload>
          }
          aggregate: {
            args: Prisma.TransactionFeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransactionFee>
          }
          groupBy: {
            args: Prisma.TransactionFeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionFeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionFeeCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionFeeCountAggregateOutputType> | number
          }
        }
      }
      RoutingStepFee: {
        payload: Prisma.$RoutingStepFeePayload<ExtArgs>
        fields: Prisma.RoutingStepFeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoutingStepFeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepFeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoutingStepFeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepFeePayload>
          }
          findFirst: {
            args: Prisma.RoutingStepFeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepFeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoutingStepFeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepFeePayload>
          }
          findMany: {
            args: Prisma.RoutingStepFeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepFeePayload>[]
          }
          create: {
            args: Prisma.RoutingStepFeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepFeePayload>
          }
          createMany: {
            args: Prisma.RoutingStepFeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoutingStepFeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepFeePayload>[]
          }
          delete: {
            args: Prisma.RoutingStepFeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepFeePayload>
          }
          update: {
            args: Prisma.RoutingStepFeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepFeePayload>
          }
          deleteMany: {
            args: Prisma.RoutingStepFeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoutingStepFeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoutingStepFeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingStepFeePayload>
          }
          aggregate: {
            args: Prisma.RoutingStepFeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoutingStepFee>
          }
          groupBy: {
            args: Prisma.RoutingStepFeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoutingStepFeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoutingStepFeeCountArgs<ExtArgs>
            result: $Utils.Optional<RoutingStepFeeCountAggregateOutputType> | number
          }
        }
      }
      RoutingRule: {
        payload: Prisma.$RoutingRulePayload<ExtArgs>
        fields: Prisma.RoutingRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoutingRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoutingRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingRulePayload>
          }
          findFirst: {
            args: Prisma.RoutingRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoutingRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingRulePayload>
          }
          findMany: {
            args: Prisma.RoutingRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingRulePayload>[]
          }
          create: {
            args: Prisma.RoutingRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingRulePayload>
          }
          createMany: {
            args: Prisma.RoutingRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoutingRuleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingRulePayload>[]
          }
          delete: {
            args: Prisma.RoutingRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingRulePayload>
          }
          update: {
            args: Prisma.RoutingRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingRulePayload>
          }
          deleteMany: {
            args: Prisma.RoutingRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoutingRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoutingRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoutingRulePayload>
          }
          aggregate: {
            args: Prisma.RoutingRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoutingRule>
          }
          groupBy: {
            args: Prisma.RoutingRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoutingRuleGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoutingRuleCountArgs<ExtArgs>
            result: $Utils.Optional<RoutingRuleCountAggregateOutputType> | number
          }
        }
      }
      ExchangeRate: {
        payload: Prisma.$ExchangeRatePayload<ExtArgs>
        fields: Prisma.ExchangeRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExchangeRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExchangeRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          findFirst: {
            args: Prisma.ExchangeRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExchangeRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          findMany: {
            args: Prisma.ExchangeRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
          }
          create: {
            args: Prisma.ExchangeRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          createMany: {
            args: Prisma.ExchangeRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExchangeRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>[]
          }
          delete: {
            args: Prisma.ExchangeRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          update: {
            args: Prisma.ExchangeRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          deleteMany: {
            args: Prisma.ExchangeRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExchangeRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExchangeRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExchangeRatePayload>
          }
          aggregate: {
            args: Prisma.ExchangeRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExchangeRate>
          }
          groupBy: {
            args: Prisma.ExchangeRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExchangeRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExchangeRateCountArgs<ExtArgs>
            result: $Utils.Optional<ExchangeRateCountAggregateOutputType> | number
          }
        }
      }
      PaymentNetworkStatus: {
        payload: Prisma.$PaymentNetworkStatusPayload<ExtArgs>
        fields: Prisma.PaymentNetworkStatusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentNetworkStatusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentNetworkStatusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentNetworkStatusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentNetworkStatusPayload>
          }
          findFirst: {
            args: Prisma.PaymentNetworkStatusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentNetworkStatusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentNetworkStatusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentNetworkStatusPayload>
          }
          findMany: {
            args: Prisma.PaymentNetworkStatusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentNetworkStatusPayload>[]
          }
          create: {
            args: Prisma.PaymentNetworkStatusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentNetworkStatusPayload>
          }
          createMany: {
            args: Prisma.PaymentNetworkStatusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentNetworkStatusCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentNetworkStatusPayload>[]
          }
          delete: {
            args: Prisma.PaymentNetworkStatusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentNetworkStatusPayload>
          }
          update: {
            args: Prisma.PaymentNetworkStatusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentNetworkStatusPayload>
          }
          deleteMany: {
            args: Prisma.PaymentNetworkStatusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentNetworkStatusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentNetworkStatusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentNetworkStatusPayload>
          }
          aggregate: {
            args: Prisma.PaymentNetworkStatusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePaymentNetworkStatus>
          }
          groupBy: {
            args: Prisma.PaymentNetworkStatusGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentNetworkStatusGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentNetworkStatusCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentNetworkStatusCountAggregateOutputType> | number
          }
        }
      }
      UserSession: {
        payload: Prisma.$UserSessionPayload<ExtArgs>
        fields: Prisma.UserSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findFirst: {
            args: Prisma.UserSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          findMany: {
            args: Prisma.UserSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          create: {
            args: Prisma.UserSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          createMany: {
            args: Prisma.UserSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>[]
          }
          delete: {
            args: Prisma.UserSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          update: {
            args: Prisma.UserSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          deleteMany: {
            args: Prisma.UserSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSessionPayload>
          }
          aggregate: {
            args: Prisma.UserSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSession>
          }
          groupBy: {
            args: Prisma.UserSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSessionCountArgs<ExtArgs>
            result: $Utils.Optional<UserSessionCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    linkedAccounts: number
    routingRules: number
    paymentRequests: number
    transactions: number
    sessions: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    linkedAccounts?: boolean | UserCountOutputTypeCountLinkedAccountsArgs
    routingRules?: boolean | UserCountOutputTypeCountRoutingRulesArgs
    paymentRequests?: boolean | UserCountOutputTypeCountPaymentRequestsArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLinkedAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkedAccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRoutingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutingRuleWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPaymentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
  }


  /**
   * Count Type LinkedAccountCountOutputType
   */

  export type LinkedAccountCountOutputType = {
    sourceTransactions: number
    targetTransactions: number
  }

  export type LinkedAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sourceTransactions?: boolean | LinkedAccountCountOutputTypeCountSourceTransactionsArgs
    targetTransactions?: boolean | LinkedAccountCountOutputTypeCountTargetTransactionsArgs
  }

  // Custom InputTypes
  /**
   * LinkedAccountCountOutputType without action
   */
  export type LinkedAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccountCountOutputType
     */
    select?: LinkedAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LinkedAccountCountOutputType without action
   */
  export type LinkedAccountCountOutputTypeCountSourceTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
  }

  /**
   * LinkedAccountCountOutputType without action
   */
  export type LinkedAccountCountOutputTypeCountTargetTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
  }


  /**
   * Count Type PaymentRequestCountOutputType
   */

  export type PaymentRequestCountOutputType = {
    transactions: number
  }

  export type PaymentRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | PaymentRequestCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * PaymentRequestCountOutputType without action
   */
  export type PaymentRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequestCountOutputType
     */
    select?: PaymentRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentRequestCountOutputType without action
   */
  export type PaymentRequestCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
  }


  /**
   * Count Type PaymentTransactionCountOutputType
   */

  export type PaymentTransactionCountOutputType = {
    routingSteps: number
    fees: number
  }

  export type PaymentTransactionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routingSteps?: boolean | PaymentTransactionCountOutputTypeCountRoutingStepsArgs
    fees?: boolean | PaymentTransactionCountOutputTypeCountFeesArgs
  }

  // Custom InputTypes
  /**
   * PaymentTransactionCountOutputType without action
   */
  export type PaymentTransactionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransactionCountOutputType
     */
    select?: PaymentTransactionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentTransactionCountOutputType without action
   */
  export type PaymentTransactionCountOutputTypeCountRoutingStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutingStepWhereInput
  }

  /**
   * PaymentTransactionCountOutputType without action
   */
  export type PaymentTransactionCountOutputTypeCountFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionFeeWhereInput
  }


  /**
   * Count Type RoutingStepCountOutputType
   */

  export type RoutingStepCountOutputType = {
    fees: number
  }

  export type RoutingStepCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fees?: boolean | RoutingStepCountOutputTypeCountFeesArgs
  }

  // Custom InputTypes
  /**
   * RoutingStepCountOutputType without action
   */
  export type RoutingStepCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepCountOutputType
     */
    select?: RoutingStepCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoutingStepCountOutputType without action
   */
  export type RoutingStepCountOutputTypeCountFeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutingStepFeeWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    phoneNumber: string | null
    firstName: string | null
    lastName: string | null
    countryCode: string | null
    preferredCurrency: string | null
    passwordHash: string | null
    isEmailVerified: boolean | null
    isPhoneVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phoneNumber: string | null
    firstName: string | null
    lastName: string | null
    countryCode: string | null
    preferredCurrency: string | null
    passwordHash: string | null
    isEmailVerified: boolean | null
    isPhoneVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    phoneNumber: number
    firstName: number
    lastName: number
    countryCode: number
    preferredCurrency: number
    passwordHash: number
    isEmailVerified: number
    isPhoneVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    phoneNumber?: true
    firstName?: true
    lastName?: true
    countryCode?: true
    preferredCurrency?: true
    passwordHash?: true
    isEmailVerified?: true
    isPhoneVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    phoneNumber?: true
    firstName?: true
    lastName?: true
    countryCode?: true
    preferredCurrency?: true
    passwordHash?: true
    isEmailVerified?: true
    isPhoneVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    phoneNumber?: true
    firstName?: true
    lastName?: true
    countryCode?: true
    preferredCurrency?: true
    passwordHash?: true
    isEmailVerified?: true
    isPhoneVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency: string
    passwordHash: string
    isEmailVerified: boolean
    isPhoneVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phoneNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    countryCode?: boolean
    preferredCurrency?: boolean
    passwordHash?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    linkedAccounts?: boolean | User$linkedAccountsArgs<ExtArgs>
    routingRules?: boolean | User$routingRulesArgs<ExtArgs>
    paymentRequests?: boolean | User$paymentRequestsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phoneNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    countryCode?: boolean
    preferredCurrency?: boolean
    passwordHash?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    phoneNumber?: boolean
    firstName?: boolean
    lastName?: boolean
    countryCode?: boolean
    preferredCurrency?: boolean
    passwordHash?: boolean
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    linkedAccounts?: boolean | User$linkedAccountsArgs<ExtArgs>
    routingRules?: boolean | User$routingRulesArgs<ExtArgs>
    paymentRequests?: boolean | User$paymentRequestsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$UserProfilePayload<ExtArgs> | null
      linkedAccounts: Prisma.$LinkedAccountPayload<ExtArgs>[]
      routingRules: Prisma.$RoutingRulePayload<ExtArgs>[]
      paymentRequests: Prisma.$PaymentRequestPayload<ExtArgs>[]
      transactions: Prisma.$PaymentTransactionPayload<ExtArgs>[]
      sessions: Prisma.$UserSessionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      phoneNumber: string
      firstName: string
      lastName: string
      countryCode: string
      preferredCurrency: string
      passwordHash: string
      isEmailVerified: boolean
      isPhoneVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    linkedAccounts<T extends User$linkedAccountsArgs<ExtArgs> = {}>(args?: Subset<T, User$linkedAccountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "findMany"> | Null>
    routingRules<T extends User$routingRulesArgs<ExtArgs> = {}>(args?: Subset<T, User$routingRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutingRulePayload<ExtArgs>, T, "findMany"> | Null>
    paymentRequests<T extends User$paymentRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$paymentRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findMany"> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly countryCode: FieldRef<"User", 'String'>
    readonly preferredCurrency: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly isEmailVerified: FieldRef<"User", 'Boolean'>
    readonly isPhoneVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    where?: UserProfileWhereInput
  }

  /**
   * User.linkedAccounts
   */
  export type User$linkedAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
    where?: LinkedAccountWhereInput
    orderBy?: LinkedAccountOrderByWithRelationInput | LinkedAccountOrderByWithRelationInput[]
    cursor?: LinkedAccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LinkedAccountScalarFieldEnum | LinkedAccountScalarFieldEnum[]
  }

  /**
   * User.routingRules
   */
  export type User$routingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleInclude<ExtArgs> | null
    where?: RoutingRuleWhereInput
    orderBy?: RoutingRuleOrderByWithRelationInput | RoutingRuleOrderByWithRelationInput[]
    cursor?: RoutingRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoutingRuleScalarFieldEnum | RoutingRuleScalarFieldEnum[]
  }

  /**
   * User.paymentRequests
   */
  export type User$paymentRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    where?: PaymentRequestWhereInput
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    cursor?: PaymentRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    cursor?: PaymentTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    cursor?: UserSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserProfile
   */

  export type AggregateUserProfile = {
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  export type UserProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    avatarUrl: string | null
    dateOfBirth: Date | null
    street: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    kycStatus: $Enums.KYCStatus | null
    riskProfile: $Enums.RiskProfile | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    avatarUrl: string | null
    dateOfBirth: Date | null
    street: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    kycStatus: $Enums.KYCStatus | null
    riskProfile: $Enums.RiskProfile | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserProfileCountAggregateOutputType = {
    id: number
    userId: number
    avatarUrl: number
    dateOfBirth: number
    street: number
    city: number
    state: number
    postalCode: number
    country: number
    kycStatus: number
    riskProfile: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserProfileMinAggregateInputType = {
    id?: true
    userId?: true
    avatarUrl?: true
    dateOfBirth?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    kycStatus?: true
    riskProfile?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    avatarUrl?: true
    dateOfBirth?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    kycStatus?: true
    riskProfile?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserProfileCountAggregateInputType = {
    id?: true
    userId?: true
    avatarUrl?: true
    dateOfBirth?: true
    street?: true
    city?: true
    state?: true
    postalCode?: true
    country?: true
    kycStatus?: true
    riskProfile?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfile to aggregate.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserProfiles
    **/
    _count?: true | UserProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserProfileMaxAggregateInputType
  }

  export type GetUserProfileAggregateType<T extends UserProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateUserProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserProfile[P]>
      : GetScalarType<T[P], AggregateUserProfile[P]>
  }




  export type UserProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserProfileWhereInput
    orderBy?: UserProfileOrderByWithAggregationInput | UserProfileOrderByWithAggregationInput[]
    by: UserProfileScalarFieldEnum[] | UserProfileScalarFieldEnum
    having?: UserProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserProfileCountAggregateInputType | true
    _min?: UserProfileMinAggregateInputType
    _max?: UserProfileMaxAggregateInputType
  }

  export type UserProfileGroupByOutputType = {
    id: string
    userId: string
    avatarUrl: string | null
    dateOfBirth: Date | null
    street: string | null
    city: string | null
    state: string | null
    postalCode: string | null
    country: string | null
    kycStatus: $Enums.KYCStatus
    riskProfile: $Enums.RiskProfile
    createdAt: Date
    updatedAt: Date
    _count: UserProfileCountAggregateOutputType | null
    _min: UserProfileMinAggregateOutputType | null
    _max: UserProfileMaxAggregateOutputType | null
  }

  type GetUserProfileGroupByPayload<T extends UserProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
            : GetScalarType<T[P], UserProfileGroupByOutputType[P]>
        }
      >
    >


  export type UserProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    avatarUrl?: boolean
    dateOfBirth?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    kycStatus?: boolean
    riskProfile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    avatarUrl?: boolean
    dateOfBirth?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    kycStatus?: boolean
    riskProfile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userProfile"]>

  export type UserProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    avatarUrl?: boolean
    dateOfBirth?: boolean
    street?: boolean
    city?: boolean
    state?: boolean
    postalCode?: boolean
    country?: boolean
    kycStatus?: boolean
    riskProfile?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      avatarUrl: string | null
      dateOfBirth: Date | null
      street: string | null
      city: string | null
      state: string | null
      postalCode: string | null
      country: string | null
      kycStatus: $Enums.KYCStatus
      riskProfile: $Enums.RiskProfile
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userProfile"]>
    composites: {}
  }

  type UserProfileGetPayload<S extends boolean | null | undefined | UserProfileDefaultArgs> = $Result.GetResult<Prisma.$UserProfilePayload, S>

  type UserProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserProfileFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserProfileCountAggregateInputType | true
    }

  export interface UserProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserProfile'], meta: { name: 'UserProfile' } }
    /**
     * Find zero or one UserProfile that matches the filter.
     * @param {UserProfileFindUniqueArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserProfileFindUniqueArgs>(args: SelectSubset<T, UserProfileFindUniqueArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserProfile that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserProfileFindUniqueOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, UserProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserProfileFindFirstArgs>(args?: SelectSubset<T, UserProfileFindFirstArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindFirstOrThrowArgs} args - Arguments to find a UserProfile
     * @example
     * // Get one UserProfile
     * const userProfile = await prisma.userProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, UserProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserProfiles
     * const userProfiles = await prisma.userProfile.findMany()
     * 
     * // Get first 10 UserProfiles
     * const userProfiles = await prisma.userProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserProfileFindManyArgs>(args?: SelectSubset<T, UserProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserProfile.
     * @param {UserProfileCreateArgs} args - Arguments to create a UserProfile.
     * @example
     * // Create one UserProfile
     * const UserProfile = await prisma.userProfile.create({
     *   data: {
     *     // ... data to create a UserProfile
     *   }
     * })
     * 
     */
    create<T extends UserProfileCreateArgs>(args: SelectSubset<T, UserProfileCreateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserProfiles.
     * @param {UserProfileCreateManyArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserProfileCreateManyArgs>(args?: SelectSubset<T, UserProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserProfiles and returns the data saved in the database.
     * @param {UserProfileCreateManyAndReturnArgs} args - Arguments to create many UserProfiles.
     * @example
     * // Create many UserProfiles
     * const userProfile = await prisma.userProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserProfiles and only return the `id`
     * const userProfileWithIdOnly = await prisma.userProfile.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, UserProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserProfile.
     * @param {UserProfileDeleteArgs} args - Arguments to delete one UserProfile.
     * @example
     * // Delete one UserProfile
     * const UserProfile = await prisma.userProfile.delete({
     *   where: {
     *     // ... filter to delete one UserProfile
     *   }
     * })
     * 
     */
    delete<T extends UserProfileDeleteArgs>(args: SelectSubset<T, UserProfileDeleteArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserProfile.
     * @param {UserProfileUpdateArgs} args - Arguments to update one UserProfile.
     * @example
     * // Update one UserProfile
     * const userProfile = await prisma.userProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserProfileUpdateArgs>(args: SelectSubset<T, UserProfileUpdateArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserProfiles.
     * @param {UserProfileDeleteManyArgs} args - Arguments to filter UserProfiles to delete.
     * @example
     * // Delete a few UserProfiles
     * const { count } = await prisma.userProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserProfileDeleteManyArgs>(args?: SelectSubset<T, UserProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserProfiles
     * const userProfile = await prisma.userProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserProfileUpdateManyArgs>(args: SelectSubset<T, UserProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserProfile.
     * @param {UserProfileUpsertArgs} args - Arguments to update or create a UserProfile.
     * @example
     * // Update or create a UserProfile
     * const userProfile = await prisma.userProfile.upsert({
     *   create: {
     *     // ... data to create a UserProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserProfile we want to update
     *   }
     * })
     */
    upsert<T extends UserProfileUpsertArgs>(args: SelectSubset<T, UserProfileUpsertArgs<ExtArgs>>): Prisma__UserProfileClient<$Result.GetResult<Prisma.$UserProfilePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileCountArgs} args - Arguments to filter UserProfiles to count.
     * @example
     * // Count the number of UserProfiles
     * const count = await prisma.userProfile.count({
     *   where: {
     *     // ... the filter for the UserProfiles we want to count
     *   }
     * })
    **/
    count<T extends UserProfileCountArgs>(
      args?: Subset<T, UserProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserProfileAggregateArgs>(args: Subset<T, UserProfileAggregateArgs>): Prisma.PrismaPromise<GetUserProfileAggregateType<T>>

    /**
     * Group by UserProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserProfileGroupByArgs['orderBy'] }
        : { orderBy?: UserProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserProfile model
   */
  readonly fields: UserProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserProfile model
   */ 
  interface UserProfileFieldRefs {
    readonly id: FieldRef<"UserProfile", 'String'>
    readonly userId: FieldRef<"UserProfile", 'String'>
    readonly avatarUrl: FieldRef<"UserProfile", 'String'>
    readonly dateOfBirth: FieldRef<"UserProfile", 'DateTime'>
    readonly street: FieldRef<"UserProfile", 'String'>
    readonly city: FieldRef<"UserProfile", 'String'>
    readonly state: FieldRef<"UserProfile", 'String'>
    readonly postalCode: FieldRef<"UserProfile", 'String'>
    readonly country: FieldRef<"UserProfile", 'String'>
    readonly kycStatus: FieldRef<"UserProfile", 'KYCStatus'>
    readonly riskProfile: FieldRef<"UserProfile", 'RiskProfile'>
    readonly createdAt: FieldRef<"UserProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"UserProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserProfile findUnique
   */
  export type UserProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findUniqueOrThrow
   */
  export type UserProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile findFirst
   */
  export type UserProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findFirstOrThrow
   */
  export type UserProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfile to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserProfiles.
     */
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile findMany
   */
  export type UserProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter, which UserProfiles to fetch.
     */
    where?: UserProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserProfiles to fetch.
     */
    orderBy?: UserProfileOrderByWithRelationInput | UserProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserProfiles.
     */
    cursor?: UserProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserProfiles.
     */
    skip?: number
    distinct?: UserProfileScalarFieldEnum | UserProfileScalarFieldEnum[]
  }

  /**
   * UserProfile create
   */
  export type UserProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a UserProfile.
     */
    data: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
  }

  /**
   * UserProfile createMany
   */
  export type UserProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserProfile createManyAndReturn
   */
  export type UserProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserProfiles.
     */
    data: UserProfileCreateManyInput | UserProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserProfile update
   */
  export type UserProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a UserProfile.
     */
    data: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
    /**
     * Choose, which UserProfile to update.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile updateMany
   */
  export type UserProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserProfiles.
     */
    data: XOR<UserProfileUpdateManyMutationInput, UserProfileUncheckedUpdateManyInput>
    /**
     * Filter which UserProfiles to update
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile upsert
   */
  export type UserProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the UserProfile to update in case it exists.
     */
    where: UserProfileWhereUniqueInput
    /**
     * In case the UserProfile found by the `where` argument doesn't exist, create a new UserProfile with this data.
     */
    create: XOR<UserProfileCreateInput, UserProfileUncheckedCreateInput>
    /**
     * In case the UserProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserProfileUpdateInput, UserProfileUncheckedUpdateInput>
  }

  /**
   * UserProfile delete
   */
  export type UserProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
    /**
     * Filter which UserProfile to delete.
     */
    where: UserProfileWhereUniqueInput
  }

  /**
   * UserProfile deleteMany
   */
  export type UserProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserProfiles to delete
     */
    where?: UserProfileWhereInput
  }

  /**
   * UserProfile without action
   */
  export type UserProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserProfile
     */
    select?: UserProfileSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserProfileInclude<ExtArgs> | null
  }


  /**
   * Model LinkedAccount
   */

  export type AggregateLinkedAccount = {
    _count: LinkedAccountCountAggregateOutputType | null
    _avg: LinkedAccountAvgAggregateOutputType | null
    _sum: LinkedAccountSumAggregateOutputType | null
    _min: LinkedAccountMinAggregateOutputType | null
    _max: LinkedAccountMaxAggregateOutputType | null
  }

  export type LinkedAccountAvgAggregateOutputType = {
    balance: number | null
    priority: number | null
    dailyLimit: number | null
    monthlyLimit: number | null
  }

  export type LinkedAccountSumAggregateOutputType = {
    balance: number | null
    priority: number | null
    dailyLimit: number | null
    monthlyLimit: number | null
  }

  export type LinkedAccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    accountType: $Enums.AccountType | null
    provider: $Enums.PaymentProvider | null
    accountNumber: string | null
    accountName: string | null
    currency: string | null
    balance: number | null
    isActive: boolean | null
    isPrimary: boolean | null
    priority: number | null
    dailyLimit: number | null
    monthlyLimit: number | null
    linkedAt: Date | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkedAccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    accountType: $Enums.AccountType | null
    provider: $Enums.PaymentProvider | null
    accountNumber: string | null
    accountName: string | null
    currency: string | null
    balance: number | null
    isActive: boolean | null
    isPrimary: boolean | null
    priority: number | null
    dailyLimit: number | null
    monthlyLimit: number | null
    linkedAt: Date | null
    lastSyncAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LinkedAccountCountAggregateOutputType = {
    id: number
    userId: number
    accountType: number
    provider: number
    accountNumber: number
    accountName: number
    currency: number
    balance: number
    isActive: number
    isPrimary: number
    priority: number
    dailyLimit: number
    monthlyLimit: number
    linkedAt: number
    lastSyncAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LinkedAccountAvgAggregateInputType = {
    balance?: true
    priority?: true
    dailyLimit?: true
    monthlyLimit?: true
  }

  export type LinkedAccountSumAggregateInputType = {
    balance?: true
    priority?: true
    dailyLimit?: true
    monthlyLimit?: true
  }

  export type LinkedAccountMinAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    provider?: true
    accountNumber?: true
    accountName?: true
    currency?: true
    balance?: true
    isActive?: true
    isPrimary?: true
    priority?: true
    dailyLimit?: true
    monthlyLimit?: true
    linkedAt?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkedAccountMaxAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    provider?: true
    accountNumber?: true
    accountName?: true
    currency?: true
    balance?: true
    isActive?: true
    isPrimary?: true
    priority?: true
    dailyLimit?: true
    monthlyLimit?: true
    linkedAt?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LinkedAccountCountAggregateInputType = {
    id?: true
    userId?: true
    accountType?: true
    provider?: true
    accountNumber?: true
    accountName?: true
    currency?: true
    balance?: true
    isActive?: true
    isPrimary?: true
    priority?: true
    dailyLimit?: true
    monthlyLimit?: true
    linkedAt?: true
    lastSyncAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LinkedAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkedAccount to aggregate.
     */
    where?: LinkedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedAccounts to fetch.
     */
    orderBy?: LinkedAccountOrderByWithRelationInput | LinkedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LinkedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LinkedAccounts
    **/
    _count?: true | LinkedAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LinkedAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LinkedAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LinkedAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LinkedAccountMaxAggregateInputType
  }

  export type GetLinkedAccountAggregateType<T extends LinkedAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateLinkedAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLinkedAccount[P]>
      : GetScalarType<T[P], AggregateLinkedAccount[P]>
  }




  export type LinkedAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LinkedAccountWhereInput
    orderBy?: LinkedAccountOrderByWithAggregationInput | LinkedAccountOrderByWithAggregationInput[]
    by: LinkedAccountScalarFieldEnum[] | LinkedAccountScalarFieldEnum
    having?: LinkedAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LinkedAccountCountAggregateInputType | true
    _avg?: LinkedAccountAvgAggregateInputType
    _sum?: LinkedAccountSumAggregateInputType
    _min?: LinkedAccountMinAggregateInputType
    _max?: LinkedAccountMaxAggregateInputType
  }

  export type LinkedAccountGroupByOutputType = {
    id: string
    userId: string
    accountType: $Enums.AccountType
    provider: $Enums.PaymentProvider
    accountNumber: string
    accountName: string
    currency: string
    balance: number | null
    isActive: boolean
    isPrimary: boolean
    priority: number
    dailyLimit: number | null
    monthlyLimit: number | null
    linkedAt: Date
    lastSyncAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: LinkedAccountCountAggregateOutputType | null
    _avg: LinkedAccountAvgAggregateOutputType | null
    _sum: LinkedAccountSumAggregateOutputType | null
    _min: LinkedAccountMinAggregateOutputType | null
    _max: LinkedAccountMaxAggregateOutputType | null
  }

  type GetLinkedAccountGroupByPayload<T extends LinkedAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LinkedAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LinkedAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LinkedAccountGroupByOutputType[P]>
            : GetScalarType<T[P], LinkedAccountGroupByOutputType[P]>
        }
      >
    >


  export type LinkedAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    provider?: boolean
    accountNumber?: boolean
    accountName?: boolean
    currency?: boolean
    balance?: boolean
    isActive?: boolean
    isPrimary?: boolean
    priority?: boolean
    dailyLimit?: boolean
    monthlyLimit?: boolean
    linkedAt?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    sourceTransactions?: boolean | LinkedAccount$sourceTransactionsArgs<ExtArgs>
    targetTransactions?: boolean | LinkedAccount$targetTransactionsArgs<ExtArgs>
    _count?: boolean | LinkedAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkedAccount"]>

  export type LinkedAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    accountType?: boolean
    provider?: boolean
    accountNumber?: boolean
    accountName?: boolean
    currency?: boolean
    balance?: boolean
    isActive?: boolean
    isPrimary?: boolean
    priority?: boolean
    dailyLimit?: boolean
    monthlyLimit?: boolean
    linkedAt?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["linkedAccount"]>

  export type LinkedAccountSelectScalar = {
    id?: boolean
    userId?: boolean
    accountType?: boolean
    provider?: boolean
    accountNumber?: boolean
    accountName?: boolean
    currency?: boolean
    balance?: boolean
    isActive?: boolean
    isPrimary?: boolean
    priority?: boolean
    dailyLimit?: boolean
    monthlyLimit?: boolean
    linkedAt?: boolean
    lastSyncAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LinkedAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    sourceTransactions?: boolean | LinkedAccount$sourceTransactionsArgs<ExtArgs>
    targetTransactions?: boolean | LinkedAccount$targetTransactionsArgs<ExtArgs>
    _count?: boolean | LinkedAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LinkedAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LinkedAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LinkedAccount"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      sourceTransactions: Prisma.$PaymentTransactionPayload<ExtArgs>[]
      targetTransactions: Prisma.$PaymentTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      accountType: $Enums.AccountType
      provider: $Enums.PaymentProvider
      accountNumber: string
      accountName: string
      currency: string
      balance: number | null
      isActive: boolean
      isPrimary: boolean
      priority: number
      dailyLimit: number | null
      monthlyLimit: number | null
      linkedAt: Date
      lastSyncAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["linkedAccount"]>
    composites: {}
  }

  type LinkedAccountGetPayload<S extends boolean | null | undefined | LinkedAccountDefaultArgs> = $Result.GetResult<Prisma.$LinkedAccountPayload, S>

  type LinkedAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LinkedAccountFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LinkedAccountCountAggregateInputType | true
    }

  export interface LinkedAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LinkedAccount'], meta: { name: 'LinkedAccount' } }
    /**
     * Find zero or one LinkedAccount that matches the filter.
     * @param {LinkedAccountFindUniqueArgs} args - Arguments to find a LinkedAccount
     * @example
     * // Get one LinkedAccount
     * const linkedAccount = await prisma.linkedAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LinkedAccountFindUniqueArgs>(args: SelectSubset<T, LinkedAccountFindUniqueArgs<ExtArgs>>): Prisma__LinkedAccountClient<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LinkedAccount that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LinkedAccountFindUniqueOrThrowArgs} args - Arguments to find a LinkedAccount
     * @example
     * // Get one LinkedAccount
     * const linkedAccount = await prisma.linkedAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LinkedAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, LinkedAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LinkedAccountClient<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LinkedAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedAccountFindFirstArgs} args - Arguments to find a LinkedAccount
     * @example
     * // Get one LinkedAccount
     * const linkedAccount = await prisma.linkedAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LinkedAccountFindFirstArgs>(args?: SelectSubset<T, LinkedAccountFindFirstArgs<ExtArgs>>): Prisma__LinkedAccountClient<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LinkedAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedAccountFindFirstOrThrowArgs} args - Arguments to find a LinkedAccount
     * @example
     * // Get one LinkedAccount
     * const linkedAccount = await prisma.linkedAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LinkedAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, LinkedAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__LinkedAccountClient<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LinkedAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LinkedAccounts
     * const linkedAccounts = await prisma.linkedAccount.findMany()
     * 
     * // Get first 10 LinkedAccounts
     * const linkedAccounts = await prisma.linkedAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const linkedAccountWithIdOnly = await prisma.linkedAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LinkedAccountFindManyArgs>(args?: SelectSubset<T, LinkedAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LinkedAccount.
     * @param {LinkedAccountCreateArgs} args - Arguments to create a LinkedAccount.
     * @example
     * // Create one LinkedAccount
     * const LinkedAccount = await prisma.linkedAccount.create({
     *   data: {
     *     // ... data to create a LinkedAccount
     *   }
     * })
     * 
     */
    create<T extends LinkedAccountCreateArgs>(args: SelectSubset<T, LinkedAccountCreateArgs<ExtArgs>>): Prisma__LinkedAccountClient<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LinkedAccounts.
     * @param {LinkedAccountCreateManyArgs} args - Arguments to create many LinkedAccounts.
     * @example
     * // Create many LinkedAccounts
     * const linkedAccount = await prisma.linkedAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LinkedAccountCreateManyArgs>(args?: SelectSubset<T, LinkedAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LinkedAccounts and returns the data saved in the database.
     * @param {LinkedAccountCreateManyAndReturnArgs} args - Arguments to create many LinkedAccounts.
     * @example
     * // Create many LinkedAccounts
     * const linkedAccount = await prisma.linkedAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LinkedAccounts and only return the `id`
     * const linkedAccountWithIdOnly = await prisma.linkedAccount.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LinkedAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, LinkedAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LinkedAccount.
     * @param {LinkedAccountDeleteArgs} args - Arguments to delete one LinkedAccount.
     * @example
     * // Delete one LinkedAccount
     * const LinkedAccount = await prisma.linkedAccount.delete({
     *   where: {
     *     // ... filter to delete one LinkedAccount
     *   }
     * })
     * 
     */
    delete<T extends LinkedAccountDeleteArgs>(args: SelectSubset<T, LinkedAccountDeleteArgs<ExtArgs>>): Prisma__LinkedAccountClient<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LinkedAccount.
     * @param {LinkedAccountUpdateArgs} args - Arguments to update one LinkedAccount.
     * @example
     * // Update one LinkedAccount
     * const linkedAccount = await prisma.linkedAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LinkedAccountUpdateArgs>(args: SelectSubset<T, LinkedAccountUpdateArgs<ExtArgs>>): Prisma__LinkedAccountClient<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LinkedAccounts.
     * @param {LinkedAccountDeleteManyArgs} args - Arguments to filter LinkedAccounts to delete.
     * @example
     * // Delete a few LinkedAccounts
     * const { count } = await prisma.linkedAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LinkedAccountDeleteManyArgs>(args?: SelectSubset<T, LinkedAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LinkedAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LinkedAccounts
     * const linkedAccount = await prisma.linkedAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LinkedAccountUpdateManyArgs>(args: SelectSubset<T, LinkedAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LinkedAccount.
     * @param {LinkedAccountUpsertArgs} args - Arguments to update or create a LinkedAccount.
     * @example
     * // Update or create a LinkedAccount
     * const linkedAccount = await prisma.linkedAccount.upsert({
     *   create: {
     *     // ... data to create a LinkedAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LinkedAccount we want to update
     *   }
     * })
     */
    upsert<T extends LinkedAccountUpsertArgs>(args: SelectSubset<T, LinkedAccountUpsertArgs<ExtArgs>>): Prisma__LinkedAccountClient<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LinkedAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedAccountCountArgs} args - Arguments to filter LinkedAccounts to count.
     * @example
     * // Count the number of LinkedAccounts
     * const count = await prisma.linkedAccount.count({
     *   where: {
     *     // ... the filter for the LinkedAccounts we want to count
     *   }
     * })
    **/
    count<T extends LinkedAccountCountArgs>(
      args?: Subset<T, LinkedAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LinkedAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LinkedAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LinkedAccountAggregateArgs>(args: Subset<T, LinkedAccountAggregateArgs>): Prisma.PrismaPromise<GetLinkedAccountAggregateType<T>>

    /**
     * Group by LinkedAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LinkedAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LinkedAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LinkedAccountGroupByArgs['orderBy'] }
        : { orderBy?: LinkedAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LinkedAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLinkedAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LinkedAccount model
   */
  readonly fields: LinkedAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LinkedAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LinkedAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sourceTransactions<T extends LinkedAccount$sourceTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, LinkedAccount$sourceTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    targetTransactions<T extends LinkedAccount$targetTransactionsArgs<ExtArgs> = {}>(args?: Subset<T, LinkedAccount$targetTransactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LinkedAccount model
   */ 
  interface LinkedAccountFieldRefs {
    readonly id: FieldRef<"LinkedAccount", 'String'>
    readonly userId: FieldRef<"LinkedAccount", 'String'>
    readonly accountType: FieldRef<"LinkedAccount", 'AccountType'>
    readonly provider: FieldRef<"LinkedAccount", 'PaymentProvider'>
    readonly accountNumber: FieldRef<"LinkedAccount", 'String'>
    readonly accountName: FieldRef<"LinkedAccount", 'String'>
    readonly currency: FieldRef<"LinkedAccount", 'String'>
    readonly balance: FieldRef<"LinkedAccount", 'Float'>
    readonly isActive: FieldRef<"LinkedAccount", 'Boolean'>
    readonly isPrimary: FieldRef<"LinkedAccount", 'Boolean'>
    readonly priority: FieldRef<"LinkedAccount", 'Int'>
    readonly dailyLimit: FieldRef<"LinkedAccount", 'Float'>
    readonly monthlyLimit: FieldRef<"LinkedAccount", 'Float'>
    readonly linkedAt: FieldRef<"LinkedAccount", 'DateTime'>
    readonly lastSyncAt: FieldRef<"LinkedAccount", 'DateTime'>
    readonly createdAt: FieldRef<"LinkedAccount", 'DateTime'>
    readonly updatedAt: FieldRef<"LinkedAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LinkedAccount findUnique
   */
  export type LinkedAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
    /**
     * Filter, which LinkedAccount to fetch.
     */
    where: LinkedAccountWhereUniqueInput
  }

  /**
   * LinkedAccount findUniqueOrThrow
   */
  export type LinkedAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
    /**
     * Filter, which LinkedAccount to fetch.
     */
    where: LinkedAccountWhereUniqueInput
  }

  /**
   * LinkedAccount findFirst
   */
  export type LinkedAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
    /**
     * Filter, which LinkedAccount to fetch.
     */
    where?: LinkedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedAccounts to fetch.
     */
    orderBy?: LinkedAccountOrderByWithRelationInput | LinkedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkedAccounts.
     */
    cursor?: LinkedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkedAccounts.
     */
    distinct?: LinkedAccountScalarFieldEnum | LinkedAccountScalarFieldEnum[]
  }

  /**
   * LinkedAccount findFirstOrThrow
   */
  export type LinkedAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
    /**
     * Filter, which LinkedAccount to fetch.
     */
    where?: LinkedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedAccounts to fetch.
     */
    orderBy?: LinkedAccountOrderByWithRelationInput | LinkedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LinkedAccounts.
     */
    cursor?: LinkedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LinkedAccounts.
     */
    distinct?: LinkedAccountScalarFieldEnum | LinkedAccountScalarFieldEnum[]
  }

  /**
   * LinkedAccount findMany
   */
  export type LinkedAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
    /**
     * Filter, which LinkedAccounts to fetch.
     */
    where?: LinkedAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LinkedAccounts to fetch.
     */
    orderBy?: LinkedAccountOrderByWithRelationInput | LinkedAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LinkedAccounts.
     */
    cursor?: LinkedAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LinkedAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LinkedAccounts.
     */
    skip?: number
    distinct?: LinkedAccountScalarFieldEnum | LinkedAccountScalarFieldEnum[]
  }

  /**
   * LinkedAccount create
   */
  export type LinkedAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a LinkedAccount.
     */
    data: XOR<LinkedAccountCreateInput, LinkedAccountUncheckedCreateInput>
  }

  /**
   * LinkedAccount createMany
   */
  export type LinkedAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LinkedAccounts.
     */
    data: LinkedAccountCreateManyInput | LinkedAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LinkedAccount createManyAndReturn
   */
  export type LinkedAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LinkedAccounts.
     */
    data: LinkedAccountCreateManyInput | LinkedAccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LinkedAccount update
   */
  export type LinkedAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a LinkedAccount.
     */
    data: XOR<LinkedAccountUpdateInput, LinkedAccountUncheckedUpdateInput>
    /**
     * Choose, which LinkedAccount to update.
     */
    where: LinkedAccountWhereUniqueInput
  }

  /**
   * LinkedAccount updateMany
   */
  export type LinkedAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LinkedAccounts.
     */
    data: XOR<LinkedAccountUpdateManyMutationInput, LinkedAccountUncheckedUpdateManyInput>
    /**
     * Filter which LinkedAccounts to update
     */
    where?: LinkedAccountWhereInput
  }

  /**
   * LinkedAccount upsert
   */
  export type LinkedAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the LinkedAccount to update in case it exists.
     */
    where: LinkedAccountWhereUniqueInput
    /**
     * In case the LinkedAccount found by the `where` argument doesn't exist, create a new LinkedAccount with this data.
     */
    create: XOR<LinkedAccountCreateInput, LinkedAccountUncheckedCreateInput>
    /**
     * In case the LinkedAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LinkedAccountUpdateInput, LinkedAccountUncheckedUpdateInput>
  }

  /**
   * LinkedAccount delete
   */
  export type LinkedAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
    /**
     * Filter which LinkedAccount to delete.
     */
    where: LinkedAccountWhereUniqueInput
  }

  /**
   * LinkedAccount deleteMany
   */
  export type LinkedAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LinkedAccounts to delete
     */
    where?: LinkedAccountWhereInput
  }

  /**
   * LinkedAccount.sourceTransactions
   */
  export type LinkedAccount$sourceTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    cursor?: PaymentTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * LinkedAccount.targetTransactions
   */
  export type LinkedAccount$targetTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    cursor?: PaymentTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * LinkedAccount without action
   */
  export type LinkedAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
  }


  /**
   * Model PaymentRequest
   */

  export type AggregatePaymentRequest = {
    _count: PaymentRequestCountAggregateOutputType | null
    _avg: PaymentRequestAvgAggregateOutputType | null
    _sum: PaymentRequestSumAggregateOutputType | null
    _min: PaymentRequestMinAggregateOutputType | null
    _max: PaymentRequestMaxAggregateOutputType | null
  }

  export type PaymentRequestAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentRequestSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    targetCurrency: string | null
    merchantId: string | null
    merchantName: string | null
    description: string | null
    qrCode: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    amount: number | null
    currency: string | null
    targetCurrency: string | null
    merchantId: string | null
    merchantName: string | null
    description: string | null
    qrCode: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentRequestCountAggregateOutputType = {
    id: number
    userId: number
    amount: number
    currency: number
    targetCurrency: number
    merchantId: number
    merchantName: number
    description: number
    qrCode: number
    metadata: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentRequestAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentRequestSumAggregateInputType = {
    amount?: true
  }

  export type PaymentRequestMinAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    targetCurrency?: true
    merchantId?: true
    merchantName?: true
    description?: true
    qrCode?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    targetCurrency?: true
    merchantId?: true
    merchantName?: true
    description?: true
    qrCode?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentRequestCountAggregateInputType = {
    id?: true
    userId?: true
    amount?: true
    currency?: true
    targetCurrency?: true
    merchantId?: true
    merchantName?: true
    description?: true
    qrCode?: true
    metadata?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentRequest to aggregate.
     */
    where?: PaymentRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRequests to fetch.
     */
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentRequests
    **/
    _count?: true | PaymentRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentRequestMaxAggregateInputType
  }

  export type GetPaymentRequestAggregateType<T extends PaymentRequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentRequest[P]>
      : GetScalarType<T[P], AggregatePaymentRequest[P]>
  }




  export type PaymentRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentRequestWhereInput
    orderBy?: PaymentRequestOrderByWithAggregationInput | PaymentRequestOrderByWithAggregationInput[]
    by: PaymentRequestScalarFieldEnum[] | PaymentRequestScalarFieldEnum
    having?: PaymentRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentRequestCountAggregateInputType | true
    _avg?: PaymentRequestAvgAggregateInputType
    _sum?: PaymentRequestSumAggregateInputType
    _min?: PaymentRequestMinAggregateInputType
    _max?: PaymentRequestMaxAggregateInputType
  }

  export type PaymentRequestGroupByOutputType = {
    id: string
    userId: string
    amount: number
    currency: string
    targetCurrency: string | null
    merchantId: string | null
    merchantName: string | null
    description: string | null
    qrCode: string | null
    metadata: JsonValue | null
    expiresAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentRequestCountAggregateOutputType | null
    _avg: PaymentRequestAvgAggregateOutputType | null
    _sum: PaymentRequestSumAggregateOutputType | null
    _min: PaymentRequestMinAggregateOutputType | null
    _max: PaymentRequestMaxAggregateOutputType | null
  }

  type GetPaymentRequestGroupByPayload<T extends PaymentRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentRequestGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentRequestGroupByOutputType[P]>
        }
      >
    >


  export type PaymentRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    targetCurrency?: boolean
    merchantId?: boolean
    merchantName?: boolean
    description?: boolean
    qrCode?: boolean
    metadata?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | PaymentRequest$transactionsArgs<ExtArgs>
    _count?: boolean | PaymentRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentRequest"]>

  export type PaymentRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    targetCurrency?: boolean
    merchantId?: boolean
    merchantName?: boolean
    description?: boolean
    qrCode?: boolean
    metadata?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentRequest"]>

  export type PaymentRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    amount?: boolean
    currency?: boolean
    targetCurrency?: boolean
    merchantId?: boolean
    merchantName?: boolean
    description?: boolean
    qrCode?: boolean
    metadata?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    transactions?: boolean | PaymentRequest$transactionsArgs<ExtArgs>
    _count?: boolean | PaymentRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PaymentRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      transactions: Prisma.$PaymentTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      amount: number
      currency: string
      targetCurrency: string | null
      merchantId: string | null
      merchantName: string | null
      description: string | null
      qrCode: string | null
      metadata: Prisma.JsonValue | null
      expiresAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentRequest"]>
    composites: {}
  }

  type PaymentRequestGetPayload<S extends boolean | null | undefined | PaymentRequestDefaultArgs> = $Result.GetResult<Prisma.$PaymentRequestPayload, S>

  type PaymentRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentRequestCountAggregateInputType | true
    }

  export interface PaymentRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentRequest'], meta: { name: 'PaymentRequest' } }
    /**
     * Find zero or one PaymentRequest that matches the filter.
     * @param {PaymentRequestFindUniqueArgs} args - Arguments to find a PaymentRequest
     * @example
     * // Get one PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentRequestFindUniqueArgs>(args: SelectSubset<T, PaymentRequestFindUniqueArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentRequestFindUniqueOrThrowArgs} args - Arguments to find a PaymentRequest
     * @example
     * // Get one PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestFindFirstArgs} args - Arguments to find a PaymentRequest
     * @example
     * // Get one PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentRequestFindFirstArgs>(args?: SelectSubset<T, PaymentRequestFindFirstArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestFindFirstOrThrowArgs} args - Arguments to find a PaymentRequest
     * @example
     * // Get one PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentRequests
     * const paymentRequests = await prisma.paymentRequest.findMany()
     * 
     * // Get first 10 PaymentRequests
     * const paymentRequests = await prisma.paymentRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentRequestWithIdOnly = await prisma.paymentRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentRequestFindManyArgs>(args?: SelectSubset<T, PaymentRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentRequest.
     * @param {PaymentRequestCreateArgs} args - Arguments to create a PaymentRequest.
     * @example
     * // Create one PaymentRequest
     * const PaymentRequest = await prisma.paymentRequest.create({
     *   data: {
     *     // ... data to create a PaymentRequest
     *   }
     * })
     * 
     */
    create<T extends PaymentRequestCreateArgs>(args: SelectSubset<T, PaymentRequestCreateArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentRequests.
     * @param {PaymentRequestCreateManyArgs} args - Arguments to create many PaymentRequests.
     * @example
     * // Create many PaymentRequests
     * const paymentRequest = await prisma.paymentRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentRequestCreateManyArgs>(args?: SelectSubset<T, PaymentRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentRequests and returns the data saved in the database.
     * @param {PaymentRequestCreateManyAndReturnArgs} args - Arguments to create many PaymentRequests.
     * @example
     * // Create many PaymentRequests
     * const paymentRequest = await prisma.paymentRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentRequests and only return the `id`
     * const paymentRequestWithIdOnly = await prisma.paymentRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentRequest.
     * @param {PaymentRequestDeleteArgs} args - Arguments to delete one PaymentRequest.
     * @example
     * // Delete one PaymentRequest
     * const PaymentRequest = await prisma.paymentRequest.delete({
     *   where: {
     *     // ... filter to delete one PaymentRequest
     *   }
     * })
     * 
     */
    delete<T extends PaymentRequestDeleteArgs>(args: SelectSubset<T, PaymentRequestDeleteArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentRequest.
     * @param {PaymentRequestUpdateArgs} args - Arguments to update one PaymentRequest.
     * @example
     * // Update one PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentRequestUpdateArgs>(args: SelectSubset<T, PaymentRequestUpdateArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentRequests.
     * @param {PaymentRequestDeleteManyArgs} args - Arguments to filter PaymentRequests to delete.
     * @example
     * // Delete a few PaymentRequests
     * const { count } = await prisma.paymentRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentRequestDeleteManyArgs>(args?: SelectSubset<T, PaymentRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentRequests
     * const paymentRequest = await prisma.paymentRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentRequestUpdateManyArgs>(args: SelectSubset<T, PaymentRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentRequest.
     * @param {PaymentRequestUpsertArgs} args - Arguments to update or create a PaymentRequest.
     * @example
     * // Update or create a PaymentRequest
     * const paymentRequest = await prisma.paymentRequest.upsert({
     *   create: {
     *     // ... data to create a PaymentRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentRequest we want to update
     *   }
     * })
     */
    upsert<T extends PaymentRequestUpsertArgs>(args: SelectSubset<T, PaymentRequestUpsertArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestCountArgs} args - Arguments to filter PaymentRequests to count.
     * @example
     * // Count the number of PaymentRequests
     * const count = await prisma.paymentRequest.count({
     *   where: {
     *     // ... the filter for the PaymentRequests we want to count
     *   }
     * })
    **/
    count<T extends PaymentRequestCountArgs>(
      args?: Subset<T, PaymentRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentRequestAggregateArgs>(args: Subset<T, PaymentRequestAggregateArgs>): Prisma.PrismaPromise<GetPaymentRequestAggregateType<T>>

    /**
     * Group by PaymentRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentRequestGroupByArgs['orderBy'] }
        : { orderBy?: PaymentRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentRequest model
   */
  readonly fields: PaymentRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    transactions<T extends PaymentRequest$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentRequest$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentRequest model
   */ 
  interface PaymentRequestFieldRefs {
    readonly id: FieldRef<"PaymentRequest", 'String'>
    readonly userId: FieldRef<"PaymentRequest", 'String'>
    readonly amount: FieldRef<"PaymentRequest", 'Float'>
    readonly currency: FieldRef<"PaymentRequest", 'String'>
    readonly targetCurrency: FieldRef<"PaymentRequest", 'String'>
    readonly merchantId: FieldRef<"PaymentRequest", 'String'>
    readonly merchantName: FieldRef<"PaymentRequest", 'String'>
    readonly description: FieldRef<"PaymentRequest", 'String'>
    readonly qrCode: FieldRef<"PaymentRequest", 'String'>
    readonly metadata: FieldRef<"PaymentRequest", 'Json'>
    readonly expiresAt: FieldRef<"PaymentRequest", 'DateTime'>
    readonly createdAt: FieldRef<"PaymentRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentRequest findUnique
   */
  export type PaymentRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRequest to fetch.
     */
    where: PaymentRequestWhereUniqueInput
  }

  /**
   * PaymentRequest findUniqueOrThrow
   */
  export type PaymentRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRequest to fetch.
     */
    where: PaymentRequestWhereUniqueInput
  }

  /**
   * PaymentRequest findFirst
   */
  export type PaymentRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRequest to fetch.
     */
    where?: PaymentRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRequests to fetch.
     */
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentRequests.
     */
    cursor?: PaymentRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentRequests.
     */
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * PaymentRequest findFirstOrThrow
   */
  export type PaymentRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRequest to fetch.
     */
    where?: PaymentRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRequests to fetch.
     */
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentRequests.
     */
    cursor?: PaymentRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentRequests.
     */
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * PaymentRequest findMany
   */
  export type PaymentRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter, which PaymentRequests to fetch.
     */
    where?: PaymentRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentRequests to fetch.
     */
    orderBy?: PaymentRequestOrderByWithRelationInput | PaymentRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentRequests.
     */
    cursor?: PaymentRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentRequests.
     */
    skip?: number
    distinct?: PaymentRequestScalarFieldEnum | PaymentRequestScalarFieldEnum[]
  }

  /**
   * PaymentRequest create
   */
  export type PaymentRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentRequest.
     */
    data: XOR<PaymentRequestCreateInput, PaymentRequestUncheckedCreateInput>
  }

  /**
   * PaymentRequest createMany
   */
  export type PaymentRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentRequests.
     */
    data: PaymentRequestCreateManyInput | PaymentRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentRequest createManyAndReturn
   */
  export type PaymentRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentRequests.
     */
    data: PaymentRequestCreateManyInput | PaymentRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentRequest update
   */
  export type PaymentRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentRequest.
     */
    data: XOR<PaymentRequestUpdateInput, PaymentRequestUncheckedUpdateInput>
    /**
     * Choose, which PaymentRequest to update.
     */
    where: PaymentRequestWhereUniqueInput
  }

  /**
   * PaymentRequest updateMany
   */
  export type PaymentRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentRequests.
     */
    data: XOR<PaymentRequestUpdateManyMutationInput, PaymentRequestUncheckedUpdateManyInput>
    /**
     * Filter which PaymentRequests to update
     */
    where?: PaymentRequestWhereInput
  }

  /**
   * PaymentRequest upsert
   */
  export type PaymentRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentRequest to update in case it exists.
     */
    where: PaymentRequestWhereUniqueInput
    /**
     * In case the PaymentRequest found by the `where` argument doesn't exist, create a new PaymentRequest with this data.
     */
    create: XOR<PaymentRequestCreateInput, PaymentRequestUncheckedCreateInput>
    /**
     * In case the PaymentRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentRequestUpdateInput, PaymentRequestUncheckedUpdateInput>
  }

  /**
   * PaymentRequest delete
   */
  export type PaymentRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    /**
     * Filter which PaymentRequest to delete.
     */
    where: PaymentRequestWhereUniqueInput
  }

  /**
   * PaymentRequest deleteMany
   */
  export type PaymentRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentRequests to delete
     */
    where?: PaymentRequestWhereInput
  }

  /**
   * PaymentRequest.transactions
   */
  export type PaymentRequest$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    cursor?: PaymentTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentRequest without action
   */
  export type PaymentRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
  }


  /**
   * Model PaymentTransaction
   */

  export type AggregatePaymentTransaction = {
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  export type PaymentTransactionAvgAggregateOutputType = {
    amount: number | null
    targetAmount: number | null
    exchangeRate: number | null
  }

  export type PaymentTransactionSumAggregateOutputType = {
    amount: number | null
    targetAmount: number | null
    exchangeRate: number | null
  }

  export type PaymentTransactionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    paymentRequestId: string | null
    amount: number | null
    currency: string | null
    targetAmount: number | null
    targetCurrency: string | null
    exchangeRate: number | null
    sourceAccountId: string | null
    targetAccountId: string | null
    status: $Enums.TransactionStatus | null
    failureReason: string | null
    merchantName: string | null
    merchantCategory: string | null
    merchantLocation: string | null
    initiatedAt: Date | null
    completedAt: Date | null
    failedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentTransactionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    paymentRequestId: string | null
    amount: number | null
    currency: string | null
    targetAmount: number | null
    targetCurrency: string | null
    exchangeRate: number | null
    sourceAccountId: string | null
    targetAccountId: string | null
    status: $Enums.TransactionStatus | null
    failureReason: string | null
    merchantName: string | null
    merchantCategory: string | null
    merchantLocation: string | null
    initiatedAt: Date | null
    completedAt: Date | null
    failedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentTransactionCountAggregateOutputType = {
    id: number
    userId: number
    paymentRequestId: number
    amount: number
    currency: number
    targetAmount: number
    targetCurrency: number
    exchangeRate: number
    sourceAccountId: number
    targetAccountId: number
    status: number
    failureReason: number
    merchantName: number
    merchantCategory: number
    merchantLocation: number
    metadata: number
    initiatedAt: number
    completedAt: number
    failedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentTransactionAvgAggregateInputType = {
    amount?: true
    targetAmount?: true
    exchangeRate?: true
  }

  export type PaymentTransactionSumAggregateInputType = {
    amount?: true
    targetAmount?: true
    exchangeRate?: true
  }

  export type PaymentTransactionMinAggregateInputType = {
    id?: true
    userId?: true
    paymentRequestId?: true
    amount?: true
    currency?: true
    targetAmount?: true
    targetCurrency?: true
    exchangeRate?: true
    sourceAccountId?: true
    targetAccountId?: true
    status?: true
    failureReason?: true
    merchantName?: true
    merchantCategory?: true
    merchantLocation?: true
    initiatedAt?: true
    completedAt?: true
    failedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentTransactionMaxAggregateInputType = {
    id?: true
    userId?: true
    paymentRequestId?: true
    amount?: true
    currency?: true
    targetAmount?: true
    targetCurrency?: true
    exchangeRate?: true
    sourceAccountId?: true
    targetAccountId?: true
    status?: true
    failureReason?: true
    merchantName?: true
    merchantCategory?: true
    merchantLocation?: true
    initiatedAt?: true
    completedAt?: true
    failedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentTransactionCountAggregateInputType = {
    id?: true
    userId?: true
    paymentRequestId?: true
    amount?: true
    currency?: true
    targetAmount?: true
    targetCurrency?: true
    exchangeRate?: true
    sourceAccountId?: true
    targetAccountId?: true
    status?: true
    failureReason?: true
    merchantName?: true
    merchantCategory?: true
    merchantLocation?: true
    metadata?: true
    initiatedAt?: true
    completedAt?: true
    failedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransaction to aggregate.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentTransactions
    **/
    _count?: true | PaymentTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type GetPaymentTransactionAggregateType<T extends PaymentTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentTransaction[P]>
      : GetScalarType<T[P], AggregatePaymentTransaction[P]>
  }




  export type PaymentTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentTransactionWhereInput
    orderBy?: PaymentTransactionOrderByWithAggregationInput | PaymentTransactionOrderByWithAggregationInput[]
    by: PaymentTransactionScalarFieldEnum[] | PaymentTransactionScalarFieldEnum
    having?: PaymentTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentTransactionCountAggregateInputType | true
    _avg?: PaymentTransactionAvgAggregateInputType
    _sum?: PaymentTransactionSumAggregateInputType
    _min?: PaymentTransactionMinAggregateInputType
    _max?: PaymentTransactionMaxAggregateInputType
  }

  export type PaymentTransactionGroupByOutputType = {
    id: string
    userId: string
    paymentRequestId: string | null
    amount: number
    currency: string
    targetAmount: number | null
    targetCurrency: string | null
    exchangeRate: number | null
    sourceAccountId: string
    targetAccountId: string | null
    status: $Enums.TransactionStatus
    failureReason: string | null
    merchantName: string | null
    merchantCategory: string | null
    merchantLocation: string | null
    metadata: JsonValue | null
    initiatedAt: Date
    completedAt: Date | null
    failedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentTransactionCountAggregateOutputType | null
    _avg: PaymentTransactionAvgAggregateOutputType | null
    _sum: PaymentTransactionSumAggregateOutputType | null
    _min: PaymentTransactionMinAggregateOutputType | null
    _max: PaymentTransactionMaxAggregateOutputType | null
  }

  type GetPaymentTransactionGroupByPayload<T extends PaymentTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentTransactionGroupByOutputType[P]>
        }
      >
    >


  export type PaymentTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentRequestId?: boolean
    amount?: boolean
    currency?: boolean
    targetAmount?: boolean
    targetCurrency?: boolean
    exchangeRate?: boolean
    sourceAccountId?: boolean
    targetAccountId?: boolean
    status?: boolean
    failureReason?: boolean
    merchantName?: boolean
    merchantCategory?: boolean
    merchantLocation?: boolean
    metadata?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    failedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentRequest?: boolean | PaymentTransaction$paymentRequestArgs<ExtArgs>
    sourceAccount?: boolean | LinkedAccountDefaultArgs<ExtArgs>
    targetAccount?: boolean | PaymentTransaction$targetAccountArgs<ExtArgs>
    routingSteps?: boolean | PaymentTransaction$routingStepsArgs<ExtArgs>
    fees?: boolean | PaymentTransaction$feesArgs<ExtArgs>
    _count?: boolean | PaymentTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    paymentRequestId?: boolean
    amount?: boolean
    currency?: boolean
    targetAmount?: boolean
    targetCurrency?: boolean
    exchangeRate?: boolean
    sourceAccountId?: boolean
    targetAccountId?: boolean
    status?: boolean
    failureReason?: boolean
    merchantName?: boolean
    merchantCategory?: boolean
    merchantLocation?: boolean
    metadata?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    failedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentRequest?: boolean | PaymentTransaction$paymentRequestArgs<ExtArgs>
    sourceAccount?: boolean | LinkedAccountDefaultArgs<ExtArgs>
    targetAccount?: boolean | PaymentTransaction$targetAccountArgs<ExtArgs>
  }, ExtArgs["result"]["paymentTransaction"]>

  export type PaymentTransactionSelectScalar = {
    id?: boolean
    userId?: boolean
    paymentRequestId?: boolean
    amount?: boolean
    currency?: boolean
    targetAmount?: boolean
    targetCurrency?: boolean
    exchangeRate?: boolean
    sourceAccountId?: boolean
    targetAccountId?: boolean
    status?: boolean
    failureReason?: boolean
    merchantName?: boolean
    merchantCategory?: boolean
    merchantLocation?: boolean
    metadata?: boolean
    initiatedAt?: boolean
    completedAt?: boolean
    failedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentRequest?: boolean | PaymentTransaction$paymentRequestArgs<ExtArgs>
    sourceAccount?: boolean | LinkedAccountDefaultArgs<ExtArgs>
    targetAccount?: boolean | PaymentTransaction$targetAccountArgs<ExtArgs>
    routingSteps?: boolean | PaymentTransaction$routingStepsArgs<ExtArgs>
    fees?: boolean | PaymentTransaction$feesArgs<ExtArgs>
    _count?: boolean | PaymentTransactionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    paymentRequest?: boolean | PaymentTransaction$paymentRequestArgs<ExtArgs>
    sourceAccount?: boolean | LinkedAccountDefaultArgs<ExtArgs>
    targetAccount?: boolean | PaymentTransaction$targetAccountArgs<ExtArgs>
  }

  export type $PaymentTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentTransaction"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      paymentRequest: Prisma.$PaymentRequestPayload<ExtArgs> | null
      sourceAccount: Prisma.$LinkedAccountPayload<ExtArgs>
      targetAccount: Prisma.$LinkedAccountPayload<ExtArgs> | null
      routingSteps: Prisma.$RoutingStepPayload<ExtArgs>[]
      fees: Prisma.$TransactionFeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      paymentRequestId: string | null
      amount: number
      currency: string
      targetAmount: number | null
      targetCurrency: string | null
      exchangeRate: number | null
      sourceAccountId: string
      targetAccountId: string | null
      status: $Enums.TransactionStatus
      failureReason: string | null
      merchantName: string | null
      merchantCategory: string | null
      merchantLocation: string | null
      metadata: Prisma.JsonValue | null
      initiatedAt: Date
      completedAt: Date | null
      failedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentTransaction"]>
    composites: {}
  }

  type PaymentTransactionGetPayload<S extends boolean | null | undefined | PaymentTransactionDefaultArgs> = $Result.GetResult<Prisma.$PaymentTransactionPayload, S>

  type PaymentTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentTransactionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentTransactionCountAggregateInputType | true
    }

  export interface PaymentTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentTransaction'], meta: { name: 'PaymentTransaction' } }
    /**
     * Find zero or one PaymentTransaction that matches the filter.
     * @param {PaymentTransactionFindUniqueArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentTransactionFindUniqueArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentTransaction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentTransactionFindUniqueOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentTransactionFindFirstArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindFirstOrThrowArgs} args - Arguments to find a PaymentTransaction
     * @example
     * // Get one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany()
     * 
     * // Get first 10 PaymentTransactions
     * const paymentTransactions = await prisma.paymentTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentTransactionFindManyArgs>(args?: SelectSubset<T, PaymentTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentTransaction.
     * @param {PaymentTransactionCreateArgs} args - Arguments to create a PaymentTransaction.
     * @example
     * // Create one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.create({
     *   data: {
     *     // ... data to create a PaymentTransaction
     *   }
     * })
     * 
     */
    create<T extends PaymentTransactionCreateArgs>(args: SelectSubset<T, PaymentTransactionCreateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentTransactions.
     * @param {PaymentTransactionCreateManyArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentTransactionCreateManyArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentTransactions and returns the data saved in the database.
     * @param {PaymentTransactionCreateManyAndReturnArgs} args - Arguments to create many PaymentTransactions.
     * @example
     * // Create many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentTransactions and only return the `id`
     * const paymentTransactionWithIdOnly = await prisma.paymentTransaction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentTransaction.
     * @param {PaymentTransactionDeleteArgs} args - Arguments to delete one PaymentTransaction.
     * @example
     * // Delete one PaymentTransaction
     * const PaymentTransaction = await prisma.paymentTransaction.delete({
     *   where: {
     *     // ... filter to delete one PaymentTransaction
     *   }
     * })
     * 
     */
    delete<T extends PaymentTransactionDeleteArgs>(args: SelectSubset<T, PaymentTransactionDeleteArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentTransaction.
     * @param {PaymentTransactionUpdateArgs} args - Arguments to update one PaymentTransaction.
     * @example
     * // Update one PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentTransactionUpdateArgs>(args: SelectSubset<T, PaymentTransactionUpdateArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentTransactions.
     * @param {PaymentTransactionDeleteManyArgs} args - Arguments to filter PaymentTransactions to delete.
     * @example
     * // Delete a few PaymentTransactions
     * const { count } = await prisma.paymentTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentTransactionDeleteManyArgs>(args?: SelectSubset<T, PaymentTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentTransactions
     * const paymentTransaction = await prisma.paymentTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentTransactionUpdateManyArgs>(args: SelectSubset<T, PaymentTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentTransaction.
     * @param {PaymentTransactionUpsertArgs} args - Arguments to update or create a PaymentTransaction.
     * @example
     * // Update or create a PaymentTransaction
     * const paymentTransaction = await prisma.paymentTransaction.upsert({
     *   create: {
     *     // ... data to create a PaymentTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentTransaction we want to update
     *   }
     * })
     */
    upsert<T extends PaymentTransactionUpsertArgs>(args: SelectSubset<T, PaymentTransactionUpsertArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionCountArgs} args - Arguments to filter PaymentTransactions to count.
     * @example
     * // Count the number of PaymentTransactions
     * const count = await prisma.paymentTransaction.count({
     *   where: {
     *     // ... the filter for the PaymentTransactions we want to count
     *   }
     * })
    **/
    count<T extends PaymentTransactionCountArgs>(
      args?: Subset<T, PaymentTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentTransactionAggregateArgs>(args: Subset<T, PaymentTransactionAggregateArgs>): Prisma.PrismaPromise<GetPaymentTransactionAggregateType<T>>

    /**
     * Group by PaymentTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentTransactionGroupByArgs['orderBy'] }
        : { orderBy?: PaymentTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentTransaction model
   */
  readonly fields: PaymentTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    paymentRequest<T extends PaymentTransaction$paymentRequestArgs<ExtArgs> = {}>(args?: Subset<T, PaymentTransaction$paymentRequestArgs<ExtArgs>>): Prisma__PaymentRequestClient<$Result.GetResult<Prisma.$PaymentRequestPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    sourceAccount<T extends LinkedAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LinkedAccountDefaultArgs<ExtArgs>>): Prisma__LinkedAccountClient<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    targetAccount<T extends PaymentTransaction$targetAccountArgs<ExtArgs> = {}>(args?: Subset<T, PaymentTransaction$targetAccountArgs<ExtArgs>>): Prisma__LinkedAccountClient<$Result.GetResult<Prisma.$LinkedAccountPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    routingSteps<T extends PaymentTransaction$routingStepsArgs<ExtArgs> = {}>(args?: Subset<T, PaymentTransaction$routingStepsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "findMany"> | Null>
    fees<T extends PaymentTransaction$feesArgs<ExtArgs> = {}>(args?: Subset<T, PaymentTransaction$feesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentTransaction model
   */ 
  interface PaymentTransactionFieldRefs {
    readonly id: FieldRef<"PaymentTransaction", 'String'>
    readonly userId: FieldRef<"PaymentTransaction", 'String'>
    readonly paymentRequestId: FieldRef<"PaymentTransaction", 'String'>
    readonly amount: FieldRef<"PaymentTransaction", 'Float'>
    readonly currency: FieldRef<"PaymentTransaction", 'String'>
    readonly targetAmount: FieldRef<"PaymentTransaction", 'Float'>
    readonly targetCurrency: FieldRef<"PaymentTransaction", 'String'>
    readonly exchangeRate: FieldRef<"PaymentTransaction", 'Float'>
    readonly sourceAccountId: FieldRef<"PaymentTransaction", 'String'>
    readonly targetAccountId: FieldRef<"PaymentTransaction", 'String'>
    readonly status: FieldRef<"PaymentTransaction", 'TransactionStatus'>
    readonly failureReason: FieldRef<"PaymentTransaction", 'String'>
    readonly merchantName: FieldRef<"PaymentTransaction", 'String'>
    readonly merchantCategory: FieldRef<"PaymentTransaction", 'String'>
    readonly merchantLocation: FieldRef<"PaymentTransaction", 'String'>
    readonly metadata: FieldRef<"PaymentTransaction", 'Json'>
    readonly initiatedAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly completedAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly failedAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly createdAt: FieldRef<"PaymentTransaction", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentTransaction findUnique
   */
  export type PaymentTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findUniqueOrThrow
   */
  export type PaymentTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction findFirst
   */
  export type PaymentTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findFirstOrThrow
   */
  export type PaymentTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransaction to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentTransactions.
     */
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction findMany
   */
  export type PaymentTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter, which PaymentTransactions to fetch.
     */
    where?: PaymentTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentTransactions to fetch.
     */
    orderBy?: PaymentTransactionOrderByWithRelationInput | PaymentTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentTransactions.
     */
    cursor?: PaymentTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentTransactions.
     */
    skip?: number
    distinct?: PaymentTransactionScalarFieldEnum | PaymentTransactionScalarFieldEnum[]
  }

  /**
   * PaymentTransaction create
   */
  export type PaymentTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a PaymentTransaction.
     */
    data: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
  }

  /**
   * PaymentTransaction createMany
   */
  export type PaymentTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentTransaction createManyAndReturn
   */
  export type PaymentTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentTransactions.
     */
    data: PaymentTransactionCreateManyInput | PaymentTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PaymentTransaction update
   */
  export type PaymentTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a PaymentTransaction.
     */
    data: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
    /**
     * Choose, which PaymentTransaction to update.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction updateMany
   */
  export type PaymentTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentTransactions.
     */
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyInput>
    /**
     * Filter which PaymentTransactions to update
     */
    where?: PaymentTransactionWhereInput
  }

  /**
   * PaymentTransaction upsert
   */
  export type PaymentTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the PaymentTransaction to update in case it exists.
     */
    where: PaymentTransactionWhereUniqueInput
    /**
     * In case the PaymentTransaction found by the `where` argument doesn't exist, create a new PaymentTransaction with this data.
     */
    create: XOR<PaymentTransactionCreateInput, PaymentTransactionUncheckedCreateInput>
    /**
     * In case the PaymentTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentTransactionUpdateInput, PaymentTransactionUncheckedUpdateInput>
  }

  /**
   * PaymentTransaction delete
   */
  export type PaymentTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
    /**
     * Filter which PaymentTransaction to delete.
     */
    where: PaymentTransactionWhereUniqueInput
  }

  /**
   * PaymentTransaction deleteMany
   */
  export type PaymentTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentTransactions to delete
     */
    where?: PaymentTransactionWhereInput
  }

  /**
   * PaymentTransaction.paymentRequest
   */
  export type PaymentTransaction$paymentRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentRequest
     */
    select?: PaymentRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentRequestInclude<ExtArgs> | null
    where?: PaymentRequestWhereInput
  }

  /**
   * PaymentTransaction.targetAccount
   */
  export type PaymentTransaction$targetAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LinkedAccount
     */
    select?: LinkedAccountSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LinkedAccountInclude<ExtArgs> | null
    where?: LinkedAccountWhereInput
  }

  /**
   * PaymentTransaction.routingSteps
   */
  export type PaymentTransaction$routingStepsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepInclude<ExtArgs> | null
    where?: RoutingStepWhereInput
    orderBy?: RoutingStepOrderByWithRelationInput | RoutingStepOrderByWithRelationInput[]
    cursor?: RoutingStepWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoutingStepScalarFieldEnum | RoutingStepScalarFieldEnum[]
  }

  /**
   * PaymentTransaction.fees
   */
  export type PaymentTransaction$feesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    where?: TransactionFeeWhereInput
    orderBy?: TransactionFeeOrderByWithRelationInput | TransactionFeeOrderByWithRelationInput[]
    cursor?: TransactionFeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionFeeScalarFieldEnum | TransactionFeeScalarFieldEnum[]
  }

  /**
   * PaymentTransaction without action
   */
  export type PaymentTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentTransaction
     */
    select?: PaymentTransactionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentTransactionInclude<ExtArgs> | null
  }


  /**
   * Model RoutingStep
   */

  export type AggregateRoutingStep = {
    _count: RoutingStepCountAggregateOutputType | null
    _avg: RoutingStepAvgAggregateOutputType | null
    _sum: RoutingStepSumAggregateOutputType | null
    _min: RoutingStepMinAggregateOutputType | null
    _max: RoutingStepMaxAggregateOutputType | null
  }

  export type RoutingStepAvgAggregateOutputType = {
    stepNumber: number | null
    amount: number | null
    processingTime: number | null
  }

  export type RoutingStepSumAggregateOutputType = {
    stepNumber: number | null
    amount: number | null
    processingTime: number | null
  }

  export type RoutingStepMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    stepNumber: number | null
    provider: $Enums.PaymentProvider | null
    action: $Enums.RoutingAction | null
    amount: number | null
    currency: string | null
    status: $Enums.StepStatus | null
    processingTime: number | null
    externalTransactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoutingStepMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    stepNumber: number | null
    provider: $Enums.PaymentProvider | null
    action: $Enums.RoutingAction | null
    amount: number | null
    currency: string | null
    status: $Enums.StepStatus | null
    processingTime: number | null
    externalTransactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoutingStepCountAggregateOutputType = {
    id: number
    transactionId: number
    stepNumber: number
    provider: number
    action: number
    amount: number
    currency: number
    status: number
    processingTime: number
    externalTransactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoutingStepAvgAggregateInputType = {
    stepNumber?: true
    amount?: true
    processingTime?: true
  }

  export type RoutingStepSumAggregateInputType = {
    stepNumber?: true
    amount?: true
    processingTime?: true
  }

  export type RoutingStepMinAggregateInputType = {
    id?: true
    transactionId?: true
    stepNumber?: true
    provider?: true
    action?: true
    amount?: true
    currency?: true
    status?: true
    processingTime?: true
    externalTransactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoutingStepMaxAggregateInputType = {
    id?: true
    transactionId?: true
    stepNumber?: true
    provider?: true
    action?: true
    amount?: true
    currency?: true
    status?: true
    processingTime?: true
    externalTransactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoutingStepCountAggregateInputType = {
    id?: true
    transactionId?: true
    stepNumber?: true
    provider?: true
    action?: true
    amount?: true
    currency?: true
    status?: true
    processingTime?: true
    externalTransactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoutingStepAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutingStep to aggregate.
     */
    where?: RoutingStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingSteps to fetch.
     */
    orderBy?: RoutingStepOrderByWithRelationInput | RoutingStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoutingStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoutingSteps
    **/
    _count?: true | RoutingStepCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoutingStepAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoutingStepSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoutingStepMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoutingStepMaxAggregateInputType
  }

  export type GetRoutingStepAggregateType<T extends RoutingStepAggregateArgs> = {
        [P in keyof T & keyof AggregateRoutingStep]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoutingStep[P]>
      : GetScalarType<T[P], AggregateRoutingStep[P]>
  }




  export type RoutingStepGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutingStepWhereInput
    orderBy?: RoutingStepOrderByWithAggregationInput | RoutingStepOrderByWithAggregationInput[]
    by: RoutingStepScalarFieldEnum[] | RoutingStepScalarFieldEnum
    having?: RoutingStepScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoutingStepCountAggregateInputType | true
    _avg?: RoutingStepAvgAggregateInputType
    _sum?: RoutingStepSumAggregateInputType
    _min?: RoutingStepMinAggregateInputType
    _max?: RoutingStepMaxAggregateInputType
  }

  export type RoutingStepGroupByOutputType = {
    id: string
    transactionId: string
    stepNumber: number
    provider: $Enums.PaymentProvider
    action: $Enums.RoutingAction
    amount: number
    currency: string
    status: $Enums.StepStatus
    processingTime: number | null
    externalTransactionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: RoutingStepCountAggregateOutputType | null
    _avg: RoutingStepAvgAggregateOutputType | null
    _sum: RoutingStepSumAggregateOutputType | null
    _min: RoutingStepMinAggregateOutputType | null
    _max: RoutingStepMaxAggregateOutputType | null
  }

  type GetRoutingStepGroupByPayload<T extends RoutingStepGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoutingStepGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoutingStepGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoutingStepGroupByOutputType[P]>
            : GetScalarType<T[P], RoutingStepGroupByOutputType[P]>
        }
      >
    >


  export type RoutingStepSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    stepNumber?: boolean
    provider?: boolean
    action?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    processingTime?: boolean
    externalTransactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | PaymentTransactionDefaultArgs<ExtArgs>
    fees?: boolean | RoutingStep$feesArgs<ExtArgs>
    _count?: boolean | RoutingStepCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routingStep"]>

  export type RoutingStepSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    stepNumber?: boolean
    provider?: boolean
    action?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    processingTime?: boolean
    externalTransactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    transaction?: boolean | PaymentTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routingStep"]>

  export type RoutingStepSelectScalar = {
    id?: boolean
    transactionId?: boolean
    stepNumber?: boolean
    provider?: boolean
    action?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    processingTime?: boolean
    externalTransactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoutingStepInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | PaymentTransactionDefaultArgs<ExtArgs>
    fees?: boolean | RoutingStep$feesArgs<ExtArgs>
    _count?: boolean | RoutingStepCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RoutingStepIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | PaymentTransactionDefaultArgs<ExtArgs>
  }

  export type $RoutingStepPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoutingStep"
    objects: {
      transaction: Prisma.$PaymentTransactionPayload<ExtArgs>
      fees: Prisma.$RoutingStepFeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      stepNumber: number
      provider: $Enums.PaymentProvider
      action: $Enums.RoutingAction
      amount: number
      currency: string
      status: $Enums.StepStatus
      processingTime: number | null
      externalTransactionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["routingStep"]>
    composites: {}
  }

  type RoutingStepGetPayload<S extends boolean | null | undefined | RoutingStepDefaultArgs> = $Result.GetResult<Prisma.$RoutingStepPayload, S>

  type RoutingStepCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoutingStepFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoutingStepCountAggregateInputType | true
    }

  export interface RoutingStepDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoutingStep'], meta: { name: 'RoutingStep' } }
    /**
     * Find zero or one RoutingStep that matches the filter.
     * @param {RoutingStepFindUniqueArgs} args - Arguments to find a RoutingStep
     * @example
     * // Get one RoutingStep
     * const routingStep = await prisma.routingStep.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoutingStepFindUniqueArgs>(args: SelectSubset<T, RoutingStepFindUniqueArgs<ExtArgs>>): Prisma__RoutingStepClient<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoutingStep that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoutingStepFindUniqueOrThrowArgs} args - Arguments to find a RoutingStep
     * @example
     * // Get one RoutingStep
     * const routingStep = await prisma.routingStep.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoutingStepFindUniqueOrThrowArgs>(args: SelectSubset<T, RoutingStepFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoutingStepClient<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoutingStep that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepFindFirstArgs} args - Arguments to find a RoutingStep
     * @example
     * // Get one RoutingStep
     * const routingStep = await prisma.routingStep.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoutingStepFindFirstArgs>(args?: SelectSubset<T, RoutingStepFindFirstArgs<ExtArgs>>): Prisma__RoutingStepClient<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoutingStep that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepFindFirstOrThrowArgs} args - Arguments to find a RoutingStep
     * @example
     * // Get one RoutingStep
     * const routingStep = await prisma.routingStep.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoutingStepFindFirstOrThrowArgs>(args?: SelectSubset<T, RoutingStepFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoutingStepClient<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoutingSteps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoutingSteps
     * const routingSteps = await prisma.routingStep.findMany()
     * 
     * // Get first 10 RoutingSteps
     * const routingSteps = await prisma.routingStep.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routingStepWithIdOnly = await prisma.routingStep.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoutingStepFindManyArgs>(args?: SelectSubset<T, RoutingStepFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoutingStep.
     * @param {RoutingStepCreateArgs} args - Arguments to create a RoutingStep.
     * @example
     * // Create one RoutingStep
     * const RoutingStep = await prisma.routingStep.create({
     *   data: {
     *     // ... data to create a RoutingStep
     *   }
     * })
     * 
     */
    create<T extends RoutingStepCreateArgs>(args: SelectSubset<T, RoutingStepCreateArgs<ExtArgs>>): Prisma__RoutingStepClient<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoutingSteps.
     * @param {RoutingStepCreateManyArgs} args - Arguments to create many RoutingSteps.
     * @example
     * // Create many RoutingSteps
     * const routingStep = await prisma.routingStep.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoutingStepCreateManyArgs>(args?: SelectSubset<T, RoutingStepCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoutingSteps and returns the data saved in the database.
     * @param {RoutingStepCreateManyAndReturnArgs} args - Arguments to create many RoutingSteps.
     * @example
     * // Create many RoutingSteps
     * const routingStep = await prisma.routingStep.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoutingSteps and only return the `id`
     * const routingStepWithIdOnly = await prisma.routingStep.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoutingStepCreateManyAndReturnArgs>(args?: SelectSubset<T, RoutingStepCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoutingStep.
     * @param {RoutingStepDeleteArgs} args - Arguments to delete one RoutingStep.
     * @example
     * // Delete one RoutingStep
     * const RoutingStep = await prisma.routingStep.delete({
     *   where: {
     *     // ... filter to delete one RoutingStep
     *   }
     * })
     * 
     */
    delete<T extends RoutingStepDeleteArgs>(args: SelectSubset<T, RoutingStepDeleteArgs<ExtArgs>>): Prisma__RoutingStepClient<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoutingStep.
     * @param {RoutingStepUpdateArgs} args - Arguments to update one RoutingStep.
     * @example
     * // Update one RoutingStep
     * const routingStep = await prisma.routingStep.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoutingStepUpdateArgs>(args: SelectSubset<T, RoutingStepUpdateArgs<ExtArgs>>): Prisma__RoutingStepClient<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoutingSteps.
     * @param {RoutingStepDeleteManyArgs} args - Arguments to filter RoutingSteps to delete.
     * @example
     * // Delete a few RoutingSteps
     * const { count } = await prisma.routingStep.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoutingStepDeleteManyArgs>(args?: SelectSubset<T, RoutingStepDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoutingSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoutingSteps
     * const routingStep = await prisma.routingStep.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoutingStepUpdateManyArgs>(args: SelectSubset<T, RoutingStepUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoutingStep.
     * @param {RoutingStepUpsertArgs} args - Arguments to update or create a RoutingStep.
     * @example
     * // Update or create a RoutingStep
     * const routingStep = await prisma.routingStep.upsert({
     *   create: {
     *     // ... data to create a RoutingStep
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoutingStep we want to update
     *   }
     * })
     */
    upsert<T extends RoutingStepUpsertArgs>(args: SelectSubset<T, RoutingStepUpsertArgs<ExtArgs>>): Prisma__RoutingStepClient<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoutingSteps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepCountArgs} args - Arguments to filter RoutingSteps to count.
     * @example
     * // Count the number of RoutingSteps
     * const count = await prisma.routingStep.count({
     *   where: {
     *     // ... the filter for the RoutingSteps we want to count
     *   }
     * })
    **/
    count<T extends RoutingStepCountArgs>(
      args?: Subset<T, RoutingStepCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoutingStepCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoutingStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoutingStepAggregateArgs>(args: Subset<T, RoutingStepAggregateArgs>): Prisma.PrismaPromise<GetRoutingStepAggregateType<T>>

    /**
     * Group by RoutingStep.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoutingStepGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoutingStepGroupByArgs['orderBy'] }
        : { orderBy?: RoutingStepGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoutingStepGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoutingStepGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoutingStep model
   */
  readonly fields: RoutingStepFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoutingStep.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoutingStepClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends PaymentTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentTransactionDefaultArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    fees<T extends RoutingStep$feesArgs<ExtArgs> = {}>(args?: Subset<T, RoutingStep$feesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutingStepFeePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoutingStep model
   */ 
  interface RoutingStepFieldRefs {
    readonly id: FieldRef<"RoutingStep", 'String'>
    readonly transactionId: FieldRef<"RoutingStep", 'String'>
    readonly stepNumber: FieldRef<"RoutingStep", 'Int'>
    readonly provider: FieldRef<"RoutingStep", 'PaymentProvider'>
    readonly action: FieldRef<"RoutingStep", 'RoutingAction'>
    readonly amount: FieldRef<"RoutingStep", 'Float'>
    readonly currency: FieldRef<"RoutingStep", 'String'>
    readonly status: FieldRef<"RoutingStep", 'StepStatus'>
    readonly processingTime: FieldRef<"RoutingStep", 'Int'>
    readonly externalTransactionId: FieldRef<"RoutingStep", 'String'>
    readonly createdAt: FieldRef<"RoutingStep", 'DateTime'>
    readonly updatedAt: FieldRef<"RoutingStep", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoutingStep findUnique
   */
  export type RoutingStepFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepInclude<ExtArgs> | null
    /**
     * Filter, which RoutingStep to fetch.
     */
    where: RoutingStepWhereUniqueInput
  }

  /**
   * RoutingStep findUniqueOrThrow
   */
  export type RoutingStepFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepInclude<ExtArgs> | null
    /**
     * Filter, which RoutingStep to fetch.
     */
    where: RoutingStepWhereUniqueInput
  }

  /**
   * RoutingStep findFirst
   */
  export type RoutingStepFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepInclude<ExtArgs> | null
    /**
     * Filter, which RoutingStep to fetch.
     */
    where?: RoutingStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingSteps to fetch.
     */
    orderBy?: RoutingStepOrderByWithRelationInput | RoutingStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutingSteps.
     */
    cursor?: RoutingStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutingSteps.
     */
    distinct?: RoutingStepScalarFieldEnum | RoutingStepScalarFieldEnum[]
  }

  /**
   * RoutingStep findFirstOrThrow
   */
  export type RoutingStepFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepInclude<ExtArgs> | null
    /**
     * Filter, which RoutingStep to fetch.
     */
    where?: RoutingStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingSteps to fetch.
     */
    orderBy?: RoutingStepOrderByWithRelationInput | RoutingStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutingSteps.
     */
    cursor?: RoutingStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingSteps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutingSteps.
     */
    distinct?: RoutingStepScalarFieldEnum | RoutingStepScalarFieldEnum[]
  }

  /**
   * RoutingStep findMany
   */
  export type RoutingStepFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepInclude<ExtArgs> | null
    /**
     * Filter, which RoutingSteps to fetch.
     */
    where?: RoutingStepWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingSteps to fetch.
     */
    orderBy?: RoutingStepOrderByWithRelationInput | RoutingStepOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoutingSteps.
     */
    cursor?: RoutingStepWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingSteps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingSteps.
     */
    skip?: number
    distinct?: RoutingStepScalarFieldEnum | RoutingStepScalarFieldEnum[]
  }

  /**
   * RoutingStep create
   */
  export type RoutingStepCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepInclude<ExtArgs> | null
    /**
     * The data needed to create a RoutingStep.
     */
    data: XOR<RoutingStepCreateInput, RoutingStepUncheckedCreateInput>
  }

  /**
   * RoutingStep createMany
   */
  export type RoutingStepCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoutingSteps.
     */
    data: RoutingStepCreateManyInput | RoutingStepCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoutingStep createManyAndReturn
   */
  export type RoutingStepCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoutingSteps.
     */
    data: RoutingStepCreateManyInput | RoutingStepCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoutingStep update
   */
  export type RoutingStepUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepInclude<ExtArgs> | null
    /**
     * The data needed to update a RoutingStep.
     */
    data: XOR<RoutingStepUpdateInput, RoutingStepUncheckedUpdateInput>
    /**
     * Choose, which RoutingStep to update.
     */
    where: RoutingStepWhereUniqueInput
  }

  /**
   * RoutingStep updateMany
   */
  export type RoutingStepUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoutingSteps.
     */
    data: XOR<RoutingStepUpdateManyMutationInput, RoutingStepUncheckedUpdateManyInput>
    /**
     * Filter which RoutingSteps to update
     */
    where?: RoutingStepWhereInput
  }

  /**
   * RoutingStep upsert
   */
  export type RoutingStepUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepInclude<ExtArgs> | null
    /**
     * The filter to search for the RoutingStep to update in case it exists.
     */
    where: RoutingStepWhereUniqueInput
    /**
     * In case the RoutingStep found by the `where` argument doesn't exist, create a new RoutingStep with this data.
     */
    create: XOR<RoutingStepCreateInput, RoutingStepUncheckedCreateInput>
    /**
     * In case the RoutingStep was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoutingStepUpdateInput, RoutingStepUncheckedUpdateInput>
  }

  /**
   * RoutingStep delete
   */
  export type RoutingStepDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepInclude<ExtArgs> | null
    /**
     * Filter which RoutingStep to delete.
     */
    where: RoutingStepWhereUniqueInput
  }

  /**
   * RoutingStep deleteMany
   */
  export type RoutingStepDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutingSteps to delete
     */
    where?: RoutingStepWhereInput
  }

  /**
   * RoutingStep.fees
   */
  export type RoutingStep$feesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeInclude<ExtArgs> | null
    where?: RoutingStepFeeWhereInput
    orderBy?: RoutingStepFeeOrderByWithRelationInput | RoutingStepFeeOrderByWithRelationInput[]
    cursor?: RoutingStepFeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoutingStepFeeScalarFieldEnum | RoutingStepFeeScalarFieldEnum[]
  }

  /**
   * RoutingStep without action
   */
  export type RoutingStepDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStep
     */
    select?: RoutingStepSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepInclude<ExtArgs> | null
  }


  /**
   * Model TransactionFee
   */

  export type AggregateTransactionFee = {
    _count: TransactionFeeCountAggregateOutputType | null
    _avg: TransactionFeeAvgAggregateOutputType | null
    _sum: TransactionFeeSumAggregateOutputType | null
    _min: TransactionFeeMinAggregateOutputType | null
    _max: TransactionFeeMaxAggregateOutputType | null
  }

  export type TransactionFeeAvgAggregateOutputType = {
    amount: number | null
  }

  export type TransactionFeeSumAggregateOutputType = {
    amount: number | null
  }

  export type TransactionFeeMinAggregateOutputType = {
    id: string | null
    transactionId: string | null
    type: $Enums.FeeType | null
    amount: number | null
    currency: string | null
    description: string | null
    createdAt: Date | null
  }

  export type TransactionFeeMaxAggregateOutputType = {
    id: string | null
    transactionId: string | null
    type: $Enums.FeeType | null
    amount: number | null
    currency: string | null
    description: string | null
    createdAt: Date | null
  }

  export type TransactionFeeCountAggregateOutputType = {
    id: number
    transactionId: number
    type: number
    amount: number
    currency: number
    description: number
    createdAt: number
    _all: number
  }


  export type TransactionFeeAvgAggregateInputType = {
    amount?: true
  }

  export type TransactionFeeSumAggregateInputType = {
    amount?: true
  }

  export type TransactionFeeMinAggregateInputType = {
    id?: true
    transactionId?: true
    type?: true
    amount?: true
    currency?: true
    description?: true
    createdAt?: true
  }

  export type TransactionFeeMaxAggregateInputType = {
    id?: true
    transactionId?: true
    type?: true
    amount?: true
    currency?: true
    description?: true
    createdAt?: true
  }

  export type TransactionFeeCountAggregateInputType = {
    id?: true
    transactionId?: true
    type?: true
    amount?: true
    currency?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type TransactionFeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionFee to aggregate.
     */
    where?: TransactionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFees to fetch.
     */
    orderBy?: TransactionFeeOrderByWithRelationInput | TransactionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransactionFees
    **/
    _count?: true | TransactionFeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionFeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionFeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionFeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionFeeMaxAggregateInputType
  }

  export type GetTransactionFeeAggregateType<T extends TransactionFeeAggregateArgs> = {
        [P in keyof T & keyof AggregateTransactionFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransactionFee[P]>
      : GetScalarType<T[P], AggregateTransactionFee[P]>
  }




  export type TransactionFeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionFeeWhereInput
    orderBy?: TransactionFeeOrderByWithAggregationInput | TransactionFeeOrderByWithAggregationInput[]
    by: TransactionFeeScalarFieldEnum[] | TransactionFeeScalarFieldEnum
    having?: TransactionFeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionFeeCountAggregateInputType | true
    _avg?: TransactionFeeAvgAggregateInputType
    _sum?: TransactionFeeSumAggregateInputType
    _min?: TransactionFeeMinAggregateInputType
    _max?: TransactionFeeMaxAggregateInputType
  }

  export type TransactionFeeGroupByOutputType = {
    id: string
    transactionId: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt: Date
    _count: TransactionFeeCountAggregateOutputType | null
    _avg: TransactionFeeAvgAggregateOutputType | null
    _sum: TransactionFeeSumAggregateOutputType | null
    _min: TransactionFeeMinAggregateOutputType | null
    _max: TransactionFeeMaxAggregateOutputType | null
  }

  type GetTransactionFeeGroupByPayload<T extends TransactionFeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionFeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionFeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionFeeGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionFeeGroupByOutputType[P]>
        }
      >
    >


  export type TransactionFeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    createdAt?: boolean
    transaction?: boolean | PaymentTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionFee"]>

  export type TransactionFeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    transactionId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    createdAt?: boolean
    transaction?: boolean | PaymentTransactionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transactionFee"]>

  export type TransactionFeeSelectScalar = {
    id?: boolean
    transactionId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type TransactionFeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | PaymentTransactionDefaultArgs<ExtArgs>
  }
  export type TransactionFeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transaction?: boolean | PaymentTransactionDefaultArgs<ExtArgs>
  }

  export type $TransactionFeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TransactionFee"
    objects: {
      transaction: Prisma.$PaymentTransactionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      transactionId: string
      type: $Enums.FeeType
      amount: number
      currency: string
      description: string
      createdAt: Date
    }, ExtArgs["result"]["transactionFee"]>
    composites: {}
  }

  type TransactionFeeGetPayload<S extends boolean | null | undefined | TransactionFeeDefaultArgs> = $Result.GetResult<Prisma.$TransactionFeePayload, S>

  type TransactionFeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TransactionFeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TransactionFeeCountAggregateInputType | true
    }

  export interface TransactionFeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TransactionFee'], meta: { name: 'TransactionFee' } }
    /**
     * Find zero or one TransactionFee that matches the filter.
     * @param {TransactionFeeFindUniqueArgs} args - Arguments to find a TransactionFee
     * @example
     * // Get one TransactionFee
     * const transactionFee = await prisma.transactionFee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFeeFindUniqueArgs>(args: SelectSubset<T, TransactionFeeFindUniqueArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TransactionFee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TransactionFeeFindUniqueOrThrowArgs} args - Arguments to find a TransactionFee
     * @example
     * // Get one TransactionFee
     * const transactionFee = await prisma.transactionFee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFeeFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TransactionFee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeFindFirstArgs} args - Arguments to find a TransactionFee
     * @example
     * // Get one TransactionFee
     * const transactionFee = await prisma.transactionFee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFeeFindFirstArgs>(args?: SelectSubset<T, TransactionFeeFindFirstArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TransactionFee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeFindFirstOrThrowArgs} args - Arguments to find a TransactionFee
     * @example
     * // Get one TransactionFee
     * const transactionFee = await prisma.transactionFee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFeeFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TransactionFees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransactionFees
     * const transactionFees = await prisma.transactionFee.findMany()
     * 
     * // Get first 10 TransactionFees
     * const transactionFees = await prisma.transactionFee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionFeeWithIdOnly = await prisma.transactionFee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFeeFindManyArgs>(args?: SelectSubset<T, TransactionFeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TransactionFee.
     * @param {TransactionFeeCreateArgs} args - Arguments to create a TransactionFee.
     * @example
     * // Create one TransactionFee
     * const TransactionFee = await prisma.transactionFee.create({
     *   data: {
     *     // ... data to create a TransactionFee
     *   }
     * })
     * 
     */
    create<T extends TransactionFeeCreateArgs>(args: SelectSubset<T, TransactionFeeCreateArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TransactionFees.
     * @param {TransactionFeeCreateManyArgs} args - Arguments to create many TransactionFees.
     * @example
     * // Create many TransactionFees
     * const transactionFee = await prisma.transactionFee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionFeeCreateManyArgs>(args?: SelectSubset<T, TransactionFeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TransactionFees and returns the data saved in the database.
     * @param {TransactionFeeCreateManyAndReturnArgs} args - Arguments to create many TransactionFees.
     * @example
     * // Create many TransactionFees
     * const transactionFee = await prisma.transactionFee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TransactionFees and only return the `id`
     * const transactionFeeWithIdOnly = await prisma.transactionFee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionFeeCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionFeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TransactionFee.
     * @param {TransactionFeeDeleteArgs} args - Arguments to delete one TransactionFee.
     * @example
     * // Delete one TransactionFee
     * const TransactionFee = await prisma.transactionFee.delete({
     *   where: {
     *     // ... filter to delete one TransactionFee
     *   }
     * })
     * 
     */
    delete<T extends TransactionFeeDeleteArgs>(args: SelectSubset<T, TransactionFeeDeleteArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TransactionFee.
     * @param {TransactionFeeUpdateArgs} args - Arguments to update one TransactionFee.
     * @example
     * // Update one TransactionFee
     * const transactionFee = await prisma.transactionFee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionFeeUpdateArgs>(args: SelectSubset<T, TransactionFeeUpdateArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TransactionFees.
     * @param {TransactionFeeDeleteManyArgs} args - Arguments to filter TransactionFees to delete.
     * @example
     * // Delete a few TransactionFees
     * const { count } = await prisma.transactionFee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionFeeDeleteManyArgs>(args?: SelectSubset<T, TransactionFeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransactionFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransactionFees
     * const transactionFee = await prisma.transactionFee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionFeeUpdateManyArgs>(args: SelectSubset<T, TransactionFeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TransactionFee.
     * @param {TransactionFeeUpsertArgs} args - Arguments to update or create a TransactionFee.
     * @example
     * // Update or create a TransactionFee
     * const transactionFee = await prisma.transactionFee.upsert({
     *   create: {
     *     // ... data to create a TransactionFee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransactionFee we want to update
     *   }
     * })
     */
    upsert<T extends TransactionFeeUpsertArgs>(args: SelectSubset<T, TransactionFeeUpsertArgs<ExtArgs>>): Prisma__TransactionFeeClient<$Result.GetResult<Prisma.$TransactionFeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TransactionFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeCountArgs} args - Arguments to filter TransactionFees to count.
     * @example
     * // Count the number of TransactionFees
     * const count = await prisma.transactionFee.count({
     *   where: {
     *     // ... the filter for the TransactionFees we want to count
     *   }
     * })
    **/
    count<T extends TransactionFeeCountArgs>(
      args?: Subset<T, TransactionFeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionFeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransactionFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionFeeAggregateArgs>(args: Subset<T, TransactionFeeAggregateArgs>): Prisma.PrismaPromise<GetTransactionFeeAggregateType<T>>

    /**
     * Group by TransactionFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionFeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionFeeGroupByArgs['orderBy'] }
        : { orderBy?: TransactionFeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionFeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TransactionFee model
   */
  readonly fields: TransactionFeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransactionFee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionFeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transaction<T extends PaymentTransactionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PaymentTransactionDefaultArgs<ExtArgs>>): Prisma__PaymentTransactionClient<$Result.GetResult<Prisma.$PaymentTransactionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TransactionFee model
   */ 
  interface TransactionFeeFieldRefs {
    readonly id: FieldRef<"TransactionFee", 'String'>
    readonly transactionId: FieldRef<"TransactionFee", 'String'>
    readonly type: FieldRef<"TransactionFee", 'FeeType'>
    readonly amount: FieldRef<"TransactionFee", 'Float'>
    readonly currency: FieldRef<"TransactionFee", 'String'>
    readonly description: FieldRef<"TransactionFee", 'String'>
    readonly createdAt: FieldRef<"TransactionFee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TransactionFee findUnique
   */
  export type TransactionFeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFee to fetch.
     */
    where: TransactionFeeWhereUniqueInput
  }

  /**
   * TransactionFee findUniqueOrThrow
   */
  export type TransactionFeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFee to fetch.
     */
    where: TransactionFeeWhereUniqueInput
  }

  /**
   * TransactionFee findFirst
   */
  export type TransactionFeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFee to fetch.
     */
    where?: TransactionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFees to fetch.
     */
    orderBy?: TransactionFeeOrderByWithRelationInput | TransactionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionFees.
     */
    cursor?: TransactionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionFees.
     */
    distinct?: TransactionFeeScalarFieldEnum | TransactionFeeScalarFieldEnum[]
  }

  /**
   * TransactionFee findFirstOrThrow
   */
  export type TransactionFeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFee to fetch.
     */
    where?: TransactionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFees to fetch.
     */
    orderBy?: TransactionFeeOrderByWithRelationInput | TransactionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransactionFees.
     */
    cursor?: TransactionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransactionFees.
     */
    distinct?: TransactionFeeScalarFieldEnum | TransactionFeeScalarFieldEnum[]
  }

  /**
   * TransactionFee findMany
   */
  export type TransactionFeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter, which TransactionFees to fetch.
     */
    where?: TransactionFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransactionFees to fetch.
     */
    orderBy?: TransactionFeeOrderByWithRelationInput | TransactionFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransactionFees.
     */
    cursor?: TransactionFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransactionFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransactionFees.
     */
    skip?: number
    distinct?: TransactionFeeScalarFieldEnum | TransactionFeeScalarFieldEnum[]
  }

  /**
   * TransactionFee create
   */
  export type TransactionFeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * The data needed to create a TransactionFee.
     */
    data: XOR<TransactionFeeCreateInput, TransactionFeeUncheckedCreateInput>
  }

  /**
   * TransactionFee createMany
   */
  export type TransactionFeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TransactionFees.
     */
    data: TransactionFeeCreateManyInput | TransactionFeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TransactionFee createManyAndReturn
   */
  export type TransactionFeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TransactionFees.
     */
    data: TransactionFeeCreateManyInput | TransactionFeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TransactionFee update
   */
  export type TransactionFeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * The data needed to update a TransactionFee.
     */
    data: XOR<TransactionFeeUpdateInput, TransactionFeeUncheckedUpdateInput>
    /**
     * Choose, which TransactionFee to update.
     */
    where: TransactionFeeWhereUniqueInput
  }

  /**
   * TransactionFee updateMany
   */
  export type TransactionFeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TransactionFees.
     */
    data: XOR<TransactionFeeUpdateManyMutationInput, TransactionFeeUncheckedUpdateManyInput>
    /**
     * Filter which TransactionFees to update
     */
    where?: TransactionFeeWhereInput
  }

  /**
   * TransactionFee upsert
   */
  export type TransactionFeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * The filter to search for the TransactionFee to update in case it exists.
     */
    where: TransactionFeeWhereUniqueInput
    /**
     * In case the TransactionFee found by the `where` argument doesn't exist, create a new TransactionFee with this data.
     */
    create: XOR<TransactionFeeCreateInput, TransactionFeeUncheckedCreateInput>
    /**
     * In case the TransactionFee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionFeeUpdateInput, TransactionFeeUncheckedUpdateInput>
  }

  /**
   * TransactionFee delete
   */
  export type TransactionFeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
    /**
     * Filter which TransactionFee to delete.
     */
    where: TransactionFeeWhereUniqueInput
  }

  /**
   * TransactionFee deleteMany
   */
  export type TransactionFeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TransactionFees to delete
     */
    where?: TransactionFeeWhereInput
  }

  /**
   * TransactionFee without action
   */
  export type TransactionFeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TransactionFee
     */
    select?: TransactionFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionFeeInclude<ExtArgs> | null
  }


  /**
   * Model RoutingStepFee
   */

  export type AggregateRoutingStepFee = {
    _count: RoutingStepFeeCountAggregateOutputType | null
    _avg: RoutingStepFeeAvgAggregateOutputType | null
    _sum: RoutingStepFeeSumAggregateOutputType | null
    _min: RoutingStepFeeMinAggregateOutputType | null
    _max: RoutingStepFeeMaxAggregateOutputType | null
  }

  export type RoutingStepFeeAvgAggregateOutputType = {
    amount: number | null
  }

  export type RoutingStepFeeSumAggregateOutputType = {
    amount: number | null
  }

  export type RoutingStepFeeMinAggregateOutputType = {
    id: string | null
    routingStepId: string | null
    type: $Enums.FeeType | null
    amount: number | null
    currency: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RoutingStepFeeMaxAggregateOutputType = {
    id: string | null
    routingStepId: string | null
    type: $Enums.FeeType | null
    amount: number | null
    currency: string | null
    description: string | null
    createdAt: Date | null
  }

  export type RoutingStepFeeCountAggregateOutputType = {
    id: number
    routingStepId: number
    type: number
    amount: number
    currency: number
    description: number
    createdAt: number
    _all: number
  }


  export type RoutingStepFeeAvgAggregateInputType = {
    amount?: true
  }

  export type RoutingStepFeeSumAggregateInputType = {
    amount?: true
  }

  export type RoutingStepFeeMinAggregateInputType = {
    id?: true
    routingStepId?: true
    type?: true
    amount?: true
    currency?: true
    description?: true
    createdAt?: true
  }

  export type RoutingStepFeeMaxAggregateInputType = {
    id?: true
    routingStepId?: true
    type?: true
    amount?: true
    currency?: true
    description?: true
    createdAt?: true
  }

  export type RoutingStepFeeCountAggregateInputType = {
    id?: true
    routingStepId?: true
    type?: true
    amount?: true
    currency?: true
    description?: true
    createdAt?: true
    _all?: true
  }

  export type RoutingStepFeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutingStepFee to aggregate.
     */
    where?: RoutingStepFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingStepFees to fetch.
     */
    orderBy?: RoutingStepFeeOrderByWithRelationInput | RoutingStepFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoutingStepFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingStepFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingStepFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoutingStepFees
    **/
    _count?: true | RoutingStepFeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoutingStepFeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoutingStepFeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoutingStepFeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoutingStepFeeMaxAggregateInputType
  }

  export type GetRoutingStepFeeAggregateType<T extends RoutingStepFeeAggregateArgs> = {
        [P in keyof T & keyof AggregateRoutingStepFee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoutingStepFee[P]>
      : GetScalarType<T[P], AggregateRoutingStepFee[P]>
  }




  export type RoutingStepFeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutingStepFeeWhereInput
    orderBy?: RoutingStepFeeOrderByWithAggregationInput | RoutingStepFeeOrderByWithAggregationInput[]
    by: RoutingStepFeeScalarFieldEnum[] | RoutingStepFeeScalarFieldEnum
    having?: RoutingStepFeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoutingStepFeeCountAggregateInputType | true
    _avg?: RoutingStepFeeAvgAggregateInputType
    _sum?: RoutingStepFeeSumAggregateInputType
    _min?: RoutingStepFeeMinAggregateInputType
    _max?: RoutingStepFeeMaxAggregateInputType
  }

  export type RoutingStepFeeGroupByOutputType = {
    id: string
    routingStepId: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt: Date
    _count: RoutingStepFeeCountAggregateOutputType | null
    _avg: RoutingStepFeeAvgAggregateOutputType | null
    _sum: RoutingStepFeeSumAggregateOutputType | null
    _min: RoutingStepFeeMinAggregateOutputType | null
    _max: RoutingStepFeeMaxAggregateOutputType | null
  }

  type GetRoutingStepFeeGroupByPayload<T extends RoutingStepFeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoutingStepFeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoutingStepFeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoutingStepFeeGroupByOutputType[P]>
            : GetScalarType<T[P], RoutingStepFeeGroupByOutputType[P]>
        }
      >
    >


  export type RoutingStepFeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routingStepId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    createdAt?: boolean
    routingStep?: boolean | RoutingStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routingStepFee"]>

  export type RoutingStepFeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    routingStepId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    createdAt?: boolean
    routingStep?: boolean | RoutingStepDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routingStepFee"]>

  export type RoutingStepFeeSelectScalar = {
    id?: boolean
    routingStepId?: boolean
    type?: boolean
    amount?: boolean
    currency?: boolean
    description?: boolean
    createdAt?: boolean
  }

  export type RoutingStepFeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routingStep?: boolean | RoutingStepDefaultArgs<ExtArgs>
  }
  export type RoutingStepFeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routingStep?: boolean | RoutingStepDefaultArgs<ExtArgs>
  }

  export type $RoutingStepFeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoutingStepFee"
    objects: {
      routingStep: Prisma.$RoutingStepPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      routingStepId: string
      type: $Enums.FeeType
      amount: number
      currency: string
      description: string
      createdAt: Date
    }, ExtArgs["result"]["routingStepFee"]>
    composites: {}
  }

  type RoutingStepFeeGetPayload<S extends boolean | null | undefined | RoutingStepFeeDefaultArgs> = $Result.GetResult<Prisma.$RoutingStepFeePayload, S>

  type RoutingStepFeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoutingStepFeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoutingStepFeeCountAggregateInputType | true
    }

  export interface RoutingStepFeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoutingStepFee'], meta: { name: 'RoutingStepFee' } }
    /**
     * Find zero or one RoutingStepFee that matches the filter.
     * @param {RoutingStepFeeFindUniqueArgs} args - Arguments to find a RoutingStepFee
     * @example
     * // Get one RoutingStepFee
     * const routingStepFee = await prisma.routingStepFee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoutingStepFeeFindUniqueArgs>(args: SelectSubset<T, RoutingStepFeeFindUniqueArgs<ExtArgs>>): Prisma__RoutingStepFeeClient<$Result.GetResult<Prisma.$RoutingStepFeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoutingStepFee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoutingStepFeeFindUniqueOrThrowArgs} args - Arguments to find a RoutingStepFee
     * @example
     * // Get one RoutingStepFee
     * const routingStepFee = await prisma.routingStepFee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoutingStepFeeFindUniqueOrThrowArgs>(args: SelectSubset<T, RoutingStepFeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoutingStepFeeClient<$Result.GetResult<Prisma.$RoutingStepFeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoutingStepFee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepFeeFindFirstArgs} args - Arguments to find a RoutingStepFee
     * @example
     * // Get one RoutingStepFee
     * const routingStepFee = await prisma.routingStepFee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoutingStepFeeFindFirstArgs>(args?: SelectSubset<T, RoutingStepFeeFindFirstArgs<ExtArgs>>): Prisma__RoutingStepFeeClient<$Result.GetResult<Prisma.$RoutingStepFeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoutingStepFee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepFeeFindFirstOrThrowArgs} args - Arguments to find a RoutingStepFee
     * @example
     * // Get one RoutingStepFee
     * const routingStepFee = await prisma.routingStepFee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoutingStepFeeFindFirstOrThrowArgs>(args?: SelectSubset<T, RoutingStepFeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoutingStepFeeClient<$Result.GetResult<Prisma.$RoutingStepFeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoutingStepFees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepFeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoutingStepFees
     * const routingStepFees = await prisma.routingStepFee.findMany()
     * 
     * // Get first 10 RoutingStepFees
     * const routingStepFees = await prisma.routingStepFee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routingStepFeeWithIdOnly = await prisma.routingStepFee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoutingStepFeeFindManyArgs>(args?: SelectSubset<T, RoutingStepFeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutingStepFeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoutingStepFee.
     * @param {RoutingStepFeeCreateArgs} args - Arguments to create a RoutingStepFee.
     * @example
     * // Create one RoutingStepFee
     * const RoutingStepFee = await prisma.routingStepFee.create({
     *   data: {
     *     // ... data to create a RoutingStepFee
     *   }
     * })
     * 
     */
    create<T extends RoutingStepFeeCreateArgs>(args: SelectSubset<T, RoutingStepFeeCreateArgs<ExtArgs>>): Prisma__RoutingStepFeeClient<$Result.GetResult<Prisma.$RoutingStepFeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoutingStepFees.
     * @param {RoutingStepFeeCreateManyArgs} args - Arguments to create many RoutingStepFees.
     * @example
     * // Create many RoutingStepFees
     * const routingStepFee = await prisma.routingStepFee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoutingStepFeeCreateManyArgs>(args?: SelectSubset<T, RoutingStepFeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoutingStepFees and returns the data saved in the database.
     * @param {RoutingStepFeeCreateManyAndReturnArgs} args - Arguments to create many RoutingStepFees.
     * @example
     * // Create many RoutingStepFees
     * const routingStepFee = await prisma.routingStepFee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoutingStepFees and only return the `id`
     * const routingStepFeeWithIdOnly = await prisma.routingStepFee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoutingStepFeeCreateManyAndReturnArgs>(args?: SelectSubset<T, RoutingStepFeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutingStepFeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoutingStepFee.
     * @param {RoutingStepFeeDeleteArgs} args - Arguments to delete one RoutingStepFee.
     * @example
     * // Delete one RoutingStepFee
     * const RoutingStepFee = await prisma.routingStepFee.delete({
     *   where: {
     *     // ... filter to delete one RoutingStepFee
     *   }
     * })
     * 
     */
    delete<T extends RoutingStepFeeDeleteArgs>(args: SelectSubset<T, RoutingStepFeeDeleteArgs<ExtArgs>>): Prisma__RoutingStepFeeClient<$Result.GetResult<Prisma.$RoutingStepFeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoutingStepFee.
     * @param {RoutingStepFeeUpdateArgs} args - Arguments to update one RoutingStepFee.
     * @example
     * // Update one RoutingStepFee
     * const routingStepFee = await prisma.routingStepFee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoutingStepFeeUpdateArgs>(args: SelectSubset<T, RoutingStepFeeUpdateArgs<ExtArgs>>): Prisma__RoutingStepFeeClient<$Result.GetResult<Prisma.$RoutingStepFeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoutingStepFees.
     * @param {RoutingStepFeeDeleteManyArgs} args - Arguments to filter RoutingStepFees to delete.
     * @example
     * // Delete a few RoutingStepFees
     * const { count } = await prisma.routingStepFee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoutingStepFeeDeleteManyArgs>(args?: SelectSubset<T, RoutingStepFeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoutingStepFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepFeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoutingStepFees
     * const routingStepFee = await prisma.routingStepFee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoutingStepFeeUpdateManyArgs>(args: SelectSubset<T, RoutingStepFeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoutingStepFee.
     * @param {RoutingStepFeeUpsertArgs} args - Arguments to update or create a RoutingStepFee.
     * @example
     * // Update or create a RoutingStepFee
     * const routingStepFee = await prisma.routingStepFee.upsert({
     *   create: {
     *     // ... data to create a RoutingStepFee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoutingStepFee we want to update
     *   }
     * })
     */
    upsert<T extends RoutingStepFeeUpsertArgs>(args: SelectSubset<T, RoutingStepFeeUpsertArgs<ExtArgs>>): Prisma__RoutingStepFeeClient<$Result.GetResult<Prisma.$RoutingStepFeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoutingStepFees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepFeeCountArgs} args - Arguments to filter RoutingStepFees to count.
     * @example
     * // Count the number of RoutingStepFees
     * const count = await prisma.routingStepFee.count({
     *   where: {
     *     // ... the filter for the RoutingStepFees we want to count
     *   }
     * })
    **/
    count<T extends RoutingStepFeeCountArgs>(
      args?: Subset<T, RoutingStepFeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoutingStepFeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoutingStepFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepFeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoutingStepFeeAggregateArgs>(args: Subset<T, RoutingStepFeeAggregateArgs>): Prisma.PrismaPromise<GetRoutingStepFeeAggregateType<T>>

    /**
     * Group by RoutingStepFee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingStepFeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoutingStepFeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoutingStepFeeGroupByArgs['orderBy'] }
        : { orderBy?: RoutingStepFeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoutingStepFeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoutingStepFeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoutingStepFee model
   */
  readonly fields: RoutingStepFeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoutingStepFee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoutingStepFeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    routingStep<T extends RoutingStepDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoutingStepDefaultArgs<ExtArgs>>): Prisma__RoutingStepClient<$Result.GetResult<Prisma.$RoutingStepPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoutingStepFee model
   */ 
  interface RoutingStepFeeFieldRefs {
    readonly id: FieldRef<"RoutingStepFee", 'String'>
    readonly routingStepId: FieldRef<"RoutingStepFee", 'String'>
    readonly type: FieldRef<"RoutingStepFee", 'FeeType'>
    readonly amount: FieldRef<"RoutingStepFee", 'Float'>
    readonly currency: FieldRef<"RoutingStepFee", 'String'>
    readonly description: FieldRef<"RoutingStepFee", 'String'>
    readonly createdAt: FieldRef<"RoutingStepFee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoutingStepFee findUnique
   */
  export type RoutingStepFeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeInclude<ExtArgs> | null
    /**
     * Filter, which RoutingStepFee to fetch.
     */
    where: RoutingStepFeeWhereUniqueInput
  }

  /**
   * RoutingStepFee findUniqueOrThrow
   */
  export type RoutingStepFeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeInclude<ExtArgs> | null
    /**
     * Filter, which RoutingStepFee to fetch.
     */
    where: RoutingStepFeeWhereUniqueInput
  }

  /**
   * RoutingStepFee findFirst
   */
  export type RoutingStepFeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeInclude<ExtArgs> | null
    /**
     * Filter, which RoutingStepFee to fetch.
     */
    where?: RoutingStepFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingStepFees to fetch.
     */
    orderBy?: RoutingStepFeeOrderByWithRelationInput | RoutingStepFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutingStepFees.
     */
    cursor?: RoutingStepFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingStepFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingStepFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutingStepFees.
     */
    distinct?: RoutingStepFeeScalarFieldEnum | RoutingStepFeeScalarFieldEnum[]
  }

  /**
   * RoutingStepFee findFirstOrThrow
   */
  export type RoutingStepFeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeInclude<ExtArgs> | null
    /**
     * Filter, which RoutingStepFee to fetch.
     */
    where?: RoutingStepFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingStepFees to fetch.
     */
    orderBy?: RoutingStepFeeOrderByWithRelationInput | RoutingStepFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutingStepFees.
     */
    cursor?: RoutingStepFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingStepFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingStepFees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutingStepFees.
     */
    distinct?: RoutingStepFeeScalarFieldEnum | RoutingStepFeeScalarFieldEnum[]
  }

  /**
   * RoutingStepFee findMany
   */
  export type RoutingStepFeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeInclude<ExtArgs> | null
    /**
     * Filter, which RoutingStepFees to fetch.
     */
    where?: RoutingStepFeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingStepFees to fetch.
     */
    orderBy?: RoutingStepFeeOrderByWithRelationInput | RoutingStepFeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoutingStepFees.
     */
    cursor?: RoutingStepFeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingStepFees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingStepFees.
     */
    skip?: number
    distinct?: RoutingStepFeeScalarFieldEnum | RoutingStepFeeScalarFieldEnum[]
  }

  /**
   * RoutingStepFee create
   */
  export type RoutingStepFeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeInclude<ExtArgs> | null
    /**
     * The data needed to create a RoutingStepFee.
     */
    data: XOR<RoutingStepFeeCreateInput, RoutingStepFeeUncheckedCreateInput>
  }

  /**
   * RoutingStepFee createMany
   */
  export type RoutingStepFeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoutingStepFees.
     */
    data: RoutingStepFeeCreateManyInput | RoutingStepFeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoutingStepFee createManyAndReturn
   */
  export type RoutingStepFeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoutingStepFees.
     */
    data: RoutingStepFeeCreateManyInput | RoutingStepFeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoutingStepFee update
   */
  export type RoutingStepFeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeInclude<ExtArgs> | null
    /**
     * The data needed to update a RoutingStepFee.
     */
    data: XOR<RoutingStepFeeUpdateInput, RoutingStepFeeUncheckedUpdateInput>
    /**
     * Choose, which RoutingStepFee to update.
     */
    where: RoutingStepFeeWhereUniqueInput
  }

  /**
   * RoutingStepFee updateMany
   */
  export type RoutingStepFeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoutingStepFees.
     */
    data: XOR<RoutingStepFeeUpdateManyMutationInput, RoutingStepFeeUncheckedUpdateManyInput>
    /**
     * Filter which RoutingStepFees to update
     */
    where?: RoutingStepFeeWhereInput
  }

  /**
   * RoutingStepFee upsert
   */
  export type RoutingStepFeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeInclude<ExtArgs> | null
    /**
     * The filter to search for the RoutingStepFee to update in case it exists.
     */
    where: RoutingStepFeeWhereUniqueInput
    /**
     * In case the RoutingStepFee found by the `where` argument doesn't exist, create a new RoutingStepFee with this data.
     */
    create: XOR<RoutingStepFeeCreateInput, RoutingStepFeeUncheckedCreateInput>
    /**
     * In case the RoutingStepFee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoutingStepFeeUpdateInput, RoutingStepFeeUncheckedUpdateInput>
  }

  /**
   * RoutingStepFee delete
   */
  export type RoutingStepFeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeInclude<ExtArgs> | null
    /**
     * Filter which RoutingStepFee to delete.
     */
    where: RoutingStepFeeWhereUniqueInput
  }

  /**
   * RoutingStepFee deleteMany
   */
  export type RoutingStepFeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutingStepFees to delete
     */
    where?: RoutingStepFeeWhereInput
  }

  /**
   * RoutingStepFee without action
   */
  export type RoutingStepFeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingStepFee
     */
    select?: RoutingStepFeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingStepFeeInclude<ExtArgs> | null
  }


  /**
   * Model RoutingRule
   */

  export type AggregateRoutingRule = {
    _count: RoutingRuleCountAggregateOutputType | null
    _avg: RoutingRuleAvgAggregateOutputType | null
    _sum: RoutingRuleSumAggregateOutputType | null
    _min: RoutingRuleMinAggregateOutputType | null
    _max: RoutingRuleMaxAggregateOutputType | null
  }

  export type RoutingRuleAvgAggregateOutputType = {
    priority: number | null
  }

  export type RoutingRuleSumAggregateOutputType = {
    priority: number | null
  }

  export type RoutingRuleMinAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    priority: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoutingRuleMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    name: string | null
    priority: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type RoutingRuleCountAggregateOutputType = {
    id: number
    userId: number
    name: number
    conditions: number
    actions: number
    priority: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type RoutingRuleAvgAggregateInputType = {
    priority?: true
  }

  export type RoutingRuleSumAggregateInputType = {
    priority?: true
  }

  export type RoutingRuleMinAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    priority?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoutingRuleMaxAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    priority?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type RoutingRuleCountAggregateInputType = {
    id?: true
    userId?: true
    name?: true
    conditions?: true
    actions?: true
    priority?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type RoutingRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutingRule to aggregate.
     */
    where?: RoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingRules to fetch.
     */
    orderBy?: RoutingRuleOrderByWithRelationInput | RoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoutingRules
    **/
    _count?: true | RoutingRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoutingRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoutingRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoutingRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoutingRuleMaxAggregateInputType
  }

  export type GetRoutingRuleAggregateType<T extends RoutingRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateRoutingRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoutingRule[P]>
      : GetScalarType<T[P], AggregateRoutingRule[P]>
  }




  export type RoutingRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoutingRuleWhereInput
    orderBy?: RoutingRuleOrderByWithAggregationInput | RoutingRuleOrderByWithAggregationInput[]
    by: RoutingRuleScalarFieldEnum[] | RoutingRuleScalarFieldEnum
    having?: RoutingRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoutingRuleCountAggregateInputType | true
    _avg?: RoutingRuleAvgAggregateInputType
    _sum?: RoutingRuleSumAggregateInputType
    _min?: RoutingRuleMinAggregateInputType
    _max?: RoutingRuleMaxAggregateInputType
  }

  export type RoutingRuleGroupByOutputType = {
    id: string
    userId: string
    name: string
    conditions: JsonValue
    actions: JsonValue
    priority: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: RoutingRuleCountAggregateOutputType | null
    _avg: RoutingRuleAvgAggregateOutputType | null
    _sum: RoutingRuleSumAggregateOutputType | null
    _min: RoutingRuleMinAggregateOutputType | null
    _max: RoutingRuleMaxAggregateOutputType | null
  }

  type GetRoutingRuleGroupByPayload<T extends RoutingRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoutingRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoutingRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoutingRuleGroupByOutputType[P]>
            : GetScalarType<T[P], RoutingRuleGroupByOutputType[P]>
        }
      >
    >


  export type RoutingRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    conditions?: boolean
    actions?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routingRule"]>

  export type RoutingRuleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    name?: boolean
    conditions?: boolean
    actions?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routingRule"]>

  export type RoutingRuleSelectScalar = {
    id?: boolean
    userId?: boolean
    name?: boolean
    conditions?: boolean
    actions?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type RoutingRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type RoutingRuleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $RoutingRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoutingRule"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      name: string
      conditions: Prisma.JsonValue
      actions: Prisma.JsonValue
      priority: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["routingRule"]>
    composites: {}
  }

  type RoutingRuleGetPayload<S extends boolean | null | undefined | RoutingRuleDefaultArgs> = $Result.GetResult<Prisma.$RoutingRulePayload, S>

  type RoutingRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoutingRuleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoutingRuleCountAggregateInputType | true
    }

  export interface RoutingRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoutingRule'], meta: { name: 'RoutingRule' } }
    /**
     * Find zero or one RoutingRule that matches the filter.
     * @param {RoutingRuleFindUniqueArgs} args - Arguments to find a RoutingRule
     * @example
     * // Get one RoutingRule
     * const routingRule = await prisma.routingRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoutingRuleFindUniqueArgs>(args: SelectSubset<T, RoutingRuleFindUniqueArgs<ExtArgs>>): Prisma__RoutingRuleClient<$Result.GetResult<Prisma.$RoutingRulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoutingRule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoutingRuleFindUniqueOrThrowArgs} args - Arguments to find a RoutingRule
     * @example
     * // Get one RoutingRule
     * const routingRule = await prisma.routingRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoutingRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, RoutingRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoutingRuleClient<$Result.GetResult<Prisma.$RoutingRulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoutingRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingRuleFindFirstArgs} args - Arguments to find a RoutingRule
     * @example
     * // Get one RoutingRule
     * const routingRule = await prisma.routingRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoutingRuleFindFirstArgs>(args?: SelectSubset<T, RoutingRuleFindFirstArgs<ExtArgs>>): Prisma__RoutingRuleClient<$Result.GetResult<Prisma.$RoutingRulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoutingRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingRuleFindFirstOrThrowArgs} args - Arguments to find a RoutingRule
     * @example
     * // Get one RoutingRule
     * const routingRule = await prisma.routingRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoutingRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, RoutingRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoutingRuleClient<$Result.GetResult<Prisma.$RoutingRulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoutingRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoutingRules
     * const routingRules = await prisma.routingRule.findMany()
     * 
     * // Get first 10 RoutingRules
     * const routingRules = await prisma.routingRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routingRuleWithIdOnly = await prisma.routingRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoutingRuleFindManyArgs>(args?: SelectSubset<T, RoutingRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutingRulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoutingRule.
     * @param {RoutingRuleCreateArgs} args - Arguments to create a RoutingRule.
     * @example
     * // Create one RoutingRule
     * const RoutingRule = await prisma.routingRule.create({
     *   data: {
     *     // ... data to create a RoutingRule
     *   }
     * })
     * 
     */
    create<T extends RoutingRuleCreateArgs>(args: SelectSubset<T, RoutingRuleCreateArgs<ExtArgs>>): Prisma__RoutingRuleClient<$Result.GetResult<Prisma.$RoutingRulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoutingRules.
     * @param {RoutingRuleCreateManyArgs} args - Arguments to create many RoutingRules.
     * @example
     * // Create many RoutingRules
     * const routingRule = await prisma.routingRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoutingRuleCreateManyArgs>(args?: SelectSubset<T, RoutingRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RoutingRules and returns the data saved in the database.
     * @param {RoutingRuleCreateManyAndReturnArgs} args - Arguments to create many RoutingRules.
     * @example
     * // Create many RoutingRules
     * const routingRule = await prisma.routingRule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RoutingRules and only return the `id`
     * const routingRuleWithIdOnly = await prisma.routingRule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoutingRuleCreateManyAndReturnArgs>(args?: SelectSubset<T, RoutingRuleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoutingRulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RoutingRule.
     * @param {RoutingRuleDeleteArgs} args - Arguments to delete one RoutingRule.
     * @example
     * // Delete one RoutingRule
     * const RoutingRule = await prisma.routingRule.delete({
     *   where: {
     *     // ... filter to delete one RoutingRule
     *   }
     * })
     * 
     */
    delete<T extends RoutingRuleDeleteArgs>(args: SelectSubset<T, RoutingRuleDeleteArgs<ExtArgs>>): Prisma__RoutingRuleClient<$Result.GetResult<Prisma.$RoutingRulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoutingRule.
     * @param {RoutingRuleUpdateArgs} args - Arguments to update one RoutingRule.
     * @example
     * // Update one RoutingRule
     * const routingRule = await prisma.routingRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoutingRuleUpdateArgs>(args: SelectSubset<T, RoutingRuleUpdateArgs<ExtArgs>>): Prisma__RoutingRuleClient<$Result.GetResult<Prisma.$RoutingRulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoutingRules.
     * @param {RoutingRuleDeleteManyArgs} args - Arguments to filter RoutingRules to delete.
     * @example
     * // Delete a few RoutingRules
     * const { count } = await prisma.routingRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoutingRuleDeleteManyArgs>(args?: SelectSubset<T, RoutingRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoutingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoutingRules
     * const routingRule = await prisma.routingRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoutingRuleUpdateManyArgs>(args: SelectSubset<T, RoutingRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoutingRule.
     * @param {RoutingRuleUpsertArgs} args - Arguments to update or create a RoutingRule.
     * @example
     * // Update or create a RoutingRule
     * const routingRule = await prisma.routingRule.upsert({
     *   create: {
     *     // ... data to create a RoutingRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoutingRule we want to update
     *   }
     * })
     */
    upsert<T extends RoutingRuleUpsertArgs>(args: SelectSubset<T, RoutingRuleUpsertArgs<ExtArgs>>): Prisma__RoutingRuleClient<$Result.GetResult<Prisma.$RoutingRulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoutingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingRuleCountArgs} args - Arguments to filter RoutingRules to count.
     * @example
     * // Count the number of RoutingRules
     * const count = await prisma.routingRule.count({
     *   where: {
     *     // ... the filter for the RoutingRules we want to count
     *   }
     * })
    **/
    count<T extends RoutingRuleCountArgs>(
      args?: Subset<T, RoutingRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoutingRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoutingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoutingRuleAggregateArgs>(args: Subset<T, RoutingRuleAggregateArgs>): Prisma.PrismaPromise<GetRoutingRuleAggregateType<T>>

    /**
     * Group by RoutingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoutingRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoutingRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoutingRuleGroupByArgs['orderBy'] }
        : { orderBy?: RoutingRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoutingRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoutingRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoutingRule model
   */
  readonly fields: RoutingRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoutingRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoutingRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoutingRule model
   */ 
  interface RoutingRuleFieldRefs {
    readonly id: FieldRef<"RoutingRule", 'String'>
    readonly userId: FieldRef<"RoutingRule", 'String'>
    readonly name: FieldRef<"RoutingRule", 'String'>
    readonly conditions: FieldRef<"RoutingRule", 'Json'>
    readonly actions: FieldRef<"RoutingRule", 'Json'>
    readonly priority: FieldRef<"RoutingRule", 'Int'>
    readonly isActive: FieldRef<"RoutingRule", 'Boolean'>
    readonly createdAt: FieldRef<"RoutingRule", 'DateTime'>
    readonly updatedAt: FieldRef<"RoutingRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RoutingRule findUnique
   */
  export type RoutingRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleInclude<ExtArgs> | null
    /**
     * Filter, which RoutingRule to fetch.
     */
    where: RoutingRuleWhereUniqueInput
  }

  /**
   * RoutingRule findUniqueOrThrow
   */
  export type RoutingRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleInclude<ExtArgs> | null
    /**
     * Filter, which RoutingRule to fetch.
     */
    where: RoutingRuleWhereUniqueInput
  }

  /**
   * RoutingRule findFirst
   */
  export type RoutingRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleInclude<ExtArgs> | null
    /**
     * Filter, which RoutingRule to fetch.
     */
    where?: RoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingRules to fetch.
     */
    orderBy?: RoutingRuleOrderByWithRelationInput | RoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutingRules.
     */
    cursor?: RoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutingRules.
     */
    distinct?: RoutingRuleScalarFieldEnum | RoutingRuleScalarFieldEnum[]
  }

  /**
   * RoutingRule findFirstOrThrow
   */
  export type RoutingRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleInclude<ExtArgs> | null
    /**
     * Filter, which RoutingRule to fetch.
     */
    where?: RoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingRules to fetch.
     */
    orderBy?: RoutingRuleOrderByWithRelationInput | RoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoutingRules.
     */
    cursor?: RoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoutingRules.
     */
    distinct?: RoutingRuleScalarFieldEnum | RoutingRuleScalarFieldEnum[]
  }

  /**
   * RoutingRule findMany
   */
  export type RoutingRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleInclude<ExtArgs> | null
    /**
     * Filter, which RoutingRules to fetch.
     */
    where?: RoutingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoutingRules to fetch.
     */
    orderBy?: RoutingRuleOrderByWithRelationInput | RoutingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoutingRules.
     */
    cursor?: RoutingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoutingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoutingRules.
     */
    skip?: number
    distinct?: RoutingRuleScalarFieldEnum | RoutingRuleScalarFieldEnum[]
  }

  /**
   * RoutingRule create
   */
  export type RoutingRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a RoutingRule.
     */
    data: XOR<RoutingRuleCreateInput, RoutingRuleUncheckedCreateInput>
  }

  /**
   * RoutingRule createMany
   */
  export type RoutingRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoutingRules.
     */
    data: RoutingRuleCreateManyInput | RoutingRuleCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoutingRule createManyAndReturn
   */
  export type RoutingRuleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RoutingRules.
     */
    data: RoutingRuleCreateManyInput | RoutingRuleCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RoutingRule update
   */
  export type RoutingRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a RoutingRule.
     */
    data: XOR<RoutingRuleUpdateInput, RoutingRuleUncheckedUpdateInput>
    /**
     * Choose, which RoutingRule to update.
     */
    where: RoutingRuleWhereUniqueInput
  }

  /**
   * RoutingRule updateMany
   */
  export type RoutingRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoutingRules.
     */
    data: XOR<RoutingRuleUpdateManyMutationInput, RoutingRuleUncheckedUpdateManyInput>
    /**
     * Filter which RoutingRules to update
     */
    where?: RoutingRuleWhereInput
  }

  /**
   * RoutingRule upsert
   */
  export type RoutingRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the RoutingRule to update in case it exists.
     */
    where: RoutingRuleWhereUniqueInput
    /**
     * In case the RoutingRule found by the `where` argument doesn't exist, create a new RoutingRule with this data.
     */
    create: XOR<RoutingRuleCreateInput, RoutingRuleUncheckedCreateInput>
    /**
     * In case the RoutingRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoutingRuleUpdateInput, RoutingRuleUncheckedUpdateInput>
  }

  /**
   * RoutingRule delete
   */
  export type RoutingRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleInclude<ExtArgs> | null
    /**
     * Filter which RoutingRule to delete.
     */
    where: RoutingRuleWhereUniqueInput
  }

  /**
   * RoutingRule deleteMany
   */
  export type RoutingRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoutingRules to delete
     */
    where?: RoutingRuleWhereInput
  }

  /**
   * RoutingRule without action
   */
  export type RoutingRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoutingRule
     */
    select?: RoutingRuleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoutingRuleInclude<ExtArgs> | null
  }


  /**
   * Model ExchangeRate
   */

  export type AggregateExchangeRate = {
    _count: ExchangeRateCountAggregateOutputType | null
    _avg: ExchangeRateAvgAggregateOutputType | null
    _sum: ExchangeRateSumAggregateOutputType | null
    _min: ExchangeRateMinAggregateOutputType | null
    _max: ExchangeRateMaxAggregateOutputType | null
  }

  export type ExchangeRateAvgAggregateOutputType = {
    rate: number | null
  }

  export type ExchangeRateSumAggregateOutputType = {
    rate: number | null
  }

  export type ExchangeRateMinAggregateOutputType = {
    id: string | null
    fromCurrency: string | null
    toCurrency: string | null
    rate: number | null
    provider: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type ExchangeRateMaxAggregateOutputType = {
    id: string | null
    fromCurrency: string | null
    toCurrency: string | null
    rate: number | null
    provider: string | null
    timestamp: Date | null
    createdAt: Date | null
  }

  export type ExchangeRateCountAggregateOutputType = {
    id: number
    fromCurrency: number
    toCurrency: number
    rate: number
    provider: number
    timestamp: number
    createdAt: number
    _all: number
  }


  export type ExchangeRateAvgAggregateInputType = {
    rate?: true
  }

  export type ExchangeRateSumAggregateInputType = {
    rate?: true
  }

  export type ExchangeRateMinAggregateInputType = {
    id?: true
    fromCurrency?: true
    toCurrency?: true
    rate?: true
    provider?: true
    timestamp?: true
    createdAt?: true
  }

  export type ExchangeRateMaxAggregateInputType = {
    id?: true
    fromCurrency?: true
    toCurrency?: true
    rate?: true
    provider?: true
    timestamp?: true
    createdAt?: true
  }

  export type ExchangeRateCountAggregateInputType = {
    id?: true
    fromCurrency?: true
    toCurrency?: true
    rate?: true
    provider?: true
    timestamp?: true
    createdAt?: true
    _all?: true
  }

  export type ExchangeRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeRate to aggregate.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ExchangeRates
    **/
    _count?: true | ExchangeRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExchangeRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExchangeRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExchangeRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExchangeRateMaxAggregateInputType
  }

  export type GetExchangeRateAggregateType<T extends ExchangeRateAggregateArgs> = {
        [P in keyof T & keyof AggregateExchangeRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExchangeRate[P]>
      : GetScalarType<T[P], AggregateExchangeRate[P]>
  }




  export type ExchangeRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExchangeRateWhereInput
    orderBy?: ExchangeRateOrderByWithAggregationInput | ExchangeRateOrderByWithAggregationInput[]
    by: ExchangeRateScalarFieldEnum[] | ExchangeRateScalarFieldEnum
    having?: ExchangeRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExchangeRateCountAggregateInputType | true
    _avg?: ExchangeRateAvgAggregateInputType
    _sum?: ExchangeRateSumAggregateInputType
    _min?: ExchangeRateMinAggregateInputType
    _max?: ExchangeRateMaxAggregateInputType
  }

  export type ExchangeRateGroupByOutputType = {
    id: string
    fromCurrency: string
    toCurrency: string
    rate: number
    provider: string
    timestamp: Date
    createdAt: Date
    _count: ExchangeRateCountAggregateOutputType | null
    _avg: ExchangeRateAvgAggregateOutputType | null
    _sum: ExchangeRateSumAggregateOutputType | null
    _min: ExchangeRateMinAggregateOutputType | null
    _max: ExchangeRateMaxAggregateOutputType | null
  }

  type GetExchangeRateGroupByPayload<T extends ExchangeRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExchangeRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExchangeRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExchangeRateGroupByOutputType[P]>
            : GetScalarType<T[P], ExchangeRateGroupByOutputType[P]>
        }
      >
    >


  export type ExchangeRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCurrency?: boolean
    toCurrency?: boolean
    rate?: boolean
    provider?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exchangeRate"]>

  export type ExchangeRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fromCurrency?: boolean
    toCurrency?: boolean
    rate?: boolean
    provider?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["exchangeRate"]>

  export type ExchangeRateSelectScalar = {
    id?: boolean
    fromCurrency?: boolean
    toCurrency?: boolean
    rate?: boolean
    provider?: boolean
    timestamp?: boolean
    createdAt?: boolean
  }


  export type $ExchangeRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ExchangeRate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fromCurrency: string
      toCurrency: string
      rate: number
      provider: string
      timestamp: Date
      createdAt: Date
    }, ExtArgs["result"]["exchangeRate"]>
    composites: {}
  }

  type ExchangeRateGetPayload<S extends boolean | null | undefined | ExchangeRateDefaultArgs> = $Result.GetResult<Prisma.$ExchangeRatePayload, S>

  type ExchangeRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExchangeRateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExchangeRateCountAggregateInputType | true
    }

  export interface ExchangeRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ExchangeRate'], meta: { name: 'ExchangeRate' } }
    /**
     * Find zero or one ExchangeRate that matches the filter.
     * @param {ExchangeRateFindUniqueArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExchangeRateFindUniqueArgs>(args: SelectSubset<T, ExchangeRateFindUniqueArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ExchangeRate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExchangeRateFindUniqueOrThrowArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExchangeRateFindUniqueOrThrowArgs>(args: SelectSubset<T, ExchangeRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ExchangeRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateFindFirstArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExchangeRateFindFirstArgs>(args?: SelectSubset<T, ExchangeRateFindFirstArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ExchangeRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateFindFirstOrThrowArgs} args - Arguments to find a ExchangeRate
     * @example
     * // Get one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExchangeRateFindFirstOrThrowArgs>(args?: SelectSubset<T, ExchangeRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ExchangeRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ExchangeRates
     * const exchangeRates = await prisma.exchangeRate.findMany()
     * 
     * // Get first 10 ExchangeRates
     * const exchangeRates = await prisma.exchangeRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const exchangeRateWithIdOnly = await prisma.exchangeRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExchangeRateFindManyArgs>(args?: SelectSubset<T, ExchangeRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ExchangeRate.
     * @param {ExchangeRateCreateArgs} args - Arguments to create a ExchangeRate.
     * @example
     * // Create one ExchangeRate
     * const ExchangeRate = await prisma.exchangeRate.create({
     *   data: {
     *     // ... data to create a ExchangeRate
     *   }
     * })
     * 
     */
    create<T extends ExchangeRateCreateArgs>(args: SelectSubset<T, ExchangeRateCreateArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ExchangeRates.
     * @param {ExchangeRateCreateManyArgs} args - Arguments to create many ExchangeRates.
     * @example
     * // Create many ExchangeRates
     * const exchangeRate = await prisma.exchangeRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExchangeRateCreateManyArgs>(args?: SelectSubset<T, ExchangeRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ExchangeRates and returns the data saved in the database.
     * @param {ExchangeRateCreateManyAndReturnArgs} args - Arguments to create many ExchangeRates.
     * @example
     * // Create many ExchangeRates
     * const exchangeRate = await prisma.exchangeRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ExchangeRates and only return the `id`
     * const exchangeRateWithIdOnly = await prisma.exchangeRate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExchangeRateCreateManyAndReturnArgs>(args?: SelectSubset<T, ExchangeRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ExchangeRate.
     * @param {ExchangeRateDeleteArgs} args - Arguments to delete one ExchangeRate.
     * @example
     * // Delete one ExchangeRate
     * const ExchangeRate = await prisma.exchangeRate.delete({
     *   where: {
     *     // ... filter to delete one ExchangeRate
     *   }
     * })
     * 
     */
    delete<T extends ExchangeRateDeleteArgs>(args: SelectSubset<T, ExchangeRateDeleteArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ExchangeRate.
     * @param {ExchangeRateUpdateArgs} args - Arguments to update one ExchangeRate.
     * @example
     * // Update one ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExchangeRateUpdateArgs>(args: SelectSubset<T, ExchangeRateUpdateArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ExchangeRates.
     * @param {ExchangeRateDeleteManyArgs} args - Arguments to filter ExchangeRates to delete.
     * @example
     * // Delete a few ExchangeRates
     * const { count } = await prisma.exchangeRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExchangeRateDeleteManyArgs>(args?: SelectSubset<T, ExchangeRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ExchangeRates
     * const exchangeRate = await prisma.exchangeRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExchangeRateUpdateManyArgs>(args: SelectSubset<T, ExchangeRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ExchangeRate.
     * @param {ExchangeRateUpsertArgs} args - Arguments to update or create a ExchangeRate.
     * @example
     * // Update or create a ExchangeRate
     * const exchangeRate = await prisma.exchangeRate.upsert({
     *   create: {
     *     // ... data to create a ExchangeRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ExchangeRate we want to update
     *   }
     * })
     */
    upsert<T extends ExchangeRateUpsertArgs>(args: SelectSubset<T, ExchangeRateUpsertArgs<ExtArgs>>): Prisma__ExchangeRateClient<$Result.GetResult<Prisma.$ExchangeRatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ExchangeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateCountArgs} args - Arguments to filter ExchangeRates to count.
     * @example
     * // Count the number of ExchangeRates
     * const count = await prisma.exchangeRate.count({
     *   where: {
     *     // ... the filter for the ExchangeRates we want to count
     *   }
     * })
    **/
    count<T extends ExchangeRateCountArgs>(
      args?: Subset<T, ExchangeRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExchangeRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ExchangeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExchangeRateAggregateArgs>(args: Subset<T, ExchangeRateAggregateArgs>): Prisma.PrismaPromise<GetExchangeRateAggregateType<T>>

    /**
     * Group by ExchangeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExchangeRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExchangeRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExchangeRateGroupByArgs['orderBy'] }
        : { orderBy?: ExchangeRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExchangeRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExchangeRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ExchangeRate model
   */
  readonly fields: ExchangeRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ExchangeRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExchangeRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ExchangeRate model
   */ 
  interface ExchangeRateFieldRefs {
    readonly id: FieldRef<"ExchangeRate", 'String'>
    readonly fromCurrency: FieldRef<"ExchangeRate", 'String'>
    readonly toCurrency: FieldRef<"ExchangeRate", 'String'>
    readonly rate: FieldRef<"ExchangeRate", 'Float'>
    readonly provider: FieldRef<"ExchangeRate", 'String'>
    readonly timestamp: FieldRef<"ExchangeRate", 'DateTime'>
    readonly createdAt: FieldRef<"ExchangeRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ExchangeRate findUnique
   */
  export type ExchangeRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate findUniqueOrThrow
   */
  export type ExchangeRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate findFirst
   */
  export type ExchangeRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeRates.
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeRates.
     */
    distinct?: ExchangeRateScalarFieldEnum | ExchangeRateScalarFieldEnum[]
  }

  /**
   * ExchangeRate findFirstOrThrow
   */
  export type ExchangeRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Filter, which ExchangeRate to fetch.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ExchangeRates.
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ExchangeRates.
     */
    distinct?: ExchangeRateScalarFieldEnum | ExchangeRateScalarFieldEnum[]
  }

  /**
   * ExchangeRate findMany
   */
  export type ExchangeRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Filter, which ExchangeRates to fetch.
     */
    where?: ExchangeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ExchangeRates to fetch.
     */
    orderBy?: ExchangeRateOrderByWithRelationInput | ExchangeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ExchangeRates.
     */
    cursor?: ExchangeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ExchangeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ExchangeRates.
     */
    skip?: number
    distinct?: ExchangeRateScalarFieldEnum | ExchangeRateScalarFieldEnum[]
  }

  /**
   * ExchangeRate create
   */
  export type ExchangeRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * The data needed to create a ExchangeRate.
     */
    data: XOR<ExchangeRateCreateInput, ExchangeRateUncheckedCreateInput>
  }

  /**
   * ExchangeRate createMany
   */
  export type ExchangeRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ExchangeRates.
     */
    data: ExchangeRateCreateManyInput | ExchangeRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExchangeRate createManyAndReturn
   */
  export type ExchangeRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ExchangeRates.
     */
    data: ExchangeRateCreateManyInput | ExchangeRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ExchangeRate update
   */
  export type ExchangeRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * The data needed to update a ExchangeRate.
     */
    data: XOR<ExchangeRateUpdateInput, ExchangeRateUncheckedUpdateInput>
    /**
     * Choose, which ExchangeRate to update.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate updateMany
   */
  export type ExchangeRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ExchangeRates.
     */
    data: XOR<ExchangeRateUpdateManyMutationInput, ExchangeRateUncheckedUpdateManyInput>
    /**
     * Filter which ExchangeRates to update
     */
    where?: ExchangeRateWhereInput
  }

  /**
   * ExchangeRate upsert
   */
  export type ExchangeRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * The filter to search for the ExchangeRate to update in case it exists.
     */
    where: ExchangeRateWhereUniqueInput
    /**
     * In case the ExchangeRate found by the `where` argument doesn't exist, create a new ExchangeRate with this data.
     */
    create: XOR<ExchangeRateCreateInput, ExchangeRateUncheckedCreateInput>
    /**
     * In case the ExchangeRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExchangeRateUpdateInput, ExchangeRateUncheckedUpdateInput>
  }

  /**
   * ExchangeRate delete
   */
  export type ExchangeRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
    /**
     * Filter which ExchangeRate to delete.
     */
    where: ExchangeRateWhereUniqueInput
  }

  /**
   * ExchangeRate deleteMany
   */
  export type ExchangeRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ExchangeRates to delete
     */
    where?: ExchangeRateWhereInput
  }

  /**
   * ExchangeRate without action
   */
  export type ExchangeRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ExchangeRate
     */
    select?: ExchangeRateSelect<ExtArgs> | null
  }


  /**
   * Model PaymentNetworkStatus
   */

  export type AggregatePaymentNetworkStatus = {
    _count: PaymentNetworkStatusCountAggregateOutputType | null
    _avg: PaymentNetworkStatusAvgAggregateOutputType | null
    _sum: PaymentNetworkStatusSumAggregateOutputType | null
    _min: PaymentNetworkStatusMinAggregateOutputType | null
    _max: PaymentNetworkStatusMaxAggregateOutputType | null
  }

  export type PaymentNetworkStatusAvgAggregateOutputType = {
    responseTime: number | null
  }

  export type PaymentNetworkStatusSumAggregateOutputType = {
    responseTime: number | null
  }

  export type PaymentNetworkStatusMinAggregateOutputType = {
    id: string | null
    provider: $Enums.PaymentProvider | null
    isOnline: boolean | null
    responseTime: number | null
    lastChecked: Date | null
    maintenanceStart: Date | null
    maintenanceEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentNetworkStatusMaxAggregateOutputType = {
    id: string | null
    provider: $Enums.PaymentProvider | null
    isOnline: boolean | null
    responseTime: number | null
    lastChecked: Date | null
    maintenanceStart: Date | null
    maintenanceEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentNetworkStatusCountAggregateOutputType = {
    id: number
    provider: number
    isOnline: number
    responseTime: number
    lastChecked: number
    maintenanceStart: number
    maintenanceEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentNetworkStatusAvgAggregateInputType = {
    responseTime?: true
  }

  export type PaymentNetworkStatusSumAggregateInputType = {
    responseTime?: true
  }

  export type PaymentNetworkStatusMinAggregateInputType = {
    id?: true
    provider?: true
    isOnline?: true
    responseTime?: true
    lastChecked?: true
    maintenanceStart?: true
    maintenanceEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentNetworkStatusMaxAggregateInputType = {
    id?: true
    provider?: true
    isOnline?: true
    responseTime?: true
    lastChecked?: true
    maintenanceStart?: true
    maintenanceEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentNetworkStatusCountAggregateInputType = {
    id?: true
    provider?: true
    isOnline?: true
    responseTime?: true
    lastChecked?: true
    maintenanceStart?: true
    maintenanceEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentNetworkStatusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentNetworkStatus to aggregate.
     */
    where?: PaymentNetworkStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentNetworkStatuses to fetch.
     */
    orderBy?: PaymentNetworkStatusOrderByWithRelationInput | PaymentNetworkStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentNetworkStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentNetworkStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentNetworkStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PaymentNetworkStatuses
    **/
    _count?: true | PaymentNetworkStatusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentNetworkStatusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentNetworkStatusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentNetworkStatusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentNetworkStatusMaxAggregateInputType
  }

  export type GetPaymentNetworkStatusAggregateType<T extends PaymentNetworkStatusAggregateArgs> = {
        [P in keyof T & keyof AggregatePaymentNetworkStatus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePaymentNetworkStatus[P]>
      : GetScalarType<T[P], AggregatePaymentNetworkStatus[P]>
  }




  export type PaymentNetworkStatusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentNetworkStatusWhereInput
    orderBy?: PaymentNetworkStatusOrderByWithAggregationInput | PaymentNetworkStatusOrderByWithAggregationInput[]
    by: PaymentNetworkStatusScalarFieldEnum[] | PaymentNetworkStatusScalarFieldEnum
    having?: PaymentNetworkStatusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentNetworkStatusCountAggregateInputType | true
    _avg?: PaymentNetworkStatusAvgAggregateInputType
    _sum?: PaymentNetworkStatusSumAggregateInputType
    _min?: PaymentNetworkStatusMinAggregateInputType
    _max?: PaymentNetworkStatusMaxAggregateInputType
  }

  export type PaymentNetworkStatusGroupByOutputType = {
    id: string
    provider: $Enums.PaymentProvider
    isOnline: boolean
    responseTime: number
    lastChecked: Date
    maintenanceStart: Date | null
    maintenanceEnd: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentNetworkStatusCountAggregateOutputType | null
    _avg: PaymentNetworkStatusAvgAggregateOutputType | null
    _sum: PaymentNetworkStatusSumAggregateOutputType | null
    _min: PaymentNetworkStatusMinAggregateOutputType | null
    _max: PaymentNetworkStatusMaxAggregateOutputType | null
  }

  type GetPaymentNetworkStatusGroupByPayload<T extends PaymentNetworkStatusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentNetworkStatusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentNetworkStatusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentNetworkStatusGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentNetworkStatusGroupByOutputType[P]>
        }
      >
    >


  export type PaymentNetworkStatusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    isOnline?: boolean
    responseTime?: boolean
    lastChecked?: boolean
    maintenanceStart?: boolean
    maintenanceEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentNetworkStatus"]>

  export type PaymentNetworkStatusSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    provider?: boolean
    isOnline?: boolean
    responseTime?: boolean
    lastChecked?: boolean
    maintenanceStart?: boolean
    maintenanceEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["paymentNetworkStatus"]>

  export type PaymentNetworkStatusSelectScalar = {
    id?: boolean
    provider?: boolean
    isOnline?: boolean
    responseTime?: boolean
    lastChecked?: boolean
    maintenanceStart?: boolean
    maintenanceEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $PaymentNetworkStatusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PaymentNetworkStatus"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      provider: $Enums.PaymentProvider
      isOnline: boolean
      responseTime: number
      lastChecked: Date
      maintenanceStart: Date | null
      maintenanceEnd: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["paymentNetworkStatus"]>
    composites: {}
  }

  type PaymentNetworkStatusGetPayload<S extends boolean | null | undefined | PaymentNetworkStatusDefaultArgs> = $Result.GetResult<Prisma.$PaymentNetworkStatusPayload, S>

  type PaymentNetworkStatusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentNetworkStatusFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentNetworkStatusCountAggregateInputType | true
    }

  export interface PaymentNetworkStatusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PaymentNetworkStatus'], meta: { name: 'PaymentNetworkStatus' } }
    /**
     * Find zero or one PaymentNetworkStatus that matches the filter.
     * @param {PaymentNetworkStatusFindUniqueArgs} args - Arguments to find a PaymentNetworkStatus
     * @example
     * // Get one PaymentNetworkStatus
     * const paymentNetworkStatus = await prisma.paymentNetworkStatus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentNetworkStatusFindUniqueArgs>(args: SelectSubset<T, PaymentNetworkStatusFindUniqueArgs<ExtArgs>>): Prisma__PaymentNetworkStatusClient<$Result.GetResult<Prisma.$PaymentNetworkStatusPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PaymentNetworkStatus that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentNetworkStatusFindUniqueOrThrowArgs} args - Arguments to find a PaymentNetworkStatus
     * @example
     * // Get one PaymentNetworkStatus
     * const paymentNetworkStatus = await prisma.paymentNetworkStatus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentNetworkStatusFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentNetworkStatusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentNetworkStatusClient<$Result.GetResult<Prisma.$PaymentNetworkStatusPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PaymentNetworkStatus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentNetworkStatusFindFirstArgs} args - Arguments to find a PaymentNetworkStatus
     * @example
     * // Get one PaymentNetworkStatus
     * const paymentNetworkStatus = await prisma.paymentNetworkStatus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentNetworkStatusFindFirstArgs>(args?: SelectSubset<T, PaymentNetworkStatusFindFirstArgs<ExtArgs>>): Prisma__PaymentNetworkStatusClient<$Result.GetResult<Prisma.$PaymentNetworkStatusPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PaymentNetworkStatus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentNetworkStatusFindFirstOrThrowArgs} args - Arguments to find a PaymentNetworkStatus
     * @example
     * // Get one PaymentNetworkStatus
     * const paymentNetworkStatus = await prisma.paymentNetworkStatus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentNetworkStatusFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentNetworkStatusFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentNetworkStatusClient<$Result.GetResult<Prisma.$PaymentNetworkStatusPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PaymentNetworkStatuses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentNetworkStatusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PaymentNetworkStatuses
     * const paymentNetworkStatuses = await prisma.paymentNetworkStatus.findMany()
     * 
     * // Get first 10 PaymentNetworkStatuses
     * const paymentNetworkStatuses = await prisma.paymentNetworkStatus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentNetworkStatusWithIdOnly = await prisma.paymentNetworkStatus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentNetworkStatusFindManyArgs>(args?: SelectSubset<T, PaymentNetworkStatusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentNetworkStatusPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PaymentNetworkStatus.
     * @param {PaymentNetworkStatusCreateArgs} args - Arguments to create a PaymentNetworkStatus.
     * @example
     * // Create one PaymentNetworkStatus
     * const PaymentNetworkStatus = await prisma.paymentNetworkStatus.create({
     *   data: {
     *     // ... data to create a PaymentNetworkStatus
     *   }
     * })
     * 
     */
    create<T extends PaymentNetworkStatusCreateArgs>(args: SelectSubset<T, PaymentNetworkStatusCreateArgs<ExtArgs>>): Prisma__PaymentNetworkStatusClient<$Result.GetResult<Prisma.$PaymentNetworkStatusPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PaymentNetworkStatuses.
     * @param {PaymentNetworkStatusCreateManyArgs} args - Arguments to create many PaymentNetworkStatuses.
     * @example
     * // Create many PaymentNetworkStatuses
     * const paymentNetworkStatus = await prisma.paymentNetworkStatus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentNetworkStatusCreateManyArgs>(args?: SelectSubset<T, PaymentNetworkStatusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PaymentNetworkStatuses and returns the data saved in the database.
     * @param {PaymentNetworkStatusCreateManyAndReturnArgs} args - Arguments to create many PaymentNetworkStatuses.
     * @example
     * // Create many PaymentNetworkStatuses
     * const paymentNetworkStatus = await prisma.paymentNetworkStatus.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PaymentNetworkStatuses and only return the `id`
     * const paymentNetworkStatusWithIdOnly = await prisma.paymentNetworkStatus.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentNetworkStatusCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentNetworkStatusCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentNetworkStatusPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PaymentNetworkStatus.
     * @param {PaymentNetworkStatusDeleteArgs} args - Arguments to delete one PaymentNetworkStatus.
     * @example
     * // Delete one PaymentNetworkStatus
     * const PaymentNetworkStatus = await prisma.paymentNetworkStatus.delete({
     *   where: {
     *     // ... filter to delete one PaymentNetworkStatus
     *   }
     * })
     * 
     */
    delete<T extends PaymentNetworkStatusDeleteArgs>(args: SelectSubset<T, PaymentNetworkStatusDeleteArgs<ExtArgs>>): Prisma__PaymentNetworkStatusClient<$Result.GetResult<Prisma.$PaymentNetworkStatusPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PaymentNetworkStatus.
     * @param {PaymentNetworkStatusUpdateArgs} args - Arguments to update one PaymentNetworkStatus.
     * @example
     * // Update one PaymentNetworkStatus
     * const paymentNetworkStatus = await prisma.paymentNetworkStatus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentNetworkStatusUpdateArgs>(args: SelectSubset<T, PaymentNetworkStatusUpdateArgs<ExtArgs>>): Prisma__PaymentNetworkStatusClient<$Result.GetResult<Prisma.$PaymentNetworkStatusPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PaymentNetworkStatuses.
     * @param {PaymentNetworkStatusDeleteManyArgs} args - Arguments to filter PaymentNetworkStatuses to delete.
     * @example
     * // Delete a few PaymentNetworkStatuses
     * const { count } = await prisma.paymentNetworkStatus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentNetworkStatusDeleteManyArgs>(args?: SelectSubset<T, PaymentNetworkStatusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PaymentNetworkStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentNetworkStatusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PaymentNetworkStatuses
     * const paymentNetworkStatus = await prisma.paymentNetworkStatus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentNetworkStatusUpdateManyArgs>(args: SelectSubset<T, PaymentNetworkStatusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PaymentNetworkStatus.
     * @param {PaymentNetworkStatusUpsertArgs} args - Arguments to update or create a PaymentNetworkStatus.
     * @example
     * // Update or create a PaymentNetworkStatus
     * const paymentNetworkStatus = await prisma.paymentNetworkStatus.upsert({
     *   create: {
     *     // ... data to create a PaymentNetworkStatus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PaymentNetworkStatus we want to update
     *   }
     * })
     */
    upsert<T extends PaymentNetworkStatusUpsertArgs>(args: SelectSubset<T, PaymentNetworkStatusUpsertArgs<ExtArgs>>): Prisma__PaymentNetworkStatusClient<$Result.GetResult<Prisma.$PaymentNetworkStatusPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PaymentNetworkStatuses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentNetworkStatusCountArgs} args - Arguments to filter PaymentNetworkStatuses to count.
     * @example
     * // Count the number of PaymentNetworkStatuses
     * const count = await prisma.paymentNetworkStatus.count({
     *   where: {
     *     // ... the filter for the PaymentNetworkStatuses we want to count
     *   }
     * })
    **/
    count<T extends PaymentNetworkStatusCountArgs>(
      args?: Subset<T, PaymentNetworkStatusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentNetworkStatusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PaymentNetworkStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentNetworkStatusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentNetworkStatusAggregateArgs>(args: Subset<T, PaymentNetworkStatusAggregateArgs>): Prisma.PrismaPromise<GetPaymentNetworkStatusAggregateType<T>>

    /**
     * Group by PaymentNetworkStatus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentNetworkStatusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentNetworkStatusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentNetworkStatusGroupByArgs['orderBy'] }
        : { orderBy?: PaymentNetworkStatusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentNetworkStatusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentNetworkStatusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PaymentNetworkStatus model
   */
  readonly fields: PaymentNetworkStatusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PaymentNetworkStatus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentNetworkStatusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PaymentNetworkStatus model
   */ 
  interface PaymentNetworkStatusFieldRefs {
    readonly id: FieldRef<"PaymentNetworkStatus", 'String'>
    readonly provider: FieldRef<"PaymentNetworkStatus", 'PaymentProvider'>
    readonly isOnline: FieldRef<"PaymentNetworkStatus", 'Boolean'>
    readonly responseTime: FieldRef<"PaymentNetworkStatus", 'Int'>
    readonly lastChecked: FieldRef<"PaymentNetworkStatus", 'DateTime'>
    readonly maintenanceStart: FieldRef<"PaymentNetworkStatus", 'DateTime'>
    readonly maintenanceEnd: FieldRef<"PaymentNetworkStatus", 'DateTime'>
    readonly createdAt: FieldRef<"PaymentNetworkStatus", 'DateTime'>
    readonly updatedAt: FieldRef<"PaymentNetworkStatus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PaymentNetworkStatus findUnique
   */
  export type PaymentNetworkStatusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentNetworkStatus
     */
    select?: PaymentNetworkStatusSelect<ExtArgs> | null
    /**
     * Filter, which PaymentNetworkStatus to fetch.
     */
    where: PaymentNetworkStatusWhereUniqueInput
  }

  /**
   * PaymentNetworkStatus findUniqueOrThrow
   */
  export type PaymentNetworkStatusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentNetworkStatus
     */
    select?: PaymentNetworkStatusSelect<ExtArgs> | null
    /**
     * Filter, which PaymentNetworkStatus to fetch.
     */
    where: PaymentNetworkStatusWhereUniqueInput
  }

  /**
   * PaymentNetworkStatus findFirst
   */
  export type PaymentNetworkStatusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentNetworkStatus
     */
    select?: PaymentNetworkStatusSelect<ExtArgs> | null
    /**
     * Filter, which PaymentNetworkStatus to fetch.
     */
    where?: PaymentNetworkStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentNetworkStatuses to fetch.
     */
    orderBy?: PaymentNetworkStatusOrderByWithRelationInput | PaymentNetworkStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentNetworkStatuses.
     */
    cursor?: PaymentNetworkStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentNetworkStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentNetworkStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentNetworkStatuses.
     */
    distinct?: PaymentNetworkStatusScalarFieldEnum | PaymentNetworkStatusScalarFieldEnum[]
  }

  /**
   * PaymentNetworkStatus findFirstOrThrow
   */
  export type PaymentNetworkStatusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentNetworkStatus
     */
    select?: PaymentNetworkStatusSelect<ExtArgs> | null
    /**
     * Filter, which PaymentNetworkStatus to fetch.
     */
    where?: PaymentNetworkStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentNetworkStatuses to fetch.
     */
    orderBy?: PaymentNetworkStatusOrderByWithRelationInput | PaymentNetworkStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PaymentNetworkStatuses.
     */
    cursor?: PaymentNetworkStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentNetworkStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentNetworkStatuses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PaymentNetworkStatuses.
     */
    distinct?: PaymentNetworkStatusScalarFieldEnum | PaymentNetworkStatusScalarFieldEnum[]
  }

  /**
   * PaymentNetworkStatus findMany
   */
  export type PaymentNetworkStatusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentNetworkStatus
     */
    select?: PaymentNetworkStatusSelect<ExtArgs> | null
    /**
     * Filter, which PaymentNetworkStatuses to fetch.
     */
    where?: PaymentNetworkStatusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PaymentNetworkStatuses to fetch.
     */
    orderBy?: PaymentNetworkStatusOrderByWithRelationInput | PaymentNetworkStatusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PaymentNetworkStatuses.
     */
    cursor?: PaymentNetworkStatusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PaymentNetworkStatuses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PaymentNetworkStatuses.
     */
    skip?: number
    distinct?: PaymentNetworkStatusScalarFieldEnum | PaymentNetworkStatusScalarFieldEnum[]
  }

  /**
   * PaymentNetworkStatus create
   */
  export type PaymentNetworkStatusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentNetworkStatus
     */
    select?: PaymentNetworkStatusSelect<ExtArgs> | null
    /**
     * The data needed to create a PaymentNetworkStatus.
     */
    data: XOR<PaymentNetworkStatusCreateInput, PaymentNetworkStatusUncheckedCreateInput>
  }

  /**
   * PaymentNetworkStatus createMany
   */
  export type PaymentNetworkStatusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PaymentNetworkStatuses.
     */
    data: PaymentNetworkStatusCreateManyInput | PaymentNetworkStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentNetworkStatus createManyAndReturn
   */
  export type PaymentNetworkStatusCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentNetworkStatus
     */
    select?: PaymentNetworkStatusSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PaymentNetworkStatuses.
     */
    data: PaymentNetworkStatusCreateManyInput | PaymentNetworkStatusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PaymentNetworkStatus update
   */
  export type PaymentNetworkStatusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentNetworkStatus
     */
    select?: PaymentNetworkStatusSelect<ExtArgs> | null
    /**
     * The data needed to update a PaymentNetworkStatus.
     */
    data: XOR<PaymentNetworkStatusUpdateInput, PaymentNetworkStatusUncheckedUpdateInput>
    /**
     * Choose, which PaymentNetworkStatus to update.
     */
    where: PaymentNetworkStatusWhereUniqueInput
  }

  /**
   * PaymentNetworkStatus updateMany
   */
  export type PaymentNetworkStatusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PaymentNetworkStatuses.
     */
    data: XOR<PaymentNetworkStatusUpdateManyMutationInput, PaymentNetworkStatusUncheckedUpdateManyInput>
    /**
     * Filter which PaymentNetworkStatuses to update
     */
    where?: PaymentNetworkStatusWhereInput
  }

  /**
   * PaymentNetworkStatus upsert
   */
  export type PaymentNetworkStatusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentNetworkStatus
     */
    select?: PaymentNetworkStatusSelect<ExtArgs> | null
    /**
     * The filter to search for the PaymentNetworkStatus to update in case it exists.
     */
    where: PaymentNetworkStatusWhereUniqueInput
    /**
     * In case the PaymentNetworkStatus found by the `where` argument doesn't exist, create a new PaymentNetworkStatus with this data.
     */
    create: XOR<PaymentNetworkStatusCreateInput, PaymentNetworkStatusUncheckedCreateInput>
    /**
     * In case the PaymentNetworkStatus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentNetworkStatusUpdateInput, PaymentNetworkStatusUncheckedUpdateInput>
  }

  /**
   * PaymentNetworkStatus delete
   */
  export type PaymentNetworkStatusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentNetworkStatus
     */
    select?: PaymentNetworkStatusSelect<ExtArgs> | null
    /**
     * Filter which PaymentNetworkStatus to delete.
     */
    where: PaymentNetworkStatusWhereUniqueInput
  }

  /**
   * PaymentNetworkStatus deleteMany
   */
  export type PaymentNetworkStatusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PaymentNetworkStatuses to delete
     */
    where?: PaymentNetworkStatusWhereInput
  }

  /**
   * PaymentNetworkStatus without action
   */
  export type PaymentNetworkStatusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentNetworkStatus
     */
    select?: PaymentNetworkStatusSelect<ExtArgs> | null
  }


  /**
   * Model UserSession
   */

  export type AggregateUserSession = {
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  export type UserSessionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    refreshToken: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    token: string | null
    refreshToken: string | null
    ipAddress: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSessionCountAggregateOutputType = {
    id: number
    userId: number
    token: number
    refreshToken: number
    deviceInfo: number
    ipAddress: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSessionMinAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionMaxAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSessionCountAggregateInputType = {
    id?: true
    userId?: true
    token?: true
    refreshToken?: true
    deviceInfo?: true
    ipAddress?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSession to aggregate.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSessions
    **/
    _count?: true | UserSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSessionMaxAggregateInputType
  }

  export type GetUserSessionAggregateType<T extends UserSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSession[P]>
      : GetScalarType<T[P], AggregateUserSession[P]>
  }




  export type UserSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSessionWhereInput
    orderBy?: UserSessionOrderByWithAggregationInput | UserSessionOrderByWithAggregationInput[]
    by: UserSessionScalarFieldEnum[] | UserSessionScalarFieldEnum
    having?: UserSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSessionCountAggregateInputType | true
    _min?: UserSessionMinAggregateInputType
    _max?: UserSessionMaxAggregateInputType
  }

  export type UserSessionGroupByOutputType = {
    id: string
    userId: string
    token: string
    refreshToken: string
    deviceInfo: JsonValue | null
    ipAddress: string | null
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    _count: UserSessionCountAggregateOutputType | null
    _min: UserSessionMinAggregateOutputType | null
    _max: UserSessionMaxAggregateOutputType | null
  }

  type GetUserSessionGroupByPayload<T extends UserSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
            : GetScalarType<T[P], UserSessionGroupByOutputType[P]>
        }
      >
    >


  export type UserSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSession"]>

  export type UserSessionSelectScalar = {
    id?: boolean
    userId?: boolean
    token?: boolean
    refreshToken?: boolean
    deviceInfo?: boolean
    ipAddress?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSession"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      token: string
      refreshToken: string
      deviceInfo: Prisma.JsonValue | null
      ipAddress: string | null
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSession"]>
    composites: {}
  }

  type UserSessionGetPayload<S extends boolean | null | undefined | UserSessionDefaultArgs> = $Result.GetResult<Prisma.$UserSessionPayload, S>

  type UserSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserSessionCountAggregateInputType | true
    }

  export interface UserSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSession'], meta: { name: 'UserSession' } }
    /**
     * Find zero or one UserSession that matches the filter.
     * @param {UserSessionFindUniqueArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSessionFindUniqueArgs>(args: SelectSubset<T, UserSessionFindUniqueArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserSessionFindUniqueOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSessionFindFirstArgs>(args?: SelectSubset<T, UserSessionFindFirstArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindFirstOrThrowArgs} args - Arguments to find a UserSession
     * @example
     * // Get one UserSession
     * const userSession = await prisma.userSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSessions
     * const userSessions = await prisma.userSession.findMany()
     * 
     * // Get first 10 UserSessions
     * const userSessions = await prisma.userSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSessionWithIdOnly = await prisma.userSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSessionFindManyArgs>(args?: SelectSubset<T, UserSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserSession.
     * @param {UserSessionCreateArgs} args - Arguments to create a UserSession.
     * @example
     * // Create one UserSession
     * const UserSession = await prisma.userSession.create({
     *   data: {
     *     // ... data to create a UserSession
     *   }
     * })
     * 
     */
    create<T extends UserSessionCreateArgs>(args: SelectSubset<T, UserSessionCreateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserSessions.
     * @param {UserSessionCreateManyArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSessionCreateManyArgs>(args?: SelectSubset<T, UserSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSessions and returns the data saved in the database.
     * @param {UserSessionCreateManyAndReturnArgs} args - Arguments to create many UserSessions.
     * @example
     * // Create many UserSessions
     * const userSession = await prisma.userSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSessions and only return the `id`
     * const userSessionWithIdOnly = await prisma.userSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a UserSession.
     * @param {UserSessionDeleteArgs} args - Arguments to delete one UserSession.
     * @example
     * // Delete one UserSession
     * const UserSession = await prisma.userSession.delete({
     *   where: {
     *     // ... filter to delete one UserSession
     *   }
     * })
     * 
     */
    delete<T extends UserSessionDeleteArgs>(args: SelectSubset<T, UserSessionDeleteArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserSession.
     * @param {UserSessionUpdateArgs} args - Arguments to update one UserSession.
     * @example
     * // Update one UserSession
     * const userSession = await prisma.userSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSessionUpdateArgs>(args: SelectSubset<T, UserSessionUpdateArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserSessions.
     * @param {UserSessionDeleteManyArgs} args - Arguments to filter UserSessions to delete.
     * @example
     * // Delete a few UserSessions
     * const { count } = await prisma.userSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSessionDeleteManyArgs>(args?: SelectSubset<T, UserSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSessions
     * const userSession = await prisma.userSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSessionUpdateManyArgs>(args: SelectSubset<T, UserSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserSession.
     * @param {UserSessionUpsertArgs} args - Arguments to update or create a UserSession.
     * @example
     * // Update or create a UserSession
     * const userSession = await prisma.userSession.upsert({
     *   create: {
     *     // ... data to create a UserSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSession we want to update
     *   }
     * })
     */
    upsert<T extends UserSessionUpsertArgs>(args: SelectSubset<T, UserSessionUpsertArgs<ExtArgs>>): Prisma__UserSessionClient<$Result.GetResult<Prisma.$UserSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionCountArgs} args - Arguments to filter UserSessions to count.
     * @example
     * // Count the number of UserSessions
     * const count = await prisma.userSession.count({
     *   where: {
     *     // ... the filter for the UserSessions we want to count
     *   }
     * })
    **/
    count<T extends UserSessionCountArgs>(
      args?: Subset<T, UserSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSessionAggregateArgs>(args: Subset<T, UserSessionAggregateArgs>): Prisma.PrismaPromise<GetUserSessionAggregateType<T>>

    /**
     * Group by UserSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSessionGroupByArgs['orderBy'] }
        : { orderBy?: UserSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSession model
   */
  readonly fields: UserSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSession model
   */ 
  interface UserSessionFieldRefs {
    readonly id: FieldRef<"UserSession", 'String'>
    readonly userId: FieldRef<"UserSession", 'String'>
    readonly token: FieldRef<"UserSession", 'String'>
    readonly refreshToken: FieldRef<"UserSession", 'String'>
    readonly deviceInfo: FieldRef<"UserSession", 'Json'>
    readonly ipAddress: FieldRef<"UserSession", 'String'>
    readonly expiresAt: FieldRef<"UserSession", 'DateTime'>
    readonly createdAt: FieldRef<"UserSession", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSession findUnique
   */
  export type UserSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findUniqueOrThrow
   */
  export type UserSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession findFirst
   */
  export type UserSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findFirstOrThrow
   */
  export type UserSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSession to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSessions.
     */
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession findMany
   */
  export type UserSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter, which UserSessions to fetch.
     */
    where?: UserSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSessions to fetch.
     */
    orderBy?: UserSessionOrderByWithRelationInput | UserSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSessions.
     */
    cursor?: UserSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSessions.
     */
    skip?: number
    distinct?: UserSessionScalarFieldEnum | UserSessionScalarFieldEnum[]
  }

  /**
   * UserSession create
   */
  export type UserSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSession.
     */
    data: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
  }

  /**
   * UserSession createMany
   */
  export type UserSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSession createManyAndReturn
   */
  export type UserSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many UserSessions.
     */
    data: UserSessionCreateManyInput | UserSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSession update
   */
  export type UserSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSession.
     */
    data: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
    /**
     * Choose, which UserSession to update.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession updateMany
   */
  export type UserSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSessions.
     */
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyInput>
    /**
     * Filter which UserSessions to update
     */
    where?: UserSessionWhereInput
  }

  /**
   * UserSession upsert
   */
  export type UserSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSession to update in case it exists.
     */
    where: UserSessionWhereUniqueInput
    /**
     * In case the UserSession found by the `where` argument doesn't exist, create a new UserSession with this data.
     */
    create: XOR<UserSessionCreateInput, UserSessionUncheckedCreateInput>
    /**
     * In case the UserSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSessionUpdateInput, UserSessionUncheckedUpdateInput>
  }

  /**
   * UserSession delete
   */
  export type UserSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
    /**
     * Filter which UserSession to delete.
     */
    where: UserSessionWhereUniqueInput
  }

  /**
   * UserSession deleteMany
   */
  export type UserSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSessions to delete
     */
    where?: UserSessionWhereInput
  }

  /**
   * UserSession without action
   */
  export type UserSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSession
     */
    select?: UserSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSessionInclude<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    resource: string | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    resource: number
    details: number
    ipAddress: number
    userAgent: number
    timestamp: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    resource?: true
    details?: true
    ipAddress?: true
    userAgent?: true
    timestamp?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    resource: string
    details: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    timestamp: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    resource?: boolean
    details?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    timestamp?: boolean
  }


  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      resource: string
      details: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      timestamp: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly resource: FieldRef<"AuditLog", 'String'>
    readonly details: FieldRef<"AuditLog", 'Json'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly timestamp: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phoneNumber: 'phoneNumber',
    firstName: 'firstName',
    lastName: 'lastName',
    countryCode: 'countryCode',
    preferredCurrency: 'preferredCurrency',
    passwordHash: 'passwordHash',
    isEmailVerified: 'isEmailVerified',
    isPhoneVerified: 'isPhoneVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    avatarUrl: 'avatarUrl',
    dateOfBirth: 'dateOfBirth',
    street: 'street',
    city: 'city',
    state: 'state',
    postalCode: 'postalCode',
    country: 'country',
    kycStatus: 'kycStatus',
    riskProfile: 'riskProfile',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserProfileScalarFieldEnum = (typeof UserProfileScalarFieldEnum)[keyof typeof UserProfileScalarFieldEnum]


  export const LinkedAccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    accountType: 'accountType',
    provider: 'provider',
    accountNumber: 'accountNumber',
    accountName: 'accountName',
    currency: 'currency',
    balance: 'balance',
    isActive: 'isActive',
    isPrimary: 'isPrimary',
    priority: 'priority',
    dailyLimit: 'dailyLimit',
    monthlyLimit: 'monthlyLimit',
    linkedAt: 'linkedAt',
    lastSyncAt: 'lastSyncAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LinkedAccountScalarFieldEnum = (typeof LinkedAccountScalarFieldEnum)[keyof typeof LinkedAccountScalarFieldEnum]


  export const PaymentRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    amount: 'amount',
    currency: 'currency',
    targetCurrency: 'targetCurrency',
    merchantId: 'merchantId',
    merchantName: 'merchantName',
    description: 'description',
    qrCode: 'qrCode',
    metadata: 'metadata',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentRequestScalarFieldEnum = (typeof PaymentRequestScalarFieldEnum)[keyof typeof PaymentRequestScalarFieldEnum]


  export const PaymentTransactionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    paymentRequestId: 'paymentRequestId',
    amount: 'amount',
    currency: 'currency',
    targetAmount: 'targetAmount',
    targetCurrency: 'targetCurrency',
    exchangeRate: 'exchangeRate',
    sourceAccountId: 'sourceAccountId',
    targetAccountId: 'targetAccountId',
    status: 'status',
    failureReason: 'failureReason',
    merchantName: 'merchantName',
    merchantCategory: 'merchantCategory',
    merchantLocation: 'merchantLocation',
    metadata: 'metadata',
    initiatedAt: 'initiatedAt',
    completedAt: 'completedAt',
    failedAt: 'failedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentTransactionScalarFieldEnum = (typeof PaymentTransactionScalarFieldEnum)[keyof typeof PaymentTransactionScalarFieldEnum]


  export const RoutingStepScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    stepNumber: 'stepNumber',
    provider: 'provider',
    action: 'action',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    processingTime: 'processingTime',
    externalTransactionId: 'externalTransactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoutingStepScalarFieldEnum = (typeof RoutingStepScalarFieldEnum)[keyof typeof RoutingStepScalarFieldEnum]


  export const TransactionFeeScalarFieldEnum: {
    id: 'id',
    transactionId: 'transactionId',
    type: 'type',
    amount: 'amount',
    currency: 'currency',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type TransactionFeeScalarFieldEnum = (typeof TransactionFeeScalarFieldEnum)[keyof typeof TransactionFeeScalarFieldEnum]


  export const RoutingStepFeeScalarFieldEnum: {
    id: 'id',
    routingStepId: 'routingStepId',
    type: 'type',
    amount: 'amount',
    currency: 'currency',
    description: 'description',
    createdAt: 'createdAt'
  };

  export type RoutingStepFeeScalarFieldEnum = (typeof RoutingStepFeeScalarFieldEnum)[keyof typeof RoutingStepFeeScalarFieldEnum]


  export const RoutingRuleScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    name: 'name',
    conditions: 'conditions',
    actions: 'actions',
    priority: 'priority',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type RoutingRuleScalarFieldEnum = (typeof RoutingRuleScalarFieldEnum)[keyof typeof RoutingRuleScalarFieldEnum]


  export const ExchangeRateScalarFieldEnum: {
    id: 'id',
    fromCurrency: 'fromCurrency',
    toCurrency: 'toCurrency',
    rate: 'rate',
    provider: 'provider',
    timestamp: 'timestamp',
    createdAt: 'createdAt'
  };

  export type ExchangeRateScalarFieldEnum = (typeof ExchangeRateScalarFieldEnum)[keyof typeof ExchangeRateScalarFieldEnum]


  export const PaymentNetworkStatusScalarFieldEnum: {
    id: 'id',
    provider: 'provider',
    isOnline: 'isOnline',
    responseTime: 'responseTime',
    lastChecked: 'lastChecked',
    maintenanceStart: 'maintenanceStart',
    maintenanceEnd: 'maintenanceEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentNetworkStatusScalarFieldEnum = (typeof PaymentNetworkStatusScalarFieldEnum)[keyof typeof PaymentNetworkStatusScalarFieldEnum]


  export const UserSessionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    token: 'token',
    refreshToken: 'refreshToken',
    deviceInfo: 'deviceInfo',
    ipAddress: 'ipAddress',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSessionScalarFieldEnum = (typeof UserSessionScalarFieldEnum)[keyof typeof UserSessionScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    resource: 'resource',
    details: 'details',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    timestamp: 'timestamp'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'KYCStatus'
   */
  export type EnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus'>
    


  /**
   * Reference to a field of type 'KYCStatus[]'
   */
  export type ListEnumKYCStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'KYCStatus[]'>
    


  /**
   * Reference to a field of type 'RiskProfile'
   */
  export type EnumRiskProfileFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskProfile'>
    


  /**
   * Reference to a field of type 'RiskProfile[]'
   */
  export type ListEnumRiskProfileFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RiskProfile[]'>
    


  /**
   * Reference to a field of type 'AccountType'
   */
  export type EnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType'>
    


  /**
   * Reference to a field of type 'AccountType[]'
   */
  export type ListEnumAccountTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccountType[]'>
    


  /**
   * Reference to a field of type 'PaymentProvider'
   */
  export type EnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider'>
    


  /**
   * Reference to a field of type 'PaymentProvider[]'
   */
  export type ListEnumPaymentProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentProvider[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'TransactionStatus'
   */
  export type EnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus'>
    


  /**
   * Reference to a field of type 'TransactionStatus[]'
   */
  export type ListEnumTransactionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionStatus[]'>
    


  /**
   * Reference to a field of type 'RoutingAction'
   */
  export type EnumRoutingActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoutingAction'>
    


  /**
   * Reference to a field of type 'RoutingAction[]'
   */
  export type ListEnumRoutingActionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoutingAction[]'>
    


  /**
   * Reference to a field of type 'StepStatus'
   */
  export type EnumStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepStatus'>
    


  /**
   * Reference to a field of type 'StepStatus[]'
   */
  export type ListEnumStepStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StepStatus[]'>
    


  /**
   * Reference to a field of type 'FeeType'
   */
  export type EnumFeeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeType'>
    


  /**
   * Reference to a field of type 'FeeType[]'
   */
  export type ListEnumFeeTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FeeType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phoneNumber?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    countryCode?: StringFilter<"User"> | string
    preferredCurrency?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    isEmailVerified?: BoolFilter<"User"> | boolean
    isPhoneVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<UserProfileNullableRelationFilter, UserProfileWhereInput> | null
    linkedAccounts?: LinkedAccountListRelationFilter
    routingRules?: RoutingRuleListRelationFilter
    paymentRequests?: PaymentRequestListRelationFilter
    transactions?: PaymentTransactionListRelationFilter
    sessions?: UserSessionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    countryCode?: SortOrder
    preferredCurrency?: SortOrder
    passwordHash?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: UserProfileOrderByWithRelationInput
    linkedAccounts?: LinkedAccountOrderByRelationAggregateInput
    routingRules?: RoutingRuleOrderByRelationAggregateInput
    paymentRequests?: PaymentRequestOrderByRelationAggregateInput
    transactions?: PaymentTransactionOrderByRelationAggregateInput
    sessions?: UserSessionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phoneNumber?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    countryCode?: StringFilter<"User"> | string
    preferredCurrency?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    isEmailVerified?: BoolFilter<"User"> | boolean
    isPhoneVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<UserProfileNullableRelationFilter, UserProfileWhereInput> | null
    linkedAccounts?: LinkedAccountListRelationFilter
    routingRules?: RoutingRuleListRelationFilter
    paymentRequests?: PaymentRequestListRelationFilter
    transactions?: PaymentTransactionListRelationFilter
    sessions?: UserSessionListRelationFilter
  }, "id" | "email" | "phoneNumber">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    countryCode?: SortOrder
    preferredCurrency?: SortOrder
    passwordHash?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phoneNumber?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    countryCode?: StringWithAggregatesFilter<"User"> | string
    preferredCurrency?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    isEmailVerified?: BoolWithAggregatesFilter<"User"> | boolean
    isPhoneVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserProfileWhereInput = {
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    id?: StringFilter<"UserProfile"> | string
    userId?: StringFilter<"UserProfile"> | string
    avatarUrl?: StringNullableFilter<"UserProfile"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    street?: StringNullableFilter<"UserProfile"> | string | null
    city?: StringNullableFilter<"UserProfile"> | string | null
    state?: StringNullableFilter<"UserProfile"> | string | null
    postalCode?: StringNullableFilter<"UserProfile"> | string | null
    country?: StringNullableFilter<"UserProfile"> | string | null
    kycStatus?: EnumKYCStatusFilter<"UserProfile"> | $Enums.KYCStatus
    riskProfile?: EnumRiskProfileFilter<"UserProfile"> | $Enums.RiskProfile
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    kycStatus?: SortOrder
    riskProfile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserProfileWhereInput | UserProfileWhereInput[]
    OR?: UserProfileWhereInput[]
    NOT?: UserProfileWhereInput | UserProfileWhereInput[]
    avatarUrl?: StringNullableFilter<"UserProfile"> | string | null
    dateOfBirth?: DateTimeNullableFilter<"UserProfile"> | Date | string | null
    street?: StringNullableFilter<"UserProfile"> | string | null
    city?: StringNullableFilter<"UserProfile"> | string | null
    state?: StringNullableFilter<"UserProfile"> | string | null
    postalCode?: StringNullableFilter<"UserProfile"> | string | null
    country?: StringNullableFilter<"UserProfile"> | string | null
    kycStatus?: EnumKYCStatusFilter<"UserProfile"> | $Enums.KYCStatus
    riskProfile?: EnumRiskProfileFilter<"UserProfile"> | $Enums.RiskProfile
    createdAt?: DateTimeFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeFilter<"UserProfile"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    avatarUrl?: SortOrderInput | SortOrder
    dateOfBirth?: SortOrderInput | SortOrder
    street?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    postalCode?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    kycStatus?: SortOrder
    riskProfile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserProfileCountOrderByAggregateInput
    _max?: UserProfileMaxOrderByAggregateInput
    _min?: UserProfileMinOrderByAggregateInput
  }

  export type UserProfileScalarWhereWithAggregatesInput = {
    AND?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    OR?: UserProfileScalarWhereWithAggregatesInput[]
    NOT?: UserProfileScalarWhereWithAggregatesInput | UserProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserProfile"> | string
    userId?: StringWithAggregatesFilter<"UserProfile"> | string
    avatarUrl?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    dateOfBirth?: DateTimeNullableWithAggregatesFilter<"UserProfile"> | Date | string | null
    street?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    city?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    state?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    postalCode?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    country?: StringNullableWithAggregatesFilter<"UserProfile"> | string | null
    kycStatus?: EnumKYCStatusWithAggregatesFilter<"UserProfile"> | $Enums.KYCStatus
    riskProfile?: EnumRiskProfileWithAggregatesFilter<"UserProfile"> | $Enums.RiskProfile
    createdAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserProfile"> | Date | string
  }

  export type LinkedAccountWhereInput = {
    AND?: LinkedAccountWhereInput | LinkedAccountWhereInput[]
    OR?: LinkedAccountWhereInput[]
    NOT?: LinkedAccountWhereInput | LinkedAccountWhereInput[]
    id?: StringFilter<"LinkedAccount"> | string
    userId?: StringFilter<"LinkedAccount"> | string
    accountType?: EnumAccountTypeFilter<"LinkedAccount"> | $Enums.AccountType
    provider?: EnumPaymentProviderFilter<"LinkedAccount"> | $Enums.PaymentProvider
    accountNumber?: StringFilter<"LinkedAccount"> | string
    accountName?: StringFilter<"LinkedAccount"> | string
    currency?: StringFilter<"LinkedAccount"> | string
    balance?: FloatNullableFilter<"LinkedAccount"> | number | null
    isActive?: BoolFilter<"LinkedAccount"> | boolean
    isPrimary?: BoolFilter<"LinkedAccount"> | boolean
    priority?: IntFilter<"LinkedAccount"> | number
    dailyLimit?: FloatNullableFilter<"LinkedAccount"> | number | null
    monthlyLimit?: FloatNullableFilter<"LinkedAccount"> | number | null
    linkedAt?: DateTimeFilter<"LinkedAccount"> | Date | string
    lastSyncAt?: DateTimeNullableFilter<"LinkedAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"LinkedAccount"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    sourceTransactions?: PaymentTransactionListRelationFilter
    targetTransactions?: PaymentTransactionListRelationFilter
  }

  export type LinkedAccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    provider?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    currency?: SortOrder
    balance?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    priority?: SortOrder
    dailyLimit?: SortOrderInput | SortOrder
    monthlyLimit?: SortOrderInput | SortOrder
    linkedAt?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    sourceTransactions?: PaymentTransactionOrderByRelationAggregateInput
    targetTransactions?: PaymentTransactionOrderByRelationAggregateInput
  }

  export type LinkedAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_provider_accountNumber?: LinkedAccountUserIdProviderAccountNumberCompoundUniqueInput
    AND?: LinkedAccountWhereInput | LinkedAccountWhereInput[]
    OR?: LinkedAccountWhereInput[]
    NOT?: LinkedAccountWhereInput | LinkedAccountWhereInput[]
    userId?: StringFilter<"LinkedAccount"> | string
    accountType?: EnumAccountTypeFilter<"LinkedAccount"> | $Enums.AccountType
    provider?: EnumPaymentProviderFilter<"LinkedAccount"> | $Enums.PaymentProvider
    accountNumber?: StringFilter<"LinkedAccount"> | string
    accountName?: StringFilter<"LinkedAccount"> | string
    currency?: StringFilter<"LinkedAccount"> | string
    balance?: FloatNullableFilter<"LinkedAccount"> | number | null
    isActive?: BoolFilter<"LinkedAccount"> | boolean
    isPrimary?: BoolFilter<"LinkedAccount"> | boolean
    priority?: IntFilter<"LinkedAccount"> | number
    dailyLimit?: FloatNullableFilter<"LinkedAccount"> | number | null
    monthlyLimit?: FloatNullableFilter<"LinkedAccount"> | number | null
    linkedAt?: DateTimeFilter<"LinkedAccount"> | Date | string
    lastSyncAt?: DateTimeNullableFilter<"LinkedAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"LinkedAccount"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedAccount"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    sourceTransactions?: PaymentTransactionListRelationFilter
    targetTransactions?: PaymentTransactionListRelationFilter
  }, "id" | "userId_provider_accountNumber">

  export type LinkedAccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    provider?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    currency?: SortOrder
    balance?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    priority?: SortOrder
    dailyLimit?: SortOrderInput | SortOrder
    monthlyLimit?: SortOrderInput | SortOrder
    linkedAt?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LinkedAccountCountOrderByAggregateInput
    _avg?: LinkedAccountAvgOrderByAggregateInput
    _max?: LinkedAccountMaxOrderByAggregateInput
    _min?: LinkedAccountMinOrderByAggregateInput
    _sum?: LinkedAccountSumOrderByAggregateInput
  }

  export type LinkedAccountScalarWhereWithAggregatesInput = {
    AND?: LinkedAccountScalarWhereWithAggregatesInput | LinkedAccountScalarWhereWithAggregatesInput[]
    OR?: LinkedAccountScalarWhereWithAggregatesInput[]
    NOT?: LinkedAccountScalarWhereWithAggregatesInput | LinkedAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LinkedAccount"> | string
    userId?: StringWithAggregatesFilter<"LinkedAccount"> | string
    accountType?: EnumAccountTypeWithAggregatesFilter<"LinkedAccount"> | $Enums.AccountType
    provider?: EnumPaymentProviderWithAggregatesFilter<"LinkedAccount"> | $Enums.PaymentProvider
    accountNumber?: StringWithAggregatesFilter<"LinkedAccount"> | string
    accountName?: StringWithAggregatesFilter<"LinkedAccount"> | string
    currency?: StringWithAggregatesFilter<"LinkedAccount"> | string
    balance?: FloatNullableWithAggregatesFilter<"LinkedAccount"> | number | null
    isActive?: BoolWithAggregatesFilter<"LinkedAccount"> | boolean
    isPrimary?: BoolWithAggregatesFilter<"LinkedAccount"> | boolean
    priority?: IntWithAggregatesFilter<"LinkedAccount"> | number
    dailyLimit?: FloatNullableWithAggregatesFilter<"LinkedAccount"> | number | null
    monthlyLimit?: FloatNullableWithAggregatesFilter<"LinkedAccount"> | number | null
    linkedAt?: DateTimeWithAggregatesFilter<"LinkedAccount"> | Date | string
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"LinkedAccount"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LinkedAccount"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LinkedAccount"> | Date | string
  }

  export type PaymentRequestWhereInput = {
    AND?: PaymentRequestWhereInput | PaymentRequestWhereInput[]
    OR?: PaymentRequestWhereInput[]
    NOT?: PaymentRequestWhereInput | PaymentRequestWhereInput[]
    id?: StringFilter<"PaymentRequest"> | string
    userId?: StringFilter<"PaymentRequest"> | string
    amount?: FloatFilter<"PaymentRequest"> | number
    currency?: StringFilter<"PaymentRequest"> | string
    targetCurrency?: StringNullableFilter<"PaymentRequest"> | string | null
    merchantId?: StringNullableFilter<"PaymentRequest"> | string | null
    merchantName?: StringNullableFilter<"PaymentRequest"> | string | null
    description?: StringNullableFilter<"PaymentRequest"> | string | null
    qrCode?: StringNullableFilter<"PaymentRequest"> | string | null
    metadata?: JsonNullableFilter<"PaymentRequest">
    expiresAt?: DateTimeNullableFilter<"PaymentRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: PaymentTransactionListRelationFilter
  }

  export type PaymentRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    targetCurrency?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    merchantName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    transactions?: PaymentTransactionOrderByRelationAggregateInput
  }

  export type PaymentRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentRequestWhereInput | PaymentRequestWhereInput[]
    OR?: PaymentRequestWhereInput[]
    NOT?: PaymentRequestWhereInput | PaymentRequestWhereInput[]
    userId?: StringFilter<"PaymentRequest"> | string
    amount?: FloatFilter<"PaymentRequest"> | number
    currency?: StringFilter<"PaymentRequest"> | string
    targetCurrency?: StringNullableFilter<"PaymentRequest"> | string | null
    merchantId?: StringNullableFilter<"PaymentRequest"> | string | null
    merchantName?: StringNullableFilter<"PaymentRequest"> | string | null
    description?: StringNullableFilter<"PaymentRequest"> | string | null
    qrCode?: StringNullableFilter<"PaymentRequest"> | string | null
    metadata?: JsonNullableFilter<"PaymentRequest">
    expiresAt?: DateTimeNullableFilter<"PaymentRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentRequest"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    transactions?: PaymentTransactionListRelationFilter
  }, "id">

  export type PaymentRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    targetCurrency?: SortOrderInput | SortOrder
    merchantId?: SortOrderInput | SortOrder
    merchantName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    qrCode?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    expiresAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentRequestCountOrderByAggregateInput
    _avg?: PaymentRequestAvgOrderByAggregateInput
    _max?: PaymentRequestMaxOrderByAggregateInput
    _min?: PaymentRequestMinOrderByAggregateInput
    _sum?: PaymentRequestSumOrderByAggregateInput
  }

  export type PaymentRequestScalarWhereWithAggregatesInput = {
    AND?: PaymentRequestScalarWhereWithAggregatesInput | PaymentRequestScalarWhereWithAggregatesInput[]
    OR?: PaymentRequestScalarWhereWithAggregatesInput[]
    NOT?: PaymentRequestScalarWhereWithAggregatesInput | PaymentRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentRequest"> | string
    userId?: StringWithAggregatesFilter<"PaymentRequest"> | string
    amount?: FloatWithAggregatesFilter<"PaymentRequest"> | number
    currency?: StringWithAggregatesFilter<"PaymentRequest"> | string
    targetCurrency?: StringNullableWithAggregatesFilter<"PaymentRequest"> | string | null
    merchantId?: StringNullableWithAggregatesFilter<"PaymentRequest"> | string | null
    merchantName?: StringNullableWithAggregatesFilter<"PaymentRequest"> | string | null
    description?: StringNullableWithAggregatesFilter<"PaymentRequest"> | string | null
    qrCode?: StringNullableWithAggregatesFilter<"PaymentRequest"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"PaymentRequest">
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PaymentRequest"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentRequest"> | Date | string
  }

  export type PaymentTransactionWhereInput = {
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    id?: StringFilter<"PaymentTransaction"> | string
    userId?: StringFilter<"PaymentTransaction"> | string
    paymentRequestId?: StringNullableFilter<"PaymentTransaction"> | string | null
    amount?: FloatFilter<"PaymentTransaction"> | number
    currency?: StringFilter<"PaymentTransaction"> | string
    targetAmount?: FloatNullableFilter<"PaymentTransaction"> | number | null
    targetCurrency?: StringNullableFilter<"PaymentTransaction"> | string | null
    exchangeRate?: FloatNullableFilter<"PaymentTransaction"> | number | null
    sourceAccountId?: StringFilter<"PaymentTransaction"> | string
    targetAccountId?: StringNullableFilter<"PaymentTransaction"> | string | null
    status?: EnumTransactionStatusFilter<"PaymentTransaction"> | $Enums.TransactionStatus
    failureReason?: StringNullableFilter<"PaymentTransaction"> | string | null
    merchantName?: StringNullableFilter<"PaymentTransaction"> | string | null
    merchantCategory?: StringNullableFilter<"PaymentTransaction"> | string | null
    merchantLocation?: StringNullableFilter<"PaymentTransaction"> | string | null
    metadata?: JsonNullableFilter<"PaymentTransaction">
    initiatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    completedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    paymentRequest?: XOR<PaymentRequestNullableRelationFilter, PaymentRequestWhereInput> | null
    sourceAccount?: XOR<LinkedAccountRelationFilter, LinkedAccountWhereInput>
    targetAccount?: XOR<LinkedAccountNullableRelationFilter, LinkedAccountWhereInput> | null
    routingSteps?: RoutingStepListRelationFilter
    fees?: TransactionFeeListRelationFilter
  }

  export type PaymentTransactionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentRequestId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    targetAmount?: SortOrderInput | SortOrder
    targetCurrency?: SortOrderInput | SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    sourceAccountId?: SortOrder
    targetAccountId?: SortOrderInput | SortOrder
    status?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    merchantName?: SortOrderInput | SortOrder
    merchantCategory?: SortOrderInput | SortOrder
    merchantLocation?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    paymentRequest?: PaymentRequestOrderByWithRelationInput
    sourceAccount?: LinkedAccountOrderByWithRelationInput
    targetAccount?: LinkedAccountOrderByWithRelationInput
    routingSteps?: RoutingStepOrderByRelationAggregateInput
    fees?: TransactionFeeOrderByRelationAggregateInput
  }

  export type PaymentTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    OR?: PaymentTransactionWhereInput[]
    NOT?: PaymentTransactionWhereInput | PaymentTransactionWhereInput[]
    userId?: StringFilter<"PaymentTransaction"> | string
    paymentRequestId?: StringNullableFilter<"PaymentTransaction"> | string | null
    amount?: FloatFilter<"PaymentTransaction"> | number
    currency?: StringFilter<"PaymentTransaction"> | string
    targetAmount?: FloatNullableFilter<"PaymentTransaction"> | number | null
    targetCurrency?: StringNullableFilter<"PaymentTransaction"> | string | null
    exchangeRate?: FloatNullableFilter<"PaymentTransaction"> | number | null
    sourceAccountId?: StringFilter<"PaymentTransaction"> | string
    targetAccountId?: StringNullableFilter<"PaymentTransaction"> | string | null
    status?: EnumTransactionStatusFilter<"PaymentTransaction"> | $Enums.TransactionStatus
    failureReason?: StringNullableFilter<"PaymentTransaction"> | string | null
    merchantName?: StringNullableFilter<"PaymentTransaction"> | string | null
    merchantCategory?: StringNullableFilter<"PaymentTransaction"> | string | null
    merchantLocation?: StringNullableFilter<"PaymentTransaction"> | string | null
    metadata?: JsonNullableFilter<"PaymentTransaction">
    initiatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    completedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    paymentRequest?: XOR<PaymentRequestNullableRelationFilter, PaymentRequestWhereInput> | null
    sourceAccount?: XOR<LinkedAccountRelationFilter, LinkedAccountWhereInput>
    targetAccount?: XOR<LinkedAccountNullableRelationFilter, LinkedAccountWhereInput> | null
    routingSteps?: RoutingStepListRelationFilter
    fees?: TransactionFeeListRelationFilter
  }, "id">

  export type PaymentTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentRequestId?: SortOrderInput | SortOrder
    amount?: SortOrder
    currency?: SortOrder
    targetAmount?: SortOrderInput | SortOrder
    targetCurrency?: SortOrderInput | SortOrder
    exchangeRate?: SortOrderInput | SortOrder
    sourceAccountId?: SortOrder
    targetAccountId?: SortOrderInput | SortOrder
    status?: SortOrder
    failureReason?: SortOrderInput | SortOrder
    merchantName?: SortOrderInput | SortOrder
    merchantCategory?: SortOrderInput | SortOrder
    merchantLocation?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    failedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentTransactionCountOrderByAggregateInput
    _avg?: PaymentTransactionAvgOrderByAggregateInput
    _max?: PaymentTransactionMaxOrderByAggregateInput
    _min?: PaymentTransactionMinOrderByAggregateInput
    _sum?: PaymentTransactionSumOrderByAggregateInput
  }

  export type PaymentTransactionScalarWhereWithAggregatesInput = {
    AND?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    OR?: PaymentTransactionScalarWhereWithAggregatesInput[]
    NOT?: PaymentTransactionScalarWhereWithAggregatesInput | PaymentTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    userId?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    paymentRequestId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    amount?: FloatWithAggregatesFilter<"PaymentTransaction"> | number
    currency?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    targetAmount?: FloatNullableWithAggregatesFilter<"PaymentTransaction"> | number | null
    targetCurrency?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    exchangeRate?: FloatNullableWithAggregatesFilter<"PaymentTransaction"> | number | null
    sourceAccountId?: StringWithAggregatesFilter<"PaymentTransaction"> | string
    targetAccountId?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    status?: EnumTransactionStatusWithAggregatesFilter<"PaymentTransaction"> | $Enums.TransactionStatus
    failureReason?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    merchantName?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    merchantCategory?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    merchantLocation?: StringNullableWithAggregatesFilter<"PaymentTransaction"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"PaymentTransaction">
    initiatedAt?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"PaymentTransaction"> | Date | string | null
    failedAt?: DateTimeNullableWithAggregatesFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentTransaction"> | Date | string
  }

  export type RoutingStepWhereInput = {
    AND?: RoutingStepWhereInput | RoutingStepWhereInput[]
    OR?: RoutingStepWhereInput[]
    NOT?: RoutingStepWhereInput | RoutingStepWhereInput[]
    id?: StringFilter<"RoutingStep"> | string
    transactionId?: StringFilter<"RoutingStep"> | string
    stepNumber?: IntFilter<"RoutingStep"> | number
    provider?: EnumPaymentProviderFilter<"RoutingStep"> | $Enums.PaymentProvider
    action?: EnumRoutingActionFilter<"RoutingStep"> | $Enums.RoutingAction
    amount?: FloatFilter<"RoutingStep"> | number
    currency?: StringFilter<"RoutingStep"> | string
    status?: EnumStepStatusFilter<"RoutingStep"> | $Enums.StepStatus
    processingTime?: IntNullableFilter<"RoutingStep"> | number | null
    externalTransactionId?: StringNullableFilter<"RoutingStep"> | string | null
    createdAt?: DateTimeFilter<"RoutingStep"> | Date | string
    updatedAt?: DateTimeFilter<"RoutingStep"> | Date | string
    transaction?: XOR<PaymentTransactionRelationFilter, PaymentTransactionWhereInput>
    fees?: RoutingStepFeeListRelationFilter
  }

  export type RoutingStepOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    stepNumber?: SortOrder
    provider?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    transaction?: PaymentTransactionOrderByWithRelationInput
    fees?: RoutingStepFeeOrderByRelationAggregateInput
  }

  export type RoutingStepWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    transactionId_stepNumber?: RoutingStepTransactionIdStepNumberCompoundUniqueInput
    AND?: RoutingStepWhereInput | RoutingStepWhereInput[]
    OR?: RoutingStepWhereInput[]
    NOT?: RoutingStepWhereInput | RoutingStepWhereInput[]
    transactionId?: StringFilter<"RoutingStep"> | string
    stepNumber?: IntFilter<"RoutingStep"> | number
    provider?: EnumPaymentProviderFilter<"RoutingStep"> | $Enums.PaymentProvider
    action?: EnumRoutingActionFilter<"RoutingStep"> | $Enums.RoutingAction
    amount?: FloatFilter<"RoutingStep"> | number
    currency?: StringFilter<"RoutingStep"> | string
    status?: EnumStepStatusFilter<"RoutingStep"> | $Enums.StepStatus
    processingTime?: IntNullableFilter<"RoutingStep"> | number | null
    externalTransactionId?: StringNullableFilter<"RoutingStep"> | string | null
    createdAt?: DateTimeFilter<"RoutingStep"> | Date | string
    updatedAt?: DateTimeFilter<"RoutingStep"> | Date | string
    transaction?: XOR<PaymentTransactionRelationFilter, PaymentTransactionWhereInput>
    fees?: RoutingStepFeeListRelationFilter
  }, "id" | "transactionId_stepNumber">

  export type RoutingStepOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    stepNumber?: SortOrder
    provider?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    processingTime?: SortOrderInput | SortOrder
    externalTransactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoutingStepCountOrderByAggregateInput
    _avg?: RoutingStepAvgOrderByAggregateInput
    _max?: RoutingStepMaxOrderByAggregateInput
    _min?: RoutingStepMinOrderByAggregateInput
    _sum?: RoutingStepSumOrderByAggregateInput
  }

  export type RoutingStepScalarWhereWithAggregatesInput = {
    AND?: RoutingStepScalarWhereWithAggregatesInput | RoutingStepScalarWhereWithAggregatesInput[]
    OR?: RoutingStepScalarWhereWithAggregatesInput[]
    NOT?: RoutingStepScalarWhereWithAggregatesInput | RoutingStepScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoutingStep"> | string
    transactionId?: StringWithAggregatesFilter<"RoutingStep"> | string
    stepNumber?: IntWithAggregatesFilter<"RoutingStep"> | number
    provider?: EnumPaymentProviderWithAggregatesFilter<"RoutingStep"> | $Enums.PaymentProvider
    action?: EnumRoutingActionWithAggregatesFilter<"RoutingStep"> | $Enums.RoutingAction
    amount?: FloatWithAggregatesFilter<"RoutingStep"> | number
    currency?: StringWithAggregatesFilter<"RoutingStep"> | string
    status?: EnumStepStatusWithAggregatesFilter<"RoutingStep"> | $Enums.StepStatus
    processingTime?: IntNullableWithAggregatesFilter<"RoutingStep"> | number | null
    externalTransactionId?: StringNullableWithAggregatesFilter<"RoutingStep"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"RoutingStep"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoutingStep"> | Date | string
  }

  export type TransactionFeeWhereInput = {
    AND?: TransactionFeeWhereInput | TransactionFeeWhereInput[]
    OR?: TransactionFeeWhereInput[]
    NOT?: TransactionFeeWhereInput | TransactionFeeWhereInput[]
    id?: StringFilter<"TransactionFee"> | string
    transactionId?: StringFilter<"TransactionFee"> | string
    type?: EnumFeeTypeFilter<"TransactionFee"> | $Enums.FeeType
    amount?: FloatFilter<"TransactionFee"> | number
    currency?: StringFilter<"TransactionFee"> | string
    description?: StringFilter<"TransactionFee"> | string
    createdAt?: DateTimeFilter<"TransactionFee"> | Date | string
    transaction?: XOR<PaymentTransactionRelationFilter, PaymentTransactionWhereInput>
  }

  export type TransactionFeeOrderByWithRelationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    transaction?: PaymentTransactionOrderByWithRelationInput
  }

  export type TransactionFeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionFeeWhereInput | TransactionFeeWhereInput[]
    OR?: TransactionFeeWhereInput[]
    NOT?: TransactionFeeWhereInput | TransactionFeeWhereInput[]
    transactionId?: StringFilter<"TransactionFee"> | string
    type?: EnumFeeTypeFilter<"TransactionFee"> | $Enums.FeeType
    amount?: FloatFilter<"TransactionFee"> | number
    currency?: StringFilter<"TransactionFee"> | string
    description?: StringFilter<"TransactionFee"> | string
    createdAt?: DateTimeFilter<"TransactionFee"> | Date | string
    transaction?: XOR<PaymentTransactionRelationFilter, PaymentTransactionWhereInput>
  }, "id">

  export type TransactionFeeOrderByWithAggregationInput = {
    id?: SortOrder
    transactionId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: TransactionFeeCountOrderByAggregateInput
    _avg?: TransactionFeeAvgOrderByAggregateInput
    _max?: TransactionFeeMaxOrderByAggregateInput
    _min?: TransactionFeeMinOrderByAggregateInput
    _sum?: TransactionFeeSumOrderByAggregateInput
  }

  export type TransactionFeeScalarWhereWithAggregatesInput = {
    AND?: TransactionFeeScalarWhereWithAggregatesInput | TransactionFeeScalarWhereWithAggregatesInput[]
    OR?: TransactionFeeScalarWhereWithAggregatesInput[]
    NOT?: TransactionFeeScalarWhereWithAggregatesInput | TransactionFeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TransactionFee"> | string
    transactionId?: StringWithAggregatesFilter<"TransactionFee"> | string
    type?: EnumFeeTypeWithAggregatesFilter<"TransactionFee"> | $Enums.FeeType
    amount?: FloatWithAggregatesFilter<"TransactionFee"> | number
    currency?: StringWithAggregatesFilter<"TransactionFee"> | string
    description?: StringWithAggregatesFilter<"TransactionFee"> | string
    createdAt?: DateTimeWithAggregatesFilter<"TransactionFee"> | Date | string
  }

  export type RoutingStepFeeWhereInput = {
    AND?: RoutingStepFeeWhereInput | RoutingStepFeeWhereInput[]
    OR?: RoutingStepFeeWhereInput[]
    NOT?: RoutingStepFeeWhereInput | RoutingStepFeeWhereInput[]
    id?: StringFilter<"RoutingStepFee"> | string
    routingStepId?: StringFilter<"RoutingStepFee"> | string
    type?: EnumFeeTypeFilter<"RoutingStepFee"> | $Enums.FeeType
    amount?: FloatFilter<"RoutingStepFee"> | number
    currency?: StringFilter<"RoutingStepFee"> | string
    description?: StringFilter<"RoutingStepFee"> | string
    createdAt?: DateTimeFilter<"RoutingStepFee"> | Date | string
    routingStep?: XOR<RoutingStepRelationFilter, RoutingStepWhereInput>
  }

  export type RoutingStepFeeOrderByWithRelationInput = {
    id?: SortOrder
    routingStepId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    routingStep?: RoutingStepOrderByWithRelationInput
  }

  export type RoutingStepFeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoutingStepFeeWhereInput | RoutingStepFeeWhereInput[]
    OR?: RoutingStepFeeWhereInput[]
    NOT?: RoutingStepFeeWhereInput | RoutingStepFeeWhereInput[]
    routingStepId?: StringFilter<"RoutingStepFee"> | string
    type?: EnumFeeTypeFilter<"RoutingStepFee"> | $Enums.FeeType
    amount?: FloatFilter<"RoutingStepFee"> | number
    currency?: StringFilter<"RoutingStepFee"> | string
    description?: StringFilter<"RoutingStepFee"> | string
    createdAt?: DateTimeFilter<"RoutingStepFee"> | Date | string
    routingStep?: XOR<RoutingStepRelationFilter, RoutingStepWhereInput>
  }, "id">

  export type RoutingStepFeeOrderByWithAggregationInput = {
    id?: SortOrder
    routingStepId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    _count?: RoutingStepFeeCountOrderByAggregateInput
    _avg?: RoutingStepFeeAvgOrderByAggregateInput
    _max?: RoutingStepFeeMaxOrderByAggregateInput
    _min?: RoutingStepFeeMinOrderByAggregateInput
    _sum?: RoutingStepFeeSumOrderByAggregateInput
  }

  export type RoutingStepFeeScalarWhereWithAggregatesInput = {
    AND?: RoutingStepFeeScalarWhereWithAggregatesInput | RoutingStepFeeScalarWhereWithAggregatesInput[]
    OR?: RoutingStepFeeScalarWhereWithAggregatesInput[]
    NOT?: RoutingStepFeeScalarWhereWithAggregatesInput | RoutingStepFeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoutingStepFee"> | string
    routingStepId?: StringWithAggregatesFilter<"RoutingStepFee"> | string
    type?: EnumFeeTypeWithAggregatesFilter<"RoutingStepFee"> | $Enums.FeeType
    amount?: FloatWithAggregatesFilter<"RoutingStepFee"> | number
    currency?: StringWithAggregatesFilter<"RoutingStepFee"> | string
    description?: StringWithAggregatesFilter<"RoutingStepFee"> | string
    createdAt?: DateTimeWithAggregatesFilter<"RoutingStepFee"> | Date | string
  }

  export type RoutingRuleWhereInput = {
    AND?: RoutingRuleWhereInput | RoutingRuleWhereInput[]
    OR?: RoutingRuleWhereInput[]
    NOT?: RoutingRuleWhereInput | RoutingRuleWhereInput[]
    id?: StringFilter<"RoutingRule"> | string
    userId?: StringFilter<"RoutingRule"> | string
    name?: StringFilter<"RoutingRule"> | string
    conditions?: JsonFilter<"RoutingRule">
    actions?: JsonFilter<"RoutingRule">
    priority?: IntFilter<"RoutingRule"> | number
    isActive?: BoolFilter<"RoutingRule"> | boolean
    createdAt?: DateTimeFilter<"RoutingRule"> | Date | string
    updatedAt?: DateTimeFilter<"RoutingRule"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type RoutingRuleOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type RoutingRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoutingRuleWhereInput | RoutingRuleWhereInput[]
    OR?: RoutingRuleWhereInput[]
    NOT?: RoutingRuleWhereInput | RoutingRuleWhereInput[]
    userId?: StringFilter<"RoutingRule"> | string
    name?: StringFilter<"RoutingRule"> | string
    conditions?: JsonFilter<"RoutingRule">
    actions?: JsonFilter<"RoutingRule">
    priority?: IntFilter<"RoutingRule"> | number
    isActive?: BoolFilter<"RoutingRule"> | boolean
    createdAt?: DateTimeFilter<"RoutingRule"> | Date | string
    updatedAt?: DateTimeFilter<"RoutingRule"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type RoutingRuleOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: RoutingRuleCountOrderByAggregateInput
    _avg?: RoutingRuleAvgOrderByAggregateInput
    _max?: RoutingRuleMaxOrderByAggregateInput
    _min?: RoutingRuleMinOrderByAggregateInput
    _sum?: RoutingRuleSumOrderByAggregateInput
  }

  export type RoutingRuleScalarWhereWithAggregatesInput = {
    AND?: RoutingRuleScalarWhereWithAggregatesInput | RoutingRuleScalarWhereWithAggregatesInput[]
    OR?: RoutingRuleScalarWhereWithAggregatesInput[]
    NOT?: RoutingRuleScalarWhereWithAggregatesInput | RoutingRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoutingRule"> | string
    userId?: StringWithAggregatesFilter<"RoutingRule"> | string
    name?: StringWithAggregatesFilter<"RoutingRule"> | string
    conditions?: JsonWithAggregatesFilter<"RoutingRule">
    actions?: JsonWithAggregatesFilter<"RoutingRule">
    priority?: IntWithAggregatesFilter<"RoutingRule"> | number
    isActive?: BoolWithAggregatesFilter<"RoutingRule"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RoutingRule"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RoutingRule"> | Date | string
  }

  export type ExchangeRateWhereInput = {
    AND?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    OR?: ExchangeRateWhereInput[]
    NOT?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    id?: StringFilter<"ExchangeRate"> | string
    fromCurrency?: StringFilter<"ExchangeRate"> | string
    toCurrency?: StringFilter<"ExchangeRate"> | string
    rate?: FloatFilter<"ExchangeRate"> | number
    provider?: StringFilter<"ExchangeRate"> | string
    timestamp?: DateTimeFilter<"ExchangeRate"> | Date | string
    createdAt?: DateTimeFilter<"ExchangeRate"> | Date | string
  }

  export type ExchangeRateOrderByWithRelationInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    provider?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ExchangeRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fromCurrency_toCurrency_provider_timestamp?: ExchangeRateFromCurrencyToCurrencyProviderTimestampCompoundUniqueInput
    AND?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    OR?: ExchangeRateWhereInput[]
    NOT?: ExchangeRateWhereInput | ExchangeRateWhereInput[]
    fromCurrency?: StringFilter<"ExchangeRate"> | string
    toCurrency?: StringFilter<"ExchangeRate"> | string
    rate?: FloatFilter<"ExchangeRate"> | number
    provider?: StringFilter<"ExchangeRate"> | string
    timestamp?: DateTimeFilter<"ExchangeRate"> | Date | string
    createdAt?: DateTimeFilter<"ExchangeRate"> | Date | string
  }, "id" | "fromCurrency_toCurrency_provider_timestamp">

  export type ExchangeRateOrderByWithAggregationInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    provider?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
    _count?: ExchangeRateCountOrderByAggregateInput
    _avg?: ExchangeRateAvgOrderByAggregateInput
    _max?: ExchangeRateMaxOrderByAggregateInput
    _min?: ExchangeRateMinOrderByAggregateInput
    _sum?: ExchangeRateSumOrderByAggregateInput
  }

  export type ExchangeRateScalarWhereWithAggregatesInput = {
    AND?: ExchangeRateScalarWhereWithAggregatesInput | ExchangeRateScalarWhereWithAggregatesInput[]
    OR?: ExchangeRateScalarWhereWithAggregatesInput[]
    NOT?: ExchangeRateScalarWhereWithAggregatesInput | ExchangeRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ExchangeRate"> | string
    fromCurrency?: StringWithAggregatesFilter<"ExchangeRate"> | string
    toCurrency?: StringWithAggregatesFilter<"ExchangeRate"> | string
    rate?: FloatWithAggregatesFilter<"ExchangeRate"> | number
    provider?: StringWithAggregatesFilter<"ExchangeRate"> | string
    timestamp?: DateTimeWithAggregatesFilter<"ExchangeRate"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"ExchangeRate"> | Date | string
  }

  export type PaymentNetworkStatusWhereInput = {
    AND?: PaymentNetworkStatusWhereInput | PaymentNetworkStatusWhereInput[]
    OR?: PaymentNetworkStatusWhereInput[]
    NOT?: PaymentNetworkStatusWhereInput | PaymentNetworkStatusWhereInput[]
    id?: StringFilter<"PaymentNetworkStatus"> | string
    provider?: EnumPaymentProviderFilter<"PaymentNetworkStatus"> | $Enums.PaymentProvider
    isOnline?: BoolFilter<"PaymentNetworkStatus"> | boolean
    responseTime?: IntFilter<"PaymentNetworkStatus"> | number
    lastChecked?: DateTimeFilter<"PaymentNetworkStatus"> | Date | string
    maintenanceStart?: DateTimeNullableFilter<"PaymentNetworkStatus"> | Date | string | null
    maintenanceEnd?: DateTimeNullableFilter<"PaymentNetworkStatus"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentNetworkStatus"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentNetworkStatus"> | Date | string
  }

  export type PaymentNetworkStatusOrderByWithRelationInput = {
    id?: SortOrder
    provider?: SortOrder
    isOnline?: SortOrder
    responseTime?: SortOrder
    lastChecked?: SortOrder
    maintenanceStart?: SortOrderInput | SortOrder
    maintenanceEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentNetworkStatusWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider?: $Enums.PaymentProvider
    AND?: PaymentNetworkStatusWhereInput | PaymentNetworkStatusWhereInput[]
    OR?: PaymentNetworkStatusWhereInput[]
    NOT?: PaymentNetworkStatusWhereInput | PaymentNetworkStatusWhereInput[]
    isOnline?: BoolFilter<"PaymentNetworkStatus"> | boolean
    responseTime?: IntFilter<"PaymentNetworkStatus"> | number
    lastChecked?: DateTimeFilter<"PaymentNetworkStatus"> | Date | string
    maintenanceStart?: DateTimeNullableFilter<"PaymentNetworkStatus"> | Date | string | null
    maintenanceEnd?: DateTimeNullableFilter<"PaymentNetworkStatus"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentNetworkStatus"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentNetworkStatus"> | Date | string
  }, "id" | "provider">

  export type PaymentNetworkStatusOrderByWithAggregationInput = {
    id?: SortOrder
    provider?: SortOrder
    isOnline?: SortOrder
    responseTime?: SortOrder
    lastChecked?: SortOrder
    maintenanceStart?: SortOrderInput | SortOrder
    maintenanceEnd?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentNetworkStatusCountOrderByAggregateInput
    _avg?: PaymentNetworkStatusAvgOrderByAggregateInput
    _max?: PaymentNetworkStatusMaxOrderByAggregateInput
    _min?: PaymentNetworkStatusMinOrderByAggregateInput
    _sum?: PaymentNetworkStatusSumOrderByAggregateInput
  }

  export type PaymentNetworkStatusScalarWhereWithAggregatesInput = {
    AND?: PaymentNetworkStatusScalarWhereWithAggregatesInput | PaymentNetworkStatusScalarWhereWithAggregatesInput[]
    OR?: PaymentNetworkStatusScalarWhereWithAggregatesInput[]
    NOT?: PaymentNetworkStatusScalarWhereWithAggregatesInput | PaymentNetworkStatusScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PaymentNetworkStatus"> | string
    provider?: EnumPaymentProviderWithAggregatesFilter<"PaymentNetworkStatus"> | $Enums.PaymentProvider
    isOnline?: BoolWithAggregatesFilter<"PaymentNetworkStatus"> | boolean
    responseTime?: IntWithAggregatesFilter<"PaymentNetworkStatus"> | number
    lastChecked?: DateTimeWithAggregatesFilter<"PaymentNetworkStatus"> | Date | string
    maintenanceStart?: DateTimeNullableWithAggregatesFilter<"PaymentNetworkStatus"> | Date | string | null
    maintenanceEnd?: DateTimeNullableWithAggregatesFilter<"PaymentNetworkStatus"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PaymentNetworkStatus"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PaymentNetworkStatus"> | Date | string
  }

  export type UserSessionWhereInput = {
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    refreshToken?: StringFilter<"UserSession"> | string
    deviceInfo?: JsonNullableFilter<"UserSession">
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserSessionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    refreshToken?: string
    AND?: UserSessionWhereInput | UserSessionWhereInput[]
    OR?: UserSessionWhereInput[]
    NOT?: UserSessionWhereInput | UserSessionWhereInput[]
    userId?: StringFilter<"UserSession"> | string
    deviceInfo?: JsonNullableFilter<"UserSession">
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "token" | "refreshToken">

  export type UserSessionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    deviceInfo?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSessionCountOrderByAggregateInput
    _max?: UserSessionMaxOrderByAggregateInput
    _min?: UserSessionMinOrderByAggregateInput
  }

  export type UserSessionScalarWhereWithAggregatesInput = {
    AND?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    OR?: UserSessionScalarWhereWithAggregatesInput[]
    NOT?: UserSessionScalarWhereWithAggregatesInput | UserSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSession"> | string
    userId?: StringWithAggregatesFilter<"UserSession"> | string
    token?: StringWithAggregatesFilter<"UserSession"> | string
    refreshToken?: StringWithAggregatesFilter<"UserSession"> | string
    deviceInfo?: JsonNullableWithAggregatesFilter<"UserSession">
    ipAddress?: StringNullableWithAggregatesFilter<"UserSession"> | string | null
    expiresAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSession"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    resource?: StringFilter<"AuditLog"> | string
    details?: JsonNullableFilter<"AuditLog">
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    timestamp?: DateTimeFilter<"AuditLog"> | Date | string
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    resource?: SortOrder
    details?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    resource?: StringWithAggregatesFilter<"AuditLog"> | string
    details?: JsonNullableWithAggregatesFilter<"AuditLog">
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    timestamp?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileCreateNestedOneWithoutUserInput
    linkedAccounts?: LinkedAccountCreateNestedManyWithoutUserInput
    routingRules?: RoutingRuleCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    linkedAccounts?: LinkedAccountUncheckedCreateNestedManyWithoutUserInput
    routingRules?: RoutingRuleUncheckedCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    linkedAccounts?: LinkedAccountUpdateManyWithoutUserNestedInput
    routingRules?: RoutingRuleUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    linkedAccounts?: LinkedAccountUncheckedUpdateManyWithoutUserNestedInput
    routingRules?: RoutingRuleUncheckedUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateInput = {
    id?: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    kycStatus?: $Enums.KYCStatus
    riskProfile?: $Enums.RiskProfile
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
  }

  export type UserProfileUncheckedCreateInput = {
    id?: string
    userId: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    kycStatus?: $Enums.KYCStatus
    riskProfile?: $Enums.RiskProfile
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    riskProfile?: EnumRiskProfileFieldUpdateOperationsInput | $Enums.RiskProfile
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
  }

  export type UserProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    riskProfile?: EnumRiskProfileFieldUpdateOperationsInput | $Enums.RiskProfile
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileCreateManyInput = {
    id?: string
    userId: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    kycStatus?: $Enums.KYCStatus
    riskProfile?: $Enums.RiskProfile
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    riskProfile?: EnumRiskProfileFieldUpdateOperationsInput | $Enums.RiskProfile
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    riskProfile?: EnumRiskProfileFieldUpdateOperationsInput | $Enums.RiskProfile
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedAccountCreateInput = {
    id?: string
    accountType: $Enums.AccountType
    provider: $Enums.PaymentProvider
    accountNumber: string
    accountName: string
    currency: string
    balance?: number | null
    isActive?: boolean
    isPrimary?: boolean
    priority?: number
    dailyLimit?: number | null
    monthlyLimit?: number | null
    linkedAt?: Date | string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLinkedAccountsInput
    sourceTransactions?: PaymentTransactionCreateNestedManyWithoutSourceAccountInput
    targetTransactions?: PaymentTransactionCreateNestedManyWithoutTargetAccountInput
  }

  export type LinkedAccountUncheckedCreateInput = {
    id?: string
    userId: string
    accountType: $Enums.AccountType
    provider: $Enums.PaymentProvider
    accountNumber: string
    accountName: string
    currency: string
    balance?: number | null
    isActive?: boolean
    isPrimary?: boolean
    priority?: number
    dailyLimit?: number | null
    monthlyLimit?: number | null
    linkedAt?: Date | string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutSourceAccountInput
    targetTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutTargetAccountInput
  }

  export type LinkedAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    dailyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLinkedAccountsNestedInput
    sourceTransactions?: PaymentTransactionUpdateManyWithoutSourceAccountNestedInput
    targetTransactions?: PaymentTransactionUpdateManyWithoutTargetAccountNestedInput
  }

  export type LinkedAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    dailyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceTransactions?: PaymentTransactionUncheckedUpdateManyWithoutSourceAccountNestedInput
    targetTransactions?: PaymentTransactionUncheckedUpdateManyWithoutTargetAccountNestedInput
  }

  export type LinkedAccountCreateManyInput = {
    id?: string
    userId: string
    accountType: $Enums.AccountType
    provider: $Enums.PaymentProvider
    accountNumber: string
    accountName: string
    currency: string
    balance?: number | null
    isActive?: boolean
    isPrimary?: boolean
    priority?: number
    dailyLimit?: number | null
    monthlyLimit?: number | null
    linkedAt?: Date | string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    dailyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    dailyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestCreateInput = {
    id?: string
    amount: number
    currency: string
    targetCurrency?: string | null
    merchantId?: string | null
    merchantName?: string | null
    description?: string | null
    qrCode?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentRequestsInput
    transactions?: PaymentTransactionCreateNestedManyWithoutPaymentRequestInput
  }

  export type PaymentRequestUncheckedCreateInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    targetCurrency?: string | null
    merchantId?: string | null
    merchantName?: string | null
    description?: string | null
    qrCode?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: PaymentTransactionUncheckedCreateNestedManyWithoutPaymentRequestInput
  }

  export type PaymentRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentRequestsNestedInput
    transactions?: PaymentTransactionUpdateManyWithoutPaymentRequestNestedInput
  }

  export type PaymentRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: PaymentTransactionUncheckedUpdateManyWithoutPaymentRequestNestedInput
  }

  export type PaymentRequestCreateManyInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    targetCurrency?: string | null
    merchantId?: string | null
    merchantName?: string | null
    description?: string | null
    qrCode?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionCreateInput = {
    id?: string
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    paymentRequest?: PaymentRequestCreateNestedOneWithoutTransactionsInput
    sourceAccount: LinkedAccountCreateNestedOneWithoutSourceTransactionsInput
    targetAccount?: LinkedAccountCreateNestedOneWithoutTargetTransactionsInput
    routingSteps?: RoutingStepCreateNestedManyWithoutTransactionInput
    fees?: TransactionFeeCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionUncheckedCreateInput = {
    id?: string
    userId: string
    paymentRequestId?: string | null
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    sourceAccountId: string
    targetAccountId?: string | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    routingSteps?: RoutingStepUncheckedCreateNestedManyWithoutTransactionInput
    fees?: TransactionFeeUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    paymentRequest?: PaymentRequestUpdateOneWithoutTransactionsNestedInput
    sourceAccount?: LinkedAccountUpdateOneRequiredWithoutSourceTransactionsNestedInput
    targetAccount?: LinkedAccountUpdateOneWithoutTargetTransactionsNestedInput
    routingSteps?: RoutingStepUpdateManyWithoutTransactionNestedInput
    fees?: TransactionFeeUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceAccountId?: StringFieldUpdateOperationsInput | string
    targetAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routingSteps?: RoutingStepUncheckedUpdateManyWithoutTransactionNestedInput
    fees?: TransactionFeeUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionCreateManyInput = {
    id?: string
    userId: string
    paymentRequestId?: string | null
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    sourceAccountId: string
    targetAccountId?: string | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceAccountId?: StringFieldUpdateOperationsInput | string
    targetAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingStepCreateInput = {
    id?: string
    stepNumber: number
    provider: $Enums.PaymentProvider
    action: $Enums.RoutingAction
    amount: number
    currency: string
    status?: $Enums.StepStatus
    processingTime?: number | null
    externalTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: PaymentTransactionCreateNestedOneWithoutRoutingStepsInput
    fees?: RoutingStepFeeCreateNestedManyWithoutRoutingStepInput
  }

  export type RoutingStepUncheckedCreateInput = {
    id?: string
    transactionId: string
    stepNumber: number
    provider: $Enums.PaymentProvider
    action: $Enums.RoutingAction
    amount: number
    currency: string
    status?: $Enums.StepStatus
    processingTime?: number | null
    externalTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: RoutingStepFeeUncheckedCreateNestedManyWithoutRoutingStepInput
  }

  export type RoutingStepUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    action?: EnumRoutingActionFieldUpdateOperationsInput | $Enums.RoutingAction
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: PaymentTransactionUpdateOneRequiredWithoutRoutingStepsNestedInput
    fees?: RoutingStepFeeUpdateManyWithoutRoutingStepNestedInput
  }

  export type RoutingStepUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    action?: EnumRoutingActionFieldUpdateOperationsInput | $Enums.RoutingAction
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: RoutingStepFeeUncheckedUpdateManyWithoutRoutingStepNestedInput
  }

  export type RoutingStepCreateManyInput = {
    id?: string
    transactionId: string
    stepNumber: number
    provider: $Enums.PaymentProvider
    action: $Enums.RoutingAction
    amount: number
    currency: string
    status?: $Enums.StepStatus
    processingTime?: number | null
    externalTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoutingStepUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    action?: EnumRoutingActionFieldUpdateOperationsInput | $Enums.RoutingAction
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingStepUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    action?: EnumRoutingActionFieldUpdateOperationsInput | $Enums.RoutingAction
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFeeCreateInput = {
    id?: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
    transaction: PaymentTransactionCreateNestedOneWithoutFeesInput
  }

  export type TransactionFeeUncheckedCreateInput = {
    id?: string
    transactionId: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
  }

  export type TransactionFeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: PaymentTransactionUpdateOneRequiredWithoutFeesNestedInput
  }

  export type TransactionFeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFeeCreateManyInput = {
    id?: string
    transactionId: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
  }

  export type TransactionFeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingStepFeeCreateInput = {
    id?: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
    routingStep: RoutingStepCreateNestedOneWithoutFeesInput
  }

  export type RoutingStepFeeUncheckedCreateInput = {
    id?: string
    routingStepId: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
  }

  export type RoutingStepFeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routingStep?: RoutingStepUpdateOneRequiredWithoutFeesNestedInput
  }

  export type RoutingStepFeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routingStepId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingStepFeeCreateManyInput = {
    id?: string
    routingStepId: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
  }

  export type RoutingStepFeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingStepFeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    routingStepId?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingRuleCreateInput = {
    id?: string
    name: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutRoutingRulesInput
  }

  export type RoutingRuleUncheckedCreateInput = {
    id?: string
    userId: string
    name: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoutingRuleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutRoutingRulesNestedInput
  }

  export type RoutingRuleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingRuleCreateManyInput = {
    id?: string
    userId: string
    name: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoutingRuleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingRuleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateCreateInput = {
    id?: string
    fromCurrency: string
    toCurrency: string
    rate: number
    provider: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ExchangeRateUncheckedCreateInput = {
    id?: string
    fromCurrency: string
    toCurrency: string
    rate: number
    provider: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ExchangeRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateCreateManyInput = {
    id?: string
    fromCurrency: string
    toCurrency: string
    rate: number
    provider: string
    timestamp?: Date | string
    createdAt?: Date | string
  }

  export type ExchangeRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExchangeRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fromCurrency?: StringFieldUpdateOperationsInput | string
    toCurrency?: StringFieldUpdateOperationsInput | string
    rate?: FloatFieldUpdateOperationsInput | number
    provider?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentNetworkStatusCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    isOnline?: boolean
    responseTime?: number
    lastChecked?: Date | string
    maintenanceStart?: Date | string | null
    maintenanceEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentNetworkStatusUncheckedCreateInput = {
    id?: string
    provider: $Enums.PaymentProvider
    isOnline?: boolean
    responseTime?: number
    lastChecked?: Date | string
    maintenanceStart?: Date | string | null
    maintenanceEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentNetworkStatusUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentNetworkStatusUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentNetworkStatusCreateManyInput = {
    id?: string
    provider: $Enums.PaymentProvider
    isOnline?: boolean
    responseTime?: number
    lastChecked?: Date | string
    maintenanceStart?: Date | string | null
    maintenanceEnd?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentNetworkStatusUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentNetworkStatusUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    responseTime?: IntFieldUpdateOperationsInput | number
    lastChecked?: DateTimeFieldUpdateOperationsInput | Date | string
    maintenanceStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    maintenanceEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateInput = {
    id?: string
    token: string
    refreshToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type UserSessionUncheckedCreateInput = {
    id?: string
    userId: string
    token: string
    refreshToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type UserSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionCreateManyInput = {
    id?: string
    userId: string
    token: string
    refreshToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    resource: string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    timestamp?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    resource?: StringFieldUpdateOperationsInput | string
    details?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserProfileNullableRelationFilter = {
    is?: UserProfileWhereInput | null
    isNot?: UserProfileWhereInput | null
  }

  export type LinkedAccountListRelationFilter = {
    every?: LinkedAccountWhereInput
    some?: LinkedAccountWhereInput
    none?: LinkedAccountWhereInput
  }

  export type RoutingRuleListRelationFilter = {
    every?: RoutingRuleWhereInput
    some?: RoutingRuleWhereInput
    none?: RoutingRuleWhereInput
  }

  export type PaymentRequestListRelationFilter = {
    every?: PaymentRequestWhereInput
    some?: PaymentRequestWhereInput
    none?: PaymentRequestWhereInput
  }

  export type PaymentTransactionListRelationFilter = {
    every?: PaymentTransactionWhereInput
    some?: PaymentTransactionWhereInput
    none?: PaymentTransactionWhereInput
  }

  export type UserSessionListRelationFilter = {
    every?: UserSessionWhereInput
    some?: UserSessionWhereInput
    none?: UserSessionWhereInput
  }

  export type LinkedAccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoutingRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    countryCode?: SortOrder
    preferredCurrency?: SortOrder
    passwordHash?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    countryCode?: SortOrder
    preferredCurrency?: SortOrder
    passwordHash?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phoneNumber?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    countryCode?: SortOrder
    preferredCurrency?: SortOrder
    passwordHash?: SortOrder
    isEmailVerified?: SortOrder
    isPhoneVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type EnumRiskProfileFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskProfile | EnumRiskProfileFieldRefInput<$PrismaModel>
    in?: $Enums.RiskProfile[] | ListEnumRiskProfileFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskProfile[] | ListEnumRiskProfileFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskProfileFilter<$PrismaModel> | $Enums.RiskProfile
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UserProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avatarUrl?: SortOrder
    dateOfBirth?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    kycStatus?: SortOrder
    riskProfile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avatarUrl?: SortOrder
    dateOfBirth?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    kycStatus?: SortOrder
    riskProfile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    avatarUrl?: SortOrder
    dateOfBirth?: SortOrder
    street?: SortOrder
    city?: SortOrder
    state?: SortOrder
    postalCode?: SortOrder
    country?: SortOrder
    kycStatus?: SortOrder
    riskProfile?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type EnumRiskProfileWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskProfile | EnumRiskProfileFieldRefInput<$PrismaModel>
    in?: $Enums.RiskProfile[] | ListEnumRiskProfileFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskProfile[] | ListEnumRiskProfileFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskProfileWithAggregatesFilter<$PrismaModel> | $Enums.RiskProfile
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskProfileFilter<$PrismaModel>
    _max?: NestedEnumRiskProfileFilter<$PrismaModel>
  }

  export type EnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type EnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type LinkedAccountUserIdProviderAccountNumberCompoundUniqueInput = {
    userId: string
    provider: $Enums.PaymentProvider
    accountNumber: string
  }

  export type LinkedAccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    provider?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    currency?: SortOrder
    balance?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    priority?: SortOrder
    dailyLimit?: SortOrder
    monthlyLimit?: SortOrder
    linkedAt?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkedAccountAvgOrderByAggregateInput = {
    balance?: SortOrder
    priority?: SortOrder
    dailyLimit?: SortOrder
    monthlyLimit?: SortOrder
  }

  export type LinkedAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    provider?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    currency?: SortOrder
    balance?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    priority?: SortOrder
    dailyLimit?: SortOrder
    monthlyLimit?: SortOrder
    linkedAt?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkedAccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    accountType?: SortOrder
    provider?: SortOrder
    accountNumber?: SortOrder
    accountName?: SortOrder
    currency?: SortOrder
    balance?: SortOrder
    isActive?: SortOrder
    isPrimary?: SortOrder
    priority?: SortOrder
    dailyLimit?: SortOrder
    monthlyLimit?: SortOrder
    linkedAt?: SortOrder
    lastSyncAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LinkedAccountSumOrderByAggregateInput = {
    balance?: SortOrder
    priority?: SortOrder
    dailyLimit?: SortOrder
    monthlyLimit?: SortOrder
  }

  export type EnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type EnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type PaymentRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    targetCurrency?: SortOrder
    merchantId?: SortOrder
    merchantName?: SortOrder
    description?: SortOrder
    qrCode?: SortOrder
    metadata?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRequestAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    targetCurrency?: SortOrder
    merchantId?: SortOrder
    merchantName?: SortOrder
    description?: SortOrder
    qrCode?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    targetCurrency?: SortOrder
    merchantId?: SortOrder
    merchantName?: SortOrder
    description?: SortOrder
    qrCode?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentRequestSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type PaymentRequestNullableRelationFilter = {
    is?: PaymentRequestWhereInput | null
    isNot?: PaymentRequestWhereInput | null
  }

  export type LinkedAccountRelationFilter = {
    is?: LinkedAccountWhereInput
    isNot?: LinkedAccountWhereInput
  }

  export type LinkedAccountNullableRelationFilter = {
    is?: LinkedAccountWhereInput | null
    isNot?: LinkedAccountWhereInput | null
  }

  export type RoutingStepListRelationFilter = {
    every?: RoutingStepWhereInput
    some?: RoutingStepWhereInput
    none?: RoutingStepWhereInput
  }

  export type TransactionFeeListRelationFilter = {
    every?: TransactionFeeWhereInput
    some?: TransactionFeeWhereInput
    none?: TransactionFeeWhereInput
  }

  export type RoutingStepOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionFeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentRequestId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    targetAmount?: SortOrder
    targetCurrency?: SortOrder
    exchangeRate?: SortOrder
    sourceAccountId?: SortOrder
    targetAccountId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    merchantName?: SortOrder
    merchantCategory?: SortOrder
    merchantLocation?: SortOrder
    metadata?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    failedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    targetAmount?: SortOrder
    exchangeRate?: SortOrder
  }

  export type PaymentTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentRequestId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    targetAmount?: SortOrder
    targetCurrency?: SortOrder
    exchangeRate?: SortOrder
    sourceAccountId?: SortOrder
    targetAccountId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    merchantName?: SortOrder
    merchantCategory?: SortOrder
    merchantLocation?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    failedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    paymentRequestId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    targetAmount?: SortOrder
    targetCurrency?: SortOrder
    exchangeRate?: SortOrder
    sourceAccountId?: SortOrder
    targetAccountId?: SortOrder
    status?: SortOrder
    failureReason?: SortOrder
    merchantName?: SortOrder
    merchantCategory?: SortOrder
    merchantLocation?: SortOrder
    initiatedAt?: SortOrder
    completedAt?: SortOrder
    failedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    targetAmount?: SortOrder
    exchangeRate?: SortOrder
  }

  export type EnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type EnumRoutingActionFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutingAction | EnumRoutingActionFieldRefInput<$PrismaModel>
    in?: $Enums.RoutingAction[] | ListEnumRoutingActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutingAction[] | ListEnumRoutingActionFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutingActionFilter<$PrismaModel> | $Enums.RoutingAction
  }

  export type EnumStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusFilter<$PrismaModel> | $Enums.StepStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type PaymentTransactionRelationFilter = {
    is?: PaymentTransactionWhereInput
    isNot?: PaymentTransactionWhereInput
  }

  export type RoutingStepFeeListRelationFilter = {
    every?: RoutingStepFeeWhereInput
    some?: RoutingStepFeeWhereInput
    none?: RoutingStepFeeWhereInput
  }

  export type RoutingStepFeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoutingStepTransactionIdStepNumberCompoundUniqueInput = {
    transactionId: string
    stepNumber: number
  }

  export type RoutingStepCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    stepNumber?: SortOrder
    provider?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    processingTime?: SortOrder
    externalTransactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoutingStepAvgOrderByAggregateInput = {
    stepNumber?: SortOrder
    amount?: SortOrder
    processingTime?: SortOrder
  }

  export type RoutingStepMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    stepNumber?: SortOrder
    provider?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    processingTime?: SortOrder
    externalTransactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoutingStepMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    stepNumber?: SortOrder
    provider?: SortOrder
    action?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    processingTime?: SortOrder
    externalTransactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoutingStepSumOrderByAggregateInput = {
    stepNumber?: SortOrder
    amount?: SortOrder
    processingTime?: SortOrder
  }

  export type EnumRoutingActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutingAction | EnumRoutingActionFieldRefInput<$PrismaModel>
    in?: $Enums.RoutingAction[] | ListEnumRoutingActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutingAction[] | ListEnumRoutingActionFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutingActionWithAggregatesFilter<$PrismaModel> | $Enums.RoutingAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoutingActionFilter<$PrismaModel>
    _max?: NestedEnumRoutingActionFilter<$PrismaModel>
  }

  export type EnumStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.StepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepStatusFilter<$PrismaModel>
    _max?: NestedEnumStepStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumFeeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeTypeFilter<$PrismaModel> | $Enums.FeeType
  }

  export type TransactionFeeCountOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionFeeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type TransactionFeeMaxOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionFeeMinOrderByAggregateInput = {
    id?: SortOrder
    transactionId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type TransactionFeeSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumFeeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeeTypeFilter<$PrismaModel>
    _max?: NestedEnumFeeTypeFilter<$PrismaModel>
  }

  export type RoutingStepRelationFilter = {
    is?: RoutingStepWhereInput
    isNot?: RoutingStepWhereInput
  }

  export type RoutingStepFeeCountOrderByAggregateInput = {
    id?: SortOrder
    routingStepId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoutingStepFeeAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type RoutingStepFeeMaxOrderByAggregateInput = {
    id?: SortOrder
    routingStepId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoutingStepFeeMinOrderByAggregateInput = {
    id?: SortOrder
    routingStepId?: SortOrder
    type?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
  }

  export type RoutingStepFeeSumOrderByAggregateInput = {
    amount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RoutingRuleCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    conditions?: SortOrder
    actions?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoutingRuleAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type RoutingRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoutingRuleMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RoutingRuleSumOrderByAggregateInput = {
    priority?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type ExchangeRateFromCurrencyToCurrencyProviderTimestampCompoundUniqueInput = {
    fromCurrency: string
    toCurrency: string
    provider: string
    timestamp: Date | string
  }

  export type ExchangeRateCountOrderByAggregateInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    provider?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ExchangeRateAvgOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type ExchangeRateMaxOrderByAggregateInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    provider?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ExchangeRateMinOrderByAggregateInput = {
    id?: SortOrder
    fromCurrency?: SortOrder
    toCurrency?: SortOrder
    rate?: SortOrder
    provider?: SortOrder
    timestamp?: SortOrder
    createdAt?: SortOrder
  }

  export type ExchangeRateSumOrderByAggregateInput = {
    rate?: SortOrder
  }

  export type PaymentNetworkStatusCountOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    isOnline?: SortOrder
    responseTime?: SortOrder
    lastChecked?: SortOrder
    maintenanceStart?: SortOrder
    maintenanceEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentNetworkStatusAvgOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type PaymentNetworkStatusMaxOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    isOnline?: SortOrder
    responseTime?: SortOrder
    lastChecked?: SortOrder
    maintenanceStart?: SortOrder
    maintenanceEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentNetworkStatusMinOrderByAggregateInput = {
    id?: SortOrder
    provider?: SortOrder
    isOnline?: SortOrder
    responseTime?: SortOrder
    lastChecked?: SortOrder
    maintenanceStart?: SortOrder
    maintenanceEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentNetworkStatusSumOrderByAggregateInput = {
    responseTime?: SortOrder
  }

  export type UserSessionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    deviceInfo?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSessionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    token?: SortOrder
    refreshToken?: SortOrder
    ipAddress?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    details?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    resource?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    timestamp?: SortOrder
  }

  export type UserProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type LinkedAccountCreateNestedManyWithoutUserInput = {
    create?: XOR<LinkedAccountCreateWithoutUserInput, LinkedAccountUncheckedCreateWithoutUserInput> | LinkedAccountCreateWithoutUserInput[] | LinkedAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkedAccountCreateOrConnectWithoutUserInput | LinkedAccountCreateOrConnectWithoutUserInput[]
    createMany?: LinkedAccountCreateManyUserInputEnvelope
    connect?: LinkedAccountWhereUniqueInput | LinkedAccountWhereUniqueInput[]
  }

  export type RoutingRuleCreateNestedManyWithoutUserInput = {
    create?: XOR<RoutingRuleCreateWithoutUserInput, RoutingRuleUncheckedCreateWithoutUserInput> | RoutingRuleCreateWithoutUserInput[] | RoutingRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoutingRuleCreateOrConnectWithoutUserInput | RoutingRuleCreateOrConnectWithoutUserInput[]
    createMany?: RoutingRuleCreateManyUserInputEnvelope
    connect?: RoutingRuleWhereUniqueInput | RoutingRuleWhereUniqueInput[]
  }

  export type PaymentRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentRequestCreateWithoutUserInput, PaymentRequestUncheckedCreateWithoutUserInput> | PaymentRequestCreateWithoutUserInput[] | PaymentRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutUserInput | PaymentRequestCreateOrConnectWithoutUserInput[]
    createMany?: PaymentRequestCreateManyUserInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type PaymentTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentTransactionCreateWithoutUserInput, PaymentTransactionUncheckedCreateWithoutUserInput> | PaymentTransactionCreateWithoutUserInput[] | PaymentTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutUserInput | PaymentTransactionCreateOrConnectWithoutUserInput[]
    createMany?: PaymentTransactionCreateManyUserInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type UserSessionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type UserProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    connect?: UserProfileWhereUniqueInput
  }

  export type LinkedAccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LinkedAccountCreateWithoutUserInput, LinkedAccountUncheckedCreateWithoutUserInput> | LinkedAccountCreateWithoutUserInput[] | LinkedAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkedAccountCreateOrConnectWithoutUserInput | LinkedAccountCreateOrConnectWithoutUserInput[]
    createMany?: LinkedAccountCreateManyUserInputEnvelope
    connect?: LinkedAccountWhereUniqueInput | LinkedAccountWhereUniqueInput[]
  }

  export type RoutingRuleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<RoutingRuleCreateWithoutUserInput, RoutingRuleUncheckedCreateWithoutUserInput> | RoutingRuleCreateWithoutUserInput[] | RoutingRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoutingRuleCreateOrConnectWithoutUserInput | RoutingRuleCreateOrConnectWithoutUserInput[]
    createMany?: RoutingRuleCreateManyUserInputEnvelope
    connect?: RoutingRuleWhereUniqueInput | RoutingRuleWhereUniqueInput[]
  }

  export type PaymentRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentRequestCreateWithoutUserInput, PaymentRequestUncheckedCreateWithoutUserInput> | PaymentRequestCreateWithoutUserInput[] | PaymentRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutUserInput | PaymentRequestCreateOrConnectWithoutUserInput[]
    createMany?: PaymentRequestCreateManyUserInputEnvelope
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
  }

  export type PaymentTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PaymentTransactionCreateWithoutUserInput, PaymentTransactionUncheckedCreateWithoutUserInput> | PaymentTransactionCreateWithoutUserInput[] | PaymentTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutUserInput | PaymentTransactionCreateOrConnectWithoutUserInput[]
    createMany?: PaymentTransactionCreateManyUserInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type UserSessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type LinkedAccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<LinkedAccountCreateWithoutUserInput, LinkedAccountUncheckedCreateWithoutUserInput> | LinkedAccountCreateWithoutUserInput[] | LinkedAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkedAccountCreateOrConnectWithoutUserInput | LinkedAccountCreateOrConnectWithoutUserInput[]
    upsert?: LinkedAccountUpsertWithWhereUniqueWithoutUserInput | LinkedAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LinkedAccountCreateManyUserInputEnvelope
    set?: LinkedAccountWhereUniqueInput | LinkedAccountWhereUniqueInput[]
    disconnect?: LinkedAccountWhereUniqueInput | LinkedAccountWhereUniqueInput[]
    delete?: LinkedAccountWhereUniqueInput | LinkedAccountWhereUniqueInput[]
    connect?: LinkedAccountWhereUniqueInput | LinkedAccountWhereUniqueInput[]
    update?: LinkedAccountUpdateWithWhereUniqueWithoutUserInput | LinkedAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LinkedAccountUpdateManyWithWhereWithoutUserInput | LinkedAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LinkedAccountScalarWhereInput | LinkedAccountScalarWhereInput[]
  }

  export type RoutingRuleUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoutingRuleCreateWithoutUserInput, RoutingRuleUncheckedCreateWithoutUserInput> | RoutingRuleCreateWithoutUserInput[] | RoutingRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoutingRuleCreateOrConnectWithoutUserInput | RoutingRuleCreateOrConnectWithoutUserInput[]
    upsert?: RoutingRuleUpsertWithWhereUniqueWithoutUserInput | RoutingRuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoutingRuleCreateManyUserInputEnvelope
    set?: RoutingRuleWhereUniqueInput | RoutingRuleWhereUniqueInput[]
    disconnect?: RoutingRuleWhereUniqueInput | RoutingRuleWhereUniqueInput[]
    delete?: RoutingRuleWhereUniqueInput | RoutingRuleWhereUniqueInput[]
    connect?: RoutingRuleWhereUniqueInput | RoutingRuleWhereUniqueInput[]
    update?: RoutingRuleUpdateWithWhereUniqueWithoutUserInput | RoutingRuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoutingRuleUpdateManyWithWhereWithoutUserInput | RoutingRuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoutingRuleScalarWhereInput | RoutingRuleScalarWhereInput[]
  }

  export type PaymentRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutUserInput, PaymentRequestUncheckedCreateWithoutUserInput> | PaymentRequestCreateWithoutUserInput[] | PaymentRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutUserInput | PaymentRequestCreateOrConnectWithoutUserInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutUserInput | PaymentRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentRequestCreateManyUserInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutUserInput | PaymentRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutUserInput | PaymentRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type PaymentTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutUserInput, PaymentTransactionUncheckedCreateWithoutUserInput> | PaymentTransactionCreateWithoutUserInput[] | PaymentTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutUserInput | PaymentTransactionCreateOrConnectWithoutUserInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutUserInput | PaymentTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentTransactionCreateManyUserInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutUserInput | PaymentTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutUserInput | PaymentTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type UserSessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserProfileCreateOrConnectWithoutUserInput
    upsert?: UserProfileUpsertWithoutUserInput
    disconnect?: UserProfileWhereInput | boolean
    delete?: UserProfileWhereInput | boolean
    connect?: UserProfileWhereUniqueInput
    update?: XOR<XOR<UserProfileUpdateToOneWithWhereWithoutUserInput, UserProfileUpdateWithoutUserInput>, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type LinkedAccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LinkedAccountCreateWithoutUserInput, LinkedAccountUncheckedCreateWithoutUserInput> | LinkedAccountCreateWithoutUserInput[] | LinkedAccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LinkedAccountCreateOrConnectWithoutUserInput | LinkedAccountCreateOrConnectWithoutUserInput[]
    upsert?: LinkedAccountUpsertWithWhereUniqueWithoutUserInput | LinkedAccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LinkedAccountCreateManyUserInputEnvelope
    set?: LinkedAccountWhereUniqueInput | LinkedAccountWhereUniqueInput[]
    disconnect?: LinkedAccountWhereUniqueInput | LinkedAccountWhereUniqueInput[]
    delete?: LinkedAccountWhereUniqueInput | LinkedAccountWhereUniqueInput[]
    connect?: LinkedAccountWhereUniqueInput | LinkedAccountWhereUniqueInput[]
    update?: LinkedAccountUpdateWithWhereUniqueWithoutUserInput | LinkedAccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LinkedAccountUpdateManyWithWhereWithoutUserInput | LinkedAccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LinkedAccountScalarWhereInput | LinkedAccountScalarWhereInput[]
  }

  export type RoutingRuleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<RoutingRuleCreateWithoutUserInput, RoutingRuleUncheckedCreateWithoutUserInput> | RoutingRuleCreateWithoutUserInput[] | RoutingRuleUncheckedCreateWithoutUserInput[]
    connectOrCreate?: RoutingRuleCreateOrConnectWithoutUserInput | RoutingRuleCreateOrConnectWithoutUserInput[]
    upsert?: RoutingRuleUpsertWithWhereUniqueWithoutUserInput | RoutingRuleUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: RoutingRuleCreateManyUserInputEnvelope
    set?: RoutingRuleWhereUniqueInput | RoutingRuleWhereUniqueInput[]
    disconnect?: RoutingRuleWhereUniqueInput | RoutingRuleWhereUniqueInput[]
    delete?: RoutingRuleWhereUniqueInput | RoutingRuleWhereUniqueInput[]
    connect?: RoutingRuleWhereUniqueInput | RoutingRuleWhereUniqueInput[]
    update?: RoutingRuleUpdateWithWhereUniqueWithoutUserInput | RoutingRuleUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: RoutingRuleUpdateManyWithWhereWithoutUserInput | RoutingRuleUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: RoutingRuleScalarWhereInput | RoutingRuleScalarWhereInput[]
  }

  export type PaymentRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutUserInput, PaymentRequestUncheckedCreateWithoutUserInput> | PaymentRequestCreateWithoutUserInput[] | PaymentRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutUserInput | PaymentRequestCreateOrConnectWithoutUserInput[]
    upsert?: PaymentRequestUpsertWithWhereUniqueWithoutUserInput | PaymentRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentRequestCreateManyUserInputEnvelope
    set?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    disconnect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    delete?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    connect?: PaymentRequestWhereUniqueInput | PaymentRequestWhereUniqueInput[]
    update?: PaymentRequestUpdateWithWhereUniqueWithoutUserInput | PaymentRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentRequestUpdateManyWithWhereWithoutUserInput | PaymentRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutUserInput, PaymentTransactionUncheckedCreateWithoutUserInput> | PaymentTransactionCreateWithoutUserInput[] | PaymentTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutUserInput | PaymentTransactionCreateOrConnectWithoutUserInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutUserInput | PaymentTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PaymentTransactionCreateManyUserInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutUserInput | PaymentTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutUserInput | PaymentTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type UserSessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput> | UserSessionCreateWithoutUserInput[] | UserSessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserSessionCreateOrConnectWithoutUserInput | UserSessionCreateOrConnectWithoutUserInput[]
    upsert?: UserSessionUpsertWithWhereUniqueWithoutUserInput | UserSessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserSessionCreateManyUserInputEnvelope
    set?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    disconnect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    delete?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    connect?: UserSessionWhereUniqueInput | UserSessionWhereUniqueInput[]
    update?: UserSessionUpdateWithWhereUniqueWithoutUserInput | UserSessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserSessionUpdateManyWithWhereWithoutUserInput | UserSessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumKYCStatusFieldUpdateOperationsInput = {
    set?: $Enums.KYCStatus
  }

  export type EnumRiskProfileFieldUpdateOperationsInput = {
    set?: $Enums.RiskProfile
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserCreateNestedOneWithoutLinkedAccountsInput = {
    create?: XOR<UserCreateWithoutLinkedAccountsInput, UserUncheckedCreateWithoutLinkedAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinkedAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentTransactionCreateNestedManyWithoutSourceAccountInput = {
    create?: XOR<PaymentTransactionCreateWithoutSourceAccountInput, PaymentTransactionUncheckedCreateWithoutSourceAccountInput> | PaymentTransactionCreateWithoutSourceAccountInput[] | PaymentTransactionUncheckedCreateWithoutSourceAccountInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutSourceAccountInput | PaymentTransactionCreateOrConnectWithoutSourceAccountInput[]
    createMany?: PaymentTransactionCreateManySourceAccountInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type PaymentTransactionCreateNestedManyWithoutTargetAccountInput = {
    create?: XOR<PaymentTransactionCreateWithoutTargetAccountInput, PaymentTransactionUncheckedCreateWithoutTargetAccountInput> | PaymentTransactionCreateWithoutTargetAccountInput[] | PaymentTransactionUncheckedCreateWithoutTargetAccountInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutTargetAccountInput | PaymentTransactionCreateOrConnectWithoutTargetAccountInput[]
    createMany?: PaymentTransactionCreateManyTargetAccountInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type PaymentTransactionUncheckedCreateNestedManyWithoutSourceAccountInput = {
    create?: XOR<PaymentTransactionCreateWithoutSourceAccountInput, PaymentTransactionUncheckedCreateWithoutSourceAccountInput> | PaymentTransactionCreateWithoutSourceAccountInput[] | PaymentTransactionUncheckedCreateWithoutSourceAccountInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutSourceAccountInput | PaymentTransactionCreateOrConnectWithoutSourceAccountInput[]
    createMany?: PaymentTransactionCreateManySourceAccountInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type PaymentTransactionUncheckedCreateNestedManyWithoutTargetAccountInput = {
    create?: XOR<PaymentTransactionCreateWithoutTargetAccountInput, PaymentTransactionUncheckedCreateWithoutTargetAccountInput> | PaymentTransactionCreateWithoutTargetAccountInput[] | PaymentTransactionUncheckedCreateWithoutTargetAccountInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutTargetAccountInput | PaymentTransactionCreateOrConnectWithoutTargetAccountInput[]
    createMany?: PaymentTransactionCreateManyTargetAccountInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type EnumAccountTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccountType
  }

  export type EnumPaymentProviderFieldUpdateOperationsInput = {
    set?: $Enums.PaymentProvider
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutLinkedAccountsNestedInput = {
    create?: XOR<UserCreateWithoutLinkedAccountsInput, UserUncheckedCreateWithoutLinkedAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutLinkedAccountsInput
    upsert?: UserUpsertWithoutLinkedAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLinkedAccountsInput, UserUpdateWithoutLinkedAccountsInput>, UserUncheckedUpdateWithoutLinkedAccountsInput>
  }

  export type PaymentTransactionUpdateManyWithoutSourceAccountNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutSourceAccountInput, PaymentTransactionUncheckedCreateWithoutSourceAccountInput> | PaymentTransactionCreateWithoutSourceAccountInput[] | PaymentTransactionUncheckedCreateWithoutSourceAccountInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutSourceAccountInput | PaymentTransactionCreateOrConnectWithoutSourceAccountInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutSourceAccountInput | PaymentTransactionUpsertWithWhereUniqueWithoutSourceAccountInput[]
    createMany?: PaymentTransactionCreateManySourceAccountInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutSourceAccountInput | PaymentTransactionUpdateWithWhereUniqueWithoutSourceAccountInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutSourceAccountInput | PaymentTransactionUpdateManyWithWhereWithoutSourceAccountInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type PaymentTransactionUpdateManyWithoutTargetAccountNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutTargetAccountInput, PaymentTransactionUncheckedCreateWithoutTargetAccountInput> | PaymentTransactionCreateWithoutTargetAccountInput[] | PaymentTransactionUncheckedCreateWithoutTargetAccountInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutTargetAccountInput | PaymentTransactionCreateOrConnectWithoutTargetAccountInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutTargetAccountInput | PaymentTransactionUpsertWithWhereUniqueWithoutTargetAccountInput[]
    createMany?: PaymentTransactionCreateManyTargetAccountInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutTargetAccountInput | PaymentTransactionUpdateWithWhereUniqueWithoutTargetAccountInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutTargetAccountInput | PaymentTransactionUpdateManyWithWhereWithoutTargetAccountInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutSourceAccountNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutSourceAccountInput, PaymentTransactionUncheckedCreateWithoutSourceAccountInput> | PaymentTransactionCreateWithoutSourceAccountInput[] | PaymentTransactionUncheckedCreateWithoutSourceAccountInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutSourceAccountInput | PaymentTransactionCreateOrConnectWithoutSourceAccountInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutSourceAccountInput | PaymentTransactionUpsertWithWhereUniqueWithoutSourceAccountInput[]
    createMany?: PaymentTransactionCreateManySourceAccountInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutSourceAccountInput | PaymentTransactionUpdateWithWhereUniqueWithoutSourceAccountInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutSourceAccountInput | PaymentTransactionUpdateManyWithWhereWithoutSourceAccountInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutTargetAccountNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutTargetAccountInput, PaymentTransactionUncheckedCreateWithoutTargetAccountInput> | PaymentTransactionCreateWithoutTargetAccountInput[] | PaymentTransactionUncheckedCreateWithoutTargetAccountInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutTargetAccountInput | PaymentTransactionCreateOrConnectWithoutTargetAccountInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutTargetAccountInput | PaymentTransactionUpsertWithWhereUniqueWithoutTargetAccountInput[]
    createMany?: PaymentTransactionCreateManyTargetAccountInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutTargetAccountInput | PaymentTransactionUpdateWithWhereUniqueWithoutTargetAccountInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutTargetAccountInput | PaymentTransactionUpdateManyWithWhereWithoutTargetAccountInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPaymentRequestsInput = {
    create?: XOR<UserCreateWithoutPaymentRequestsInput, UserUncheckedCreateWithoutPaymentRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentTransactionCreateNestedManyWithoutPaymentRequestInput = {
    create?: XOR<PaymentTransactionCreateWithoutPaymentRequestInput, PaymentTransactionUncheckedCreateWithoutPaymentRequestInput> | PaymentTransactionCreateWithoutPaymentRequestInput[] | PaymentTransactionUncheckedCreateWithoutPaymentRequestInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutPaymentRequestInput | PaymentTransactionCreateOrConnectWithoutPaymentRequestInput[]
    createMany?: PaymentTransactionCreateManyPaymentRequestInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type PaymentTransactionUncheckedCreateNestedManyWithoutPaymentRequestInput = {
    create?: XOR<PaymentTransactionCreateWithoutPaymentRequestInput, PaymentTransactionUncheckedCreateWithoutPaymentRequestInput> | PaymentTransactionCreateWithoutPaymentRequestInput[] | PaymentTransactionUncheckedCreateWithoutPaymentRequestInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutPaymentRequestInput | PaymentTransactionCreateOrConnectWithoutPaymentRequestInput[]
    createMany?: PaymentTransactionCreateManyPaymentRequestInputEnvelope
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutPaymentRequestsNestedInput = {
    create?: XOR<UserCreateWithoutPaymentRequestsInput, UserUncheckedCreateWithoutPaymentRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPaymentRequestsInput
    upsert?: UserUpsertWithoutPaymentRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPaymentRequestsInput, UserUpdateWithoutPaymentRequestsInput>, UserUncheckedUpdateWithoutPaymentRequestsInput>
  }

  export type PaymentTransactionUpdateManyWithoutPaymentRequestNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutPaymentRequestInput, PaymentTransactionUncheckedCreateWithoutPaymentRequestInput> | PaymentTransactionCreateWithoutPaymentRequestInput[] | PaymentTransactionUncheckedCreateWithoutPaymentRequestInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutPaymentRequestInput | PaymentTransactionCreateOrConnectWithoutPaymentRequestInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutPaymentRequestInput | PaymentTransactionUpsertWithWhereUniqueWithoutPaymentRequestInput[]
    createMany?: PaymentTransactionCreateManyPaymentRequestInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutPaymentRequestInput | PaymentTransactionUpdateWithWhereUniqueWithoutPaymentRequestInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutPaymentRequestInput | PaymentTransactionUpdateManyWithWhereWithoutPaymentRequestInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutPaymentRequestNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutPaymentRequestInput, PaymentTransactionUncheckedCreateWithoutPaymentRequestInput> | PaymentTransactionCreateWithoutPaymentRequestInput[] | PaymentTransactionUncheckedCreateWithoutPaymentRequestInput[]
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutPaymentRequestInput | PaymentTransactionCreateOrConnectWithoutPaymentRequestInput[]
    upsert?: PaymentTransactionUpsertWithWhereUniqueWithoutPaymentRequestInput | PaymentTransactionUpsertWithWhereUniqueWithoutPaymentRequestInput[]
    createMany?: PaymentTransactionCreateManyPaymentRequestInputEnvelope
    set?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    disconnect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    delete?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    connect?: PaymentTransactionWhereUniqueInput | PaymentTransactionWhereUniqueInput[]
    update?: PaymentTransactionUpdateWithWhereUniqueWithoutPaymentRequestInput | PaymentTransactionUpdateWithWhereUniqueWithoutPaymentRequestInput[]
    updateMany?: PaymentTransactionUpdateManyWithWhereWithoutPaymentRequestInput | PaymentTransactionUpdateManyWithWhereWithoutPaymentRequestInput[]
    deleteMany?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentRequestCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<PaymentRequestCreateWithoutTransactionsInput, PaymentRequestUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutTransactionsInput
    connect?: PaymentRequestWhereUniqueInput
  }

  export type LinkedAccountCreateNestedOneWithoutSourceTransactionsInput = {
    create?: XOR<LinkedAccountCreateWithoutSourceTransactionsInput, LinkedAccountUncheckedCreateWithoutSourceTransactionsInput>
    connectOrCreate?: LinkedAccountCreateOrConnectWithoutSourceTransactionsInput
    connect?: LinkedAccountWhereUniqueInput
  }

  export type LinkedAccountCreateNestedOneWithoutTargetTransactionsInput = {
    create?: XOR<LinkedAccountCreateWithoutTargetTransactionsInput, LinkedAccountUncheckedCreateWithoutTargetTransactionsInput>
    connectOrCreate?: LinkedAccountCreateOrConnectWithoutTargetTransactionsInput
    connect?: LinkedAccountWhereUniqueInput
  }

  export type RoutingStepCreateNestedManyWithoutTransactionInput = {
    create?: XOR<RoutingStepCreateWithoutTransactionInput, RoutingStepUncheckedCreateWithoutTransactionInput> | RoutingStepCreateWithoutTransactionInput[] | RoutingStepUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RoutingStepCreateOrConnectWithoutTransactionInput | RoutingStepCreateOrConnectWithoutTransactionInput[]
    createMany?: RoutingStepCreateManyTransactionInputEnvelope
    connect?: RoutingStepWhereUniqueInput | RoutingStepWhereUniqueInput[]
  }

  export type TransactionFeeCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput> | TransactionFeeCreateWithoutTransactionInput[] | TransactionFeeUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionFeeCreateOrConnectWithoutTransactionInput | TransactionFeeCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionFeeCreateManyTransactionInputEnvelope
    connect?: TransactionFeeWhereUniqueInput | TransactionFeeWhereUniqueInput[]
  }

  export type RoutingStepUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<RoutingStepCreateWithoutTransactionInput, RoutingStepUncheckedCreateWithoutTransactionInput> | RoutingStepCreateWithoutTransactionInput[] | RoutingStepUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RoutingStepCreateOrConnectWithoutTransactionInput | RoutingStepCreateOrConnectWithoutTransactionInput[]
    createMany?: RoutingStepCreateManyTransactionInputEnvelope
    connect?: RoutingStepWhereUniqueInput | RoutingStepWhereUniqueInput[]
  }

  export type TransactionFeeUncheckedCreateNestedManyWithoutTransactionInput = {
    create?: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput> | TransactionFeeCreateWithoutTransactionInput[] | TransactionFeeUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionFeeCreateOrConnectWithoutTransactionInput | TransactionFeeCreateOrConnectWithoutTransactionInput[]
    createMany?: TransactionFeeCreateManyTransactionInputEnvelope
    connect?: TransactionFeeWhereUniqueInput | TransactionFeeWhereUniqueInput[]
  }

  export type EnumTransactionStatusFieldUpdateOperationsInput = {
    set?: $Enums.TransactionStatus
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type PaymentRequestUpdateOneWithoutTransactionsNestedInput = {
    create?: XOR<PaymentRequestCreateWithoutTransactionsInput, PaymentRequestUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: PaymentRequestCreateOrConnectWithoutTransactionsInput
    upsert?: PaymentRequestUpsertWithoutTransactionsInput
    disconnect?: PaymentRequestWhereInput | boolean
    delete?: PaymentRequestWhereInput | boolean
    connect?: PaymentRequestWhereUniqueInput
    update?: XOR<XOR<PaymentRequestUpdateToOneWithWhereWithoutTransactionsInput, PaymentRequestUpdateWithoutTransactionsInput>, PaymentRequestUncheckedUpdateWithoutTransactionsInput>
  }

  export type LinkedAccountUpdateOneRequiredWithoutSourceTransactionsNestedInput = {
    create?: XOR<LinkedAccountCreateWithoutSourceTransactionsInput, LinkedAccountUncheckedCreateWithoutSourceTransactionsInput>
    connectOrCreate?: LinkedAccountCreateOrConnectWithoutSourceTransactionsInput
    upsert?: LinkedAccountUpsertWithoutSourceTransactionsInput
    connect?: LinkedAccountWhereUniqueInput
    update?: XOR<XOR<LinkedAccountUpdateToOneWithWhereWithoutSourceTransactionsInput, LinkedAccountUpdateWithoutSourceTransactionsInput>, LinkedAccountUncheckedUpdateWithoutSourceTransactionsInput>
  }

  export type LinkedAccountUpdateOneWithoutTargetTransactionsNestedInput = {
    create?: XOR<LinkedAccountCreateWithoutTargetTransactionsInput, LinkedAccountUncheckedCreateWithoutTargetTransactionsInput>
    connectOrCreate?: LinkedAccountCreateOrConnectWithoutTargetTransactionsInput
    upsert?: LinkedAccountUpsertWithoutTargetTransactionsInput
    disconnect?: LinkedAccountWhereInput | boolean
    delete?: LinkedAccountWhereInput | boolean
    connect?: LinkedAccountWhereUniqueInput
    update?: XOR<XOR<LinkedAccountUpdateToOneWithWhereWithoutTargetTransactionsInput, LinkedAccountUpdateWithoutTargetTransactionsInput>, LinkedAccountUncheckedUpdateWithoutTargetTransactionsInput>
  }

  export type RoutingStepUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<RoutingStepCreateWithoutTransactionInput, RoutingStepUncheckedCreateWithoutTransactionInput> | RoutingStepCreateWithoutTransactionInput[] | RoutingStepUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RoutingStepCreateOrConnectWithoutTransactionInput | RoutingStepCreateOrConnectWithoutTransactionInput[]
    upsert?: RoutingStepUpsertWithWhereUniqueWithoutTransactionInput | RoutingStepUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: RoutingStepCreateManyTransactionInputEnvelope
    set?: RoutingStepWhereUniqueInput | RoutingStepWhereUniqueInput[]
    disconnect?: RoutingStepWhereUniqueInput | RoutingStepWhereUniqueInput[]
    delete?: RoutingStepWhereUniqueInput | RoutingStepWhereUniqueInput[]
    connect?: RoutingStepWhereUniqueInput | RoutingStepWhereUniqueInput[]
    update?: RoutingStepUpdateWithWhereUniqueWithoutTransactionInput | RoutingStepUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: RoutingStepUpdateManyWithWhereWithoutTransactionInput | RoutingStepUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: RoutingStepScalarWhereInput | RoutingStepScalarWhereInput[]
  }

  export type TransactionFeeUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput> | TransactionFeeCreateWithoutTransactionInput[] | TransactionFeeUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionFeeCreateOrConnectWithoutTransactionInput | TransactionFeeCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionFeeUpsertWithWhereUniqueWithoutTransactionInput | TransactionFeeUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionFeeCreateManyTransactionInputEnvelope
    set?: TransactionFeeWhereUniqueInput | TransactionFeeWhereUniqueInput[]
    disconnect?: TransactionFeeWhereUniqueInput | TransactionFeeWhereUniqueInput[]
    delete?: TransactionFeeWhereUniqueInput | TransactionFeeWhereUniqueInput[]
    connect?: TransactionFeeWhereUniqueInput | TransactionFeeWhereUniqueInput[]
    update?: TransactionFeeUpdateWithWhereUniqueWithoutTransactionInput | TransactionFeeUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionFeeUpdateManyWithWhereWithoutTransactionInput | TransactionFeeUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionFeeScalarWhereInput | TransactionFeeScalarWhereInput[]
  }

  export type RoutingStepUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<RoutingStepCreateWithoutTransactionInput, RoutingStepUncheckedCreateWithoutTransactionInput> | RoutingStepCreateWithoutTransactionInput[] | RoutingStepUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: RoutingStepCreateOrConnectWithoutTransactionInput | RoutingStepCreateOrConnectWithoutTransactionInput[]
    upsert?: RoutingStepUpsertWithWhereUniqueWithoutTransactionInput | RoutingStepUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: RoutingStepCreateManyTransactionInputEnvelope
    set?: RoutingStepWhereUniqueInput | RoutingStepWhereUniqueInput[]
    disconnect?: RoutingStepWhereUniqueInput | RoutingStepWhereUniqueInput[]
    delete?: RoutingStepWhereUniqueInput | RoutingStepWhereUniqueInput[]
    connect?: RoutingStepWhereUniqueInput | RoutingStepWhereUniqueInput[]
    update?: RoutingStepUpdateWithWhereUniqueWithoutTransactionInput | RoutingStepUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: RoutingStepUpdateManyWithWhereWithoutTransactionInput | RoutingStepUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: RoutingStepScalarWhereInput | RoutingStepScalarWhereInput[]
  }

  export type TransactionFeeUncheckedUpdateManyWithoutTransactionNestedInput = {
    create?: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput> | TransactionFeeCreateWithoutTransactionInput[] | TransactionFeeUncheckedCreateWithoutTransactionInput[]
    connectOrCreate?: TransactionFeeCreateOrConnectWithoutTransactionInput | TransactionFeeCreateOrConnectWithoutTransactionInput[]
    upsert?: TransactionFeeUpsertWithWhereUniqueWithoutTransactionInput | TransactionFeeUpsertWithWhereUniqueWithoutTransactionInput[]
    createMany?: TransactionFeeCreateManyTransactionInputEnvelope
    set?: TransactionFeeWhereUniqueInput | TransactionFeeWhereUniqueInput[]
    disconnect?: TransactionFeeWhereUniqueInput | TransactionFeeWhereUniqueInput[]
    delete?: TransactionFeeWhereUniqueInput | TransactionFeeWhereUniqueInput[]
    connect?: TransactionFeeWhereUniqueInput | TransactionFeeWhereUniqueInput[]
    update?: TransactionFeeUpdateWithWhereUniqueWithoutTransactionInput | TransactionFeeUpdateWithWhereUniqueWithoutTransactionInput[]
    updateMany?: TransactionFeeUpdateManyWithWhereWithoutTransactionInput | TransactionFeeUpdateManyWithWhereWithoutTransactionInput[]
    deleteMany?: TransactionFeeScalarWhereInput | TransactionFeeScalarWhereInput[]
  }

  export type PaymentTransactionCreateNestedOneWithoutRoutingStepsInput = {
    create?: XOR<PaymentTransactionCreateWithoutRoutingStepsInput, PaymentTransactionUncheckedCreateWithoutRoutingStepsInput>
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutRoutingStepsInput
    connect?: PaymentTransactionWhereUniqueInput
  }

  export type RoutingStepFeeCreateNestedManyWithoutRoutingStepInput = {
    create?: XOR<RoutingStepFeeCreateWithoutRoutingStepInput, RoutingStepFeeUncheckedCreateWithoutRoutingStepInput> | RoutingStepFeeCreateWithoutRoutingStepInput[] | RoutingStepFeeUncheckedCreateWithoutRoutingStepInput[]
    connectOrCreate?: RoutingStepFeeCreateOrConnectWithoutRoutingStepInput | RoutingStepFeeCreateOrConnectWithoutRoutingStepInput[]
    createMany?: RoutingStepFeeCreateManyRoutingStepInputEnvelope
    connect?: RoutingStepFeeWhereUniqueInput | RoutingStepFeeWhereUniqueInput[]
  }

  export type RoutingStepFeeUncheckedCreateNestedManyWithoutRoutingStepInput = {
    create?: XOR<RoutingStepFeeCreateWithoutRoutingStepInput, RoutingStepFeeUncheckedCreateWithoutRoutingStepInput> | RoutingStepFeeCreateWithoutRoutingStepInput[] | RoutingStepFeeUncheckedCreateWithoutRoutingStepInput[]
    connectOrCreate?: RoutingStepFeeCreateOrConnectWithoutRoutingStepInput | RoutingStepFeeCreateOrConnectWithoutRoutingStepInput[]
    createMany?: RoutingStepFeeCreateManyRoutingStepInputEnvelope
    connect?: RoutingStepFeeWhereUniqueInput | RoutingStepFeeWhereUniqueInput[]
  }

  export type EnumRoutingActionFieldUpdateOperationsInput = {
    set?: $Enums.RoutingAction
  }

  export type EnumStepStatusFieldUpdateOperationsInput = {
    set?: $Enums.StepStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PaymentTransactionUpdateOneRequiredWithoutRoutingStepsNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutRoutingStepsInput, PaymentTransactionUncheckedCreateWithoutRoutingStepsInput>
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutRoutingStepsInput
    upsert?: PaymentTransactionUpsertWithoutRoutingStepsInput
    connect?: PaymentTransactionWhereUniqueInput
    update?: XOR<XOR<PaymentTransactionUpdateToOneWithWhereWithoutRoutingStepsInput, PaymentTransactionUpdateWithoutRoutingStepsInput>, PaymentTransactionUncheckedUpdateWithoutRoutingStepsInput>
  }

  export type RoutingStepFeeUpdateManyWithoutRoutingStepNestedInput = {
    create?: XOR<RoutingStepFeeCreateWithoutRoutingStepInput, RoutingStepFeeUncheckedCreateWithoutRoutingStepInput> | RoutingStepFeeCreateWithoutRoutingStepInput[] | RoutingStepFeeUncheckedCreateWithoutRoutingStepInput[]
    connectOrCreate?: RoutingStepFeeCreateOrConnectWithoutRoutingStepInput | RoutingStepFeeCreateOrConnectWithoutRoutingStepInput[]
    upsert?: RoutingStepFeeUpsertWithWhereUniqueWithoutRoutingStepInput | RoutingStepFeeUpsertWithWhereUniqueWithoutRoutingStepInput[]
    createMany?: RoutingStepFeeCreateManyRoutingStepInputEnvelope
    set?: RoutingStepFeeWhereUniqueInput | RoutingStepFeeWhereUniqueInput[]
    disconnect?: RoutingStepFeeWhereUniqueInput | RoutingStepFeeWhereUniqueInput[]
    delete?: RoutingStepFeeWhereUniqueInput | RoutingStepFeeWhereUniqueInput[]
    connect?: RoutingStepFeeWhereUniqueInput | RoutingStepFeeWhereUniqueInput[]
    update?: RoutingStepFeeUpdateWithWhereUniqueWithoutRoutingStepInput | RoutingStepFeeUpdateWithWhereUniqueWithoutRoutingStepInput[]
    updateMany?: RoutingStepFeeUpdateManyWithWhereWithoutRoutingStepInput | RoutingStepFeeUpdateManyWithWhereWithoutRoutingStepInput[]
    deleteMany?: RoutingStepFeeScalarWhereInput | RoutingStepFeeScalarWhereInput[]
  }

  export type RoutingStepFeeUncheckedUpdateManyWithoutRoutingStepNestedInput = {
    create?: XOR<RoutingStepFeeCreateWithoutRoutingStepInput, RoutingStepFeeUncheckedCreateWithoutRoutingStepInput> | RoutingStepFeeCreateWithoutRoutingStepInput[] | RoutingStepFeeUncheckedCreateWithoutRoutingStepInput[]
    connectOrCreate?: RoutingStepFeeCreateOrConnectWithoutRoutingStepInput | RoutingStepFeeCreateOrConnectWithoutRoutingStepInput[]
    upsert?: RoutingStepFeeUpsertWithWhereUniqueWithoutRoutingStepInput | RoutingStepFeeUpsertWithWhereUniqueWithoutRoutingStepInput[]
    createMany?: RoutingStepFeeCreateManyRoutingStepInputEnvelope
    set?: RoutingStepFeeWhereUniqueInput | RoutingStepFeeWhereUniqueInput[]
    disconnect?: RoutingStepFeeWhereUniqueInput | RoutingStepFeeWhereUniqueInput[]
    delete?: RoutingStepFeeWhereUniqueInput | RoutingStepFeeWhereUniqueInput[]
    connect?: RoutingStepFeeWhereUniqueInput | RoutingStepFeeWhereUniqueInput[]
    update?: RoutingStepFeeUpdateWithWhereUniqueWithoutRoutingStepInput | RoutingStepFeeUpdateWithWhereUniqueWithoutRoutingStepInput[]
    updateMany?: RoutingStepFeeUpdateManyWithWhereWithoutRoutingStepInput | RoutingStepFeeUpdateManyWithWhereWithoutRoutingStepInput[]
    deleteMany?: RoutingStepFeeScalarWhereInput | RoutingStepFeeScalarWhereInput[]
  }

  export type PaymentTransactionCreateNestedOneWithoutFeesInput = {
    create?: XOR<PaymentTransactionCreateWithoutFeesInput, PaymentTransactionUncheckedCreateWithoutFeesInput>
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutFeesInput
    connect?: PaymentTransactionWhereUniqueInput
  }

  export type EnumFeeTypeFieldUpdateOperationsInput = {
    set?: $Enums.FeeType
  }

  export type PaymentTransactionUpdateOneRequiredWithoutFeesNestedInput = {
    create?: XOR<PaymentTransactionCreateWithoutFeesInput, PaymentTransactionUncheckedCreateWithoutFeesInput>
    connectOrCreate?: PaymentTransactionCreateOrConnectWithoutFeesInput
    upsert?: PaymentTransactionUpsertWithoutFeesInput
    connect?: PaymentTransactionWhereUniqueInput
    update?: XOR<XOR<PaymentTransactionUpdateToOneWithWhereWithoutFeesInput, PaymentTransactionUpdateWithoutFeesInput>, PaymentTransactionUncheckedUpdateWithoutFeesInput>
  }

  export type RoutingStepCreateNestedOneWithoutFeesInput = {
    create?: XOR<RoutingStepCreateWithoutFeesInput, RoutingStepUncheckedCreateWithoutFeesInput>
    connectOrCreate?: RoutingStepCreateOrConnectWithoutFeesInput
    connect?: RoutingStepWhereUniqueInput
  }

  export type RoutingStepUpdateOneRequiredWithoutFeesNestedInput = {
    create?: XOR<RoutingStepCreateWithoutFeesInput, RoutingStepUncheckedCreateWithoutFeesInput>
    connectOrCreate?: RoutingStepCreateOrConnectWithoutFeesInput
    upsert?: RoutingStepUpsertWithoutFeesInput
    connect?: RoutingStepWhereUniqueInput
    update?: XOR<XOR<RoutingStepUpdateToOneWithWhereWithoutFeesInput, RoutingStepUpdateWithoutFeesInput>, RoutingStepUncheckedUpdateWithoutFeesInput>
  }

  export type UserCreateNestedOneWithoutRoutingRulesInput = {
    create?: XOR<UserCreateWithoutRoutingRulesInput, UserUncheckedCreateWithoutRoutingRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoutingRulesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutRoutingRulesNestedInput = {
    create?: XOR<UserCreateWithoutRoutingRulesInput, UserUncheckedCreateWithoutRoutingRulesInput>
    connectOrCreate?: UserCreateOrConnectWithoutRoutingRulesInput
    upsert?: UserUpsertWithoutRoutingRulesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRoutingRulesInput, UserUpdateWithoutRoutingRulesInput>, UserUncheckedUpdateWithoutRoutingRulesInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumKYCStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusFilter<$PrismaModel> | $Enums.KYCStatus
  }

  export type NestedEnumRiskProfileFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskProfile | EnumRiskProfileFieldRefInput<$PrismaModel>
    in?: $Enums.RiskProfile[] | ListEnumRiskProfileFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskProfile[] | ListEnumRiskProfileFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskProfileFilter<$PrismaModel> | $Enums.RiskProfile
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.KYCStatus | EnumKYCStatusFieldRefInput<$PrismaModel>
    in?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.KYCStatus[] | ListEnumKYCStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumKYCStatusWithAggregatesFilter<$PrismaModel> | $Enums.KYCStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumKYCStatusFilter<$PrismaModel>
    _max?: NestedEnumKYCStatusFilter<$PrismaModel>
  }

  export type NestedEnumRiskProfileWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RiskProfile | EnumRiskProfileFieldRefInput<$PrismaModel>
    in?: $Enums.RiskProfile[] | ListEnumRiskProfileFieldRefInput<$PrismaModel>
    notIn?: $Enums.RiskProfile[] | ListEnumRiskProfileFieldRefInput<$PrismaModel>
    not?: NestedEnumRiskProfileWithAggregatesFilter<$PrismaModel> | $Enums.RiskProfile
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRiskProfileFilter<$PrismaModel>
    _max?: NestedEnumRiskProfileFilter<$PrismaModel>
  }

  export type NestedEnumAccountTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeFilter<$PrismaModel> | $Enums.AccountType
  }

  export type NestedEnumPaymentProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderFilter<$PrismaModel> | $Enums.PaymentProvider
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccountType | EnumAccountTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccountType[] | ListEnumAccountTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccountTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccountType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccountTypeFilter<$PrismaModel>
    _max?: NestedEnumAccountTypeFilter<$PrismaModel>
  }

  export type NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentProvider | EnumPaymentProviderFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentProvider[] | ListEnumPaymentProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentProviderWithAggregatesFilter<$PrismaModel> | $Enums.PaymentProvider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentProviderFilter<$PrismaModel>
    _max?: NestedEnumPaymentProviderFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTransactionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusFilter<$PrismaModel> | $Enums.TransactionStatus
  }

  export type NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionStatus | EnumTransactionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionStatus[] | ListEnumTransactionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionStatusWithAggregatesFilter<$PrismaModel> | $Enums.TransactionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionStatusFilter<$PrismaModel>
    _max?: NestedEnumTransactionStatusFilter<$PrismaModel>
  }

  export type NestedEnumRoutingActionFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutingAction | EnumRoutingActionFieldRefInput<$PrismaModel>
    in?: $Enums.RoutingAction[] | ListEnumRoutingActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutingAction[] | ListEnumRoutingActionFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutingActionFilter<$PrismaModel> | $Enums.RoutingAction
  }

  export type NestedEnumStepStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusFilter<$PrismaModel> | $Enums.StepStatus
  }

  export type NestedEnumRoutingActionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoutingAction | EnumRoutingActionFieldRefInput<$PrismaModel>
    in?: $Enums.RoutingAction[] | ListEnumRoutingActionFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoutingAction[] | ListEnumRoutingActionFieldRefInput<$PrismaModel>
    not?: NestedEnumRoutingActionWithAggregatesFilter<$PrismaModel> | $Enums.RoutingAction
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoutingActionFilter<$PrismaModel>
    _max?: NestedEnumRoutingActionFilter<$PrismaModel>
  }

  export type NestedEnumStepStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StepStatus | EnumStepStatusFieldRefInput<$PrismaModel>
    in?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.StepStatus[] | ListEnumStepStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStepStatusWithAggregatesFilter<$PrismaModel> | $Enums.StepStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStepStatusFilter<$PrismaModel>
    _max?: NestedEnumStepStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedEnumFeeTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeTypeFilter<$PrismaModel> | $Enums.FeeType
  }

  export type NestedEnumFeeTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FeeType | EnumFeeTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FeeType[] | ListEnumFeeTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFeeTypeWithAggregatesFilter<$PrismaModel> | $Enums.FeeType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFeeTypeFilter<$PrismaModel>
    _max?: NestedEnumFeeTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserProfileCreateWithoutUserInput = {
    id?: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    kycStatus?: $Enums.KYCStatus
    riskProfile?: $Enums.RiskProfile
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileUncheckedCreateWithoutUserInput = {
    id?: string
    avatarUrl?: string | null
    dateOfBirth?: Date | string | null
    street?: string | null
    city?: string | null
    state?: string | null
    postalCode?: string | null
    country?: string | null
    kycStatus?: $Enums.KYCStatus
    riskProfile?: $Enums.RiskProfile
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserProfileCreateOrConnectWithoutUserInput = {
    where: UserProfileWhereUniqueInput
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
  }

  export type LinkedAccountCreateWithoutUserInput = {
    id?: string
    accountType: $Enums.AccountType
    provider: $Enums.PaymentProvider
    accountNumber: string
    accountName: string
    currency: string
    balance?: number | null
    isActive?: boolean
    isPrimary?: boolean
    priority?: number
    dailyLimit?: number | null
    monthlyLimit?: number | null
    linkedAt?: Date | string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceTransactions?: PaymentTransactionCreateNestedManyWithoutSourceAccountInput
    targetTransactions?: PaymentTransactionCreateNestedManyWithoutTargetAccountInput
  }

  export type LinkedAccountUncheckedCreateWithoutUserInput = {
    id?: string
    accountType: $Enums.AccountType
    provider: $Enums.PaymentProvider
    accountNumber: string
    accountName: string
    currency: string
    balance?: number | null
    isActive?: boolean
    isPrimary?: boolean
    priority?: number
    dailyLimit?: number | null
    monthlyLimit?: number | null
    linkedAt?: Date | string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutSourceAccountInput
    targetTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutTargetAccountInput
  }

  export type LinkedAccountCreateOrConnectWithoutUserInput = {
    where: LinkedAccountWhereUniqueInput
    create: XOR<LinkedAccountCreateWithoutUserInput, LinkedAccountUncheckedCreateWithoutUserInput>
  }

  export type LinkedAccountCreateManyUserInputEnvelope = {
    data: LinkedAccountCreateManyUserInput | LinkedAccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type RoutingRuleCreateWithoutUserInput = {
    id?: string
    name: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoutingRuleUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoutingRuleCreateOrConnectWithoutUserInput = {
    where: RoutingRuleWhereUniqueInput
    create: XOR<RoutingRuleCreateWithoutUserInput, RoutingRuleUncheckedCreateWithoutUserInput>
  }

  export type RoutingRuleCreateManyUserInputEnvelope = {
    data: RoutingRuleCreateManyUserInput | RoutingRuleCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentRequestCreateWithoutUserInput = {
    id?: string
    amount: number
    currency: string
    targetCurrency?: string | null
    merchantId?: string | null
    merchantName?: string | null
    description?: string | null
    qrCode?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: PaymentTransactionCreateNestedManyWithoutPaymentRequestInput
  }

  export type PaymentRequestUncheckedCreateWithoutUserInput = {
    id?: string
    amount: number
    currency: string
    targetCurrency?: string | null
    merchantId?: string | null
    merchantName?: string | null
    description?: string | null
    qrCode?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transactions?: PaymentTransactionUncheckedCreateNestedManyWithoutPaymentRequestInput
  }

  export type PaymentRequestCreateOrConnectWithoutUserInput = {
    where: PaymentRequestWhereUniqueInput
    create: XOR<PaymentRequestCreateWithoutUserInput, PaymentRequestUncheckedCreateWithoutUserInput>
  }

  export type PaymentRequestCreateManyUserInputEnvelope = {
    data: PaymentRequestCreateManyUserInput | PaymentRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PaymentTransactionCreateWithoutUserInput = {
    id?: string
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentRequest?: PaymentRequestCreateNestedOneWithoutTransactionsInput
    sourceAccount: LinkedAccountCreateNestedOneWithoutSourceTransactionsInput
    targetAccount?: LinkedAccountCreateNestedOneWithoutTargetTransactionsInput
    routingSteps?: RoutingStepCreateNestedManyWithoutTransactionInput
    fees?: TransactionFeeCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    paymentRequestId?: string | null
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    sourceAccountId: string
    targetAccountId?: string | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    routingSteps?: RoutingStepUncheckedCreateNestedManyWithoutTransactionInput
    fees?: TransactionFeeUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionCreateOrConnectWithoutUserInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutUserInput, PaymentTransactionUncheckedCreateWithoutUserInput>
  }

  export type PaymentTransactionCreateManyUserInputEnvelope = {
    data: PaymentTransactionCreateManyUserInput | PaymentTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserSessionCreateWithoutUserInput = {
    id?: string
    token: string
    refreshToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionUncheckedCreateWithoutUserInput = {
    id?: string
    token: string
    refreshToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateOrConnectWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionCreateManyUserInputEnvelope = {
    data: UserSessionCreateManyUserInput | UserSessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserProfileUpsertWithoutUserInput = {
    update: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
    create: XOR<UserProfileCreateWithoutUserInput, UserProfileUncheckedCreateWithoutUserInput>
    where?: UserProfileWhereInput
  }

  export type UserProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: UserProfileWhereInput
    data: XOR<UserProfileUpdateWithoutUserInput, UserProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    riskProfile?: EnumRiskProfileFieldUpdateOperationsInput | $Enums.RiskProfile
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    avatarUrl?: NullableStringFieldUpdateOperationsInput | string | null
    dateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    street?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    postalCode?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    kycStatus?: EnumKYCStatusFieldUpdateOperationsInput | $Enums.KYCStatus
    riskProfile?: EnumRiskProfileFieldUpdateOperationsInput | $Enums.RiskProfile
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedAccountUpsertWithWhereUniqueWithoutUserInput = {
    where: LinkedAccountWhereUniqueInput
    update: XOR<LinkedAccountUpdateWithoutUserInput, LinkedAccountUncheckedUpdateWithoutUserInput>
    create: XOR<LinkedAccountCreateWithoutUserInput, LinkedAccountUncheckedCreateWithoutUserInput>
  }

  export type LinkedAccountUpdateWithWhereUniqueWithoutUserInput = {
    where: LinkedAccountWhereUniqueInput
    data: XOR<LinkedAccountUpdateWithoutUserInput, LinkedAccountUncheckedUpdateWithoutUserInput>
  }

  export type LinkedAccountUpdateManyWithWhereWithoutUserInput = {
    where: LinkedAccountScalarWhereInput
    data: XOR<LinkedAccountUpdateManyMutationInput, LinkedAccountUncheckedUpdateManyWithoutUserInput>
  }

  export type LinkedAccountScalarWhereInput = {
    AND?: LinkedAccountScalarWhereInput | LinkedAccountScalarWhereInput[]
    OR?: LinkedAccountScalarWhereInput[]
    NOT?: LinkedAccountScalarWhereInput | LinkedAccountScalarWhereInput[]
    id?: StringFilter<"LinkedAccount"> | string
    userId?: StringFilter<"LinkedAccount"> | string
    accountType?: EnumAccountTypeFilter<"LinkedAccount"> | $Enums.AccountType
    provider?: EnumPaymentProviderFilter<"LinkedAccount"> | $Enums.PaymentProvider
    accountNumber?: StringFilter<"LinkedAccount"> | string
    accountName?: StringFilter<"LinkedAccount"> | string
    currency?: StringFilter<"LinkedAccount"> | string
    balance?: FloatNullableFilter<"LinkedAccount"> | number | null
    isActive?: BoolFilter<"LinkedAccount"> | boolean
    isPrimary?: BoolFilter<"LinkedAccount"> | boolean
    priority?: IntFilter<"LinkedAccount"> | number
    dailyLimit?: FloatNullableFilter<"LinkedAccount"> | number | null
    monthlyLimit?: FloatNullableFilter<"LinkedAccount"> | number | null
    linkedAt?: DateTimeFilter<"LinkedAccount"> | Date | string
    lastSyncAt?: DateTimeNullableFilter<"LinkedAccount"> | Date | string | null
    createdAt?: DateTimeFilter<"LinkedAccount"> | Date | string
    updatedAt?: DateTimeFilter<"LinkedAccount"> | Date | string
  }

  export type RoutingRuleUpsertWithWhereUniqueWithoutUserInput = {
    where: RoutingRuleWhereUniqueInput
    update: XOR<RoutingRuleUpdateWithoutUserInput, RoutingRuleUncheckedUpdateWithoutUserInput>
    create: XOR<RoutingRuleCreateWithoutUserInput, RoutingRuleUncheckedCreateWithoutUserInput>
  }

  export type RoutingRuleUpdateWithWhereUniqueWithoutUserInput = {
    where: RoutingRuleWhereUniqueInput
    data: XOR<RoutingRuleUpdateWithoutUserInput, RoutingRuleUncheckedUpdateWithoutUserInput>
  }

  export type RoutingRuleUpdateManyWithWhereWithoutUserInput = {
    where: RoutingRuleScalarWhereInput
    data: XOR<RoutingRuleUpdateManyMutationInput, RoutingRuleUncheckedUpdateManyWithoutUserInput>
  }

  export type RoutingRuleScalarWhereInput = {
    AND?: RoutingRuleScalarWhereInput | RoutingRuleScalarWhereInput[]
    OR?: RoutingRuleScalarWhereInput[]
    NOT?: RoutingRuleScalarWhereInput | RoutingRuleScalarWhereInput[]
    id?: StringFilter<"RoutingRule"> | string
    userId?: StringFilter<"RoutingRule"> | string
    name?: StringFilter<"RoutingRule"> | string
    conditions?: JsonFilter<"RoutingRule">
    actions?: JsonFilter<"RoutingRule">
    priority?: IntFilter<"RoutingRule"> | number
    isActive?: BoolFilter<"RoutingRule"> | boolean
    createdAt?: DateTimeFilter<"RoutingRule"> | Date | string
    updatedAt?: DateTimeFilter<"RoutingRule"> | Date | string
  }

  export type PaymentRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentRequestWhereUniqueInput
    update: XOR<PaymentRequestUpdateWithoutUserInput, PaymentRequestUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentRequestCreateWithoutUserInput, PaymentRequestUncheckedCreateWithoutUserInput>
  }

  export type PaymentRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentRequestWhereUniqueInput
    data: XOR<PaymentRequestUpdateWithoutUserInput, PaymentRequestUncheckedUpdateWithoutUserInput>
  }

  export type PaymentRequestUpdateManyWithWhereWithoutUserInput = {
    where: PaymentRequestScalarWhereInput
    data: XOR<PaymentRequestUpdateManyMutationInput, PaymentRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentRequestScalarWhereInput = {
    AND?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
    OR?: PaymentRequestScalarWhereInput[]
    NOT?: PaymentRequestScalarWhereInput | PaymentRequestScalarWhereInput[]
    id?: StringFilter<"PaymentRequest"> | string
    userId?: StringFilter<"PaymentRequest"> | string
    amount?: FloatFilter<"PaymentRequest"> | number
    currency?: StringFilter<"PaymentRequest"> | string
    targetCurrency?: StringNullableFilter<"PaymentRequest"> | string | null
    merchantId?: StringNullableFilter<"PaymentRequest"> | string | null
    merchantName?: StringNullableFilter<"PaymentRequest"> | string | null
    description?: StringNullableFilter<"PaymentRequest"> | string | null
    qrCode?: StringNullableFilter<"PaymentRequest"> | string | null
    metadata?: JsonNullableFilter<"PaymentRequest">
    expiresAt?: DateTimeNullableFilter<"PaymentRequest"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentRequest"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentRequest"> | Date | string
  }

  export type PaymentTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: PaymentTransactionWhereUniqueInput
    update: XOR<PaymentTransactionUpdateWithoutUserInput, PaymentTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<PaymentTransactionCreateWithoutUserInput, PaymentTransactionUncheckedCreateWithoutUserInput>
  }

  export type PaymentTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: PaymentTransactionWhereUniqueInput
    data: XOR<PaymentTransactionUpdateWithoutUserInput, PaymentTransactionUncheckedUpdateWithoutUserInput>
  }

  export type PaymentTransactionUpdateManyWithWhereWithoutUserInput = {
    where: PaymentTransactionScalarWhereInput
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type PaymentTransactionScalarWhereInput = {
    AND?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
    OR?: PaymentTransactionScalarWhereInput[]
    NOT?: PaymentTransactionScalarWhereInput | PaymentTransactionScalarWhereInput[]
    id?: StringFilter<"PaymentTransaction"> | string
    userId?: StringFilter<"PaymentTransaction"> | string
    paymentRequestId?: StringNullableFilter<"PaymentTransaction"> | string | null
    amount?: FloatFilter<"PaymentTransaction"> | number
    currency?: StringFilter<"PaymentTransaction"> | string
    targetAmount?: FloatNullableFilter<"PaymentTransaction"> | number | null
    targetCurrency?: StringNullableFilter<"PaymentTransaction"> | string | null
    exchangeRate?: FloatNullableFilter<"PaymentTransaction"> | number | null
    sourceAccountId?: StringFilter<"PaymentTransaction"> | string
    targetAccountId?: StringNullableFilter<"PaymentTransaction"> | string | null
    status?: EnumTransactionStatusFilter<"PaymentTransaction"> | $Enums.TransactionStatus
    failureReason?: StringNullableFilter<"PaymentTransaction"> | string | null
    merchantName?: StringNullableFilter<"PaymentTransaction"> | string | null
    merchantCategory?: StringNullableFilter<"PaymentTransaction"> | string | null
    merchantLocation?: StringNullableFilter<"PaymentTransaction"> | string | null
    metadata?: JsonNullableFilter<"PaymentTransaction">
    initiatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    completedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    failedAt?: DateTimeNullableFilter<"PaymentTransaction"> | Date | string | null
    createdAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
    updatedAt?: DateTimeFilter<"PaymentTransaction"> | Date | string
  }

  export type UserSessionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    update: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
    create: XOR<UserSessionCreateWithoutUserInput, UserSessionUncheckedCreateWithoutUserInput>
  }

  export type UserSessionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserSessionWhereUniqueInput
    data: XOR<UserSessionUpdateWithoutUserInput, UserSessionUncheckedUpdateWithoutUserInput>
  }

  export type UserSessionUpdateManyWithWhereWithoutUserInput = {
    where: UserSessionScalarWhereInput
    data: XOR<UserSessionUpdateManyMutationInput, UserSessionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserSessionScalarWhereInput = {
    AND?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    OR?: UserSessionScalarWhereInput[]
    NOT?: UserSessionScalarWhereInput | UserSessionScalarWhereInput[]
    id?: StringFilter<"UserSession"> | string
    userId?: StringFilter<"UserSession"> | string
    token?: StringFilter<"UserSession"> | string
    refreshToken?: StringFilter<"UserSession"> | string
    deviceInfo?: JsonNullableFilter<"UserSession">
    ipAddress?: StringNullableFilter<"UserSession"> | string | null
    expiresAt?: DateTimeFilter<"UserSession"> | Date | string
    createdAt?: DateTimeFilter<"UserSession"> | Date | string
    updatedAt?: DateTimeFilter<"UserSession"> | Date | string
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedAccounts?: LinkedAccountCreateNestedManyWithoutUserInput
    routingRules?: RoutingRuleCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    linkedAccounts?: LinkedAccountUncheckedCreateNestedManyWithoutUserInput
    routingRules?: RoutingRuleUncheckedCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedAccounts?: LinkedAccountUpdateManyWithoutUserNestedInput
    routingRules?: RoutingRuleUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    linkedAccounts?: LinkedAccountUncheckedUpdateManyWithoutUserNestedInput
    routingRules?: RoutingRuleUncheckedUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutLinkedAccountsInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileCreateNestedOneWithoutUserInput
    routingRules?: RoutingRuleCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutLinkedAccountsInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    routingRules?: RoutingRuleUncheckedCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutLinkedAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLinkedAccountsInput, UserUncheckedCreateWithoutLinkedAccountsInput>
  }

  export type PaymentTransactionCreateWithoutSourceAccountInput = {
    id?: string
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    paymentRequest?: PaymentRequestCreateNestedOneWithoutTransactionsInput
    targetAccount?: LinkedAccountCreateNestedOneWithoutTargetTransactionsInput
    routingSteps?: RoutingStepCreateNestedManyWithoutTransactionInput
    fees?: TransactionFeeCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionUncheckedCreateWithoutSourceAccountInput = {
    id?: string
    userId: string
    paymentRequestId?: string | null
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    targetAccountId?: string | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    routingSteps?: RoutingStepUncheckedCreateNestedManyWithoutTransactionInput
    fees?: TransactionFeeUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionCreateOrConnectWithoutSourceAccountInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutSourceAccountInput, PaymentTransactionUncheckedCreateWithoutSourceAccountInput>
  }

  export type PaymentTransactionCreateManySourceAccountInputEnvelope = {
    data: PaymentTransactionCreateManySourceAccountInput | PaymentTransactionCreateManySourceAccountInput[]
    skipDuplicates?: boolean
  }

  export type PaymentTransactionCreateWithoutTargetAccountInput = {
    id?: string
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    paymentRequest?: PaymentRequestCreateNestedOneWithoutTransactionsInput
    sourceAccount: LinkedAccountCreateNestedOneWithoutSourceTransactionsInput
    routingSteps?: RoutingStepCreateNestedManyWithoutTransactionInput
    fees?: TransactionFeeCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionUncheckedCreateWithoutTargetAccountInput = {
    id?: string
    userId: string
    paymentRequestId?: string | null
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    sourceAccountId: string
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    routingSteps?: RoutingStepUncheckedCreateNestedManyWithoutTransactionInput
    fees?: TransactionFeeUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionCreateOrConnectWithoutTargetAccountInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutTargetAccountInput, PaymentTransactionUncheckedCreateWithoutTargetAccountInput>
  }

  export type PaymentTransactionCreateManyTargetAccountInputEnvelope = {
    data: PaymentTransactionCreateManyTargetAccountInput | PaymentTransactionCreateManyTargetAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutLinkedAccountsInput = {
    update: XOR<UserUpdateWithoutLinkedAccountsInput, UserUncheckedUpdateWithoutLinkedAccountsInput>
    create: XOR<UserCreateWithoutLinkedAccountsInput, UserUncheckedCreateWithoutLinkedAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLinkedAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLinkedAccountsInput, UserUncheckedUpdateWithoutLinkedAccountsInput>
  }

  export type UserUpdateWithoutLinkedAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    routingRules?: RoutingRuleUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutLinkedAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    routingRules?: RoutingRuleUncheckedUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentTransactionUpsertWithWhereUniqueWithoutSourceAccountInput = {
    where: PaymentTransactionWhereUniqueInput
    update: XOR<PaymentTransactionUpdateWithoutSourceAccountInput, PaymentTransactionUncheckedUpdateWithoutSourceAccountInput>
    create: XOR<PaymentTransactionCreateWithoutSourceAccountInput, PaymentTransactionUncheckedCreateWithoutSourceAccountInput>
  }

  export type PaymentTransactionUpdateWithWhereUniqueWithoutSourceAccountInput = {
    where: PaymentTransactionWhereUniqueInput
    data: XOR<PaymentTransactionUpdateWithoutSourceAccountInput, PaymentTransactionUncheckedUpdateWithoutSourceAccountInput>
  }

  export type PaymentTransactionUpdateManyWithWhereWithoutSourceAccountInput = {
    where: PaymentTransactionScalarWhereInput
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyWithoutSourceAccountInput>
  }

  export type PaymentTransactionUpsertWithWhereUniqueWithoutTargetAccountInput = {
    where: PaymentTransactionWhereUniqueInput
    update: XOR<PaymentTransactionUpdateWithoutTargetAccountInput, PaymentTransactionUncheckedUpdateWithoutTargetAccountInput>
    create: XOR<PaymentTransactionCreateWithoutTargetAccountInput, PaymentTransactionUncheckedCreateWithoutTargetAccountInput>
  }

  export type PaymentTransactionUpdateWithWhereUniqueWithoutTargetAccountInput = {
    where: PaymentTransactionWhereUniqueInput
    data: XOR<PaymentTransactionUpdateWithoutTargetAccountInput, PaymentTransactionUncheckedUpdateWithoutTargetAccountInput>
  }

  export type PaymentTransactionUpdateManyWithWhereWithoutTargetAccountInput = {
    where: PaymentTransactionScalarWhereInput
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyWithoutTargetAccountInput>
  }

  export type UserCreateWithoutPaymentRequestsInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileCreateNestedOneWithoutUserInput
    linkedAccounts?: LinkedAccountCreateNestedManyWithoutUserInput
    routingRules?: RoutingRuleCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPaymentRequestsInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    linkedAccounts?: LinkedAccountUncheckedCreateNestedManyWithoutUserInput
    routingRules?: RoutingRuleUncheckedCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPaymentRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPaymentRequestsInput, UserUncheckedCreateWithoutPaymentRequestsInput>
  }

  export type PaymentTransactionCreateWithoutPaymentRequestInput = {
    id?: string
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    sourceAccount: LinkedAccountCreateNestedOneWithoutSourceTransactionsInput
    targetAccount?: LinkedAccountCreateNestedOneWithoutTargetTransactionsInput
    routingSteps?: RoutingStepCreateNestedManyWithoutTransactionInput
    fees?: TransactionFeeCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionUncheckedCreateWithoutPaymentRequestInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    sourceAccountId: string
    targetAccountId?: string | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    routingSteps?: RoutingStepUncheckedCreateNestedManyWithoutTransactionInput
    fees?: TransactionFeeUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionCreateOrConnectWithoutPaymentRequestInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutPaymentRequestInput, PaymentTransactionUncheckedCreateWithoutPaymentRequestInput>
  }

  export type PaymentTransactionCreateManyPaymentRequestInputEnvelope = {
    data: PaymentTransactionCreateManyPaymentRequestInput | PaymentTransactionCreateManyPaymentRequestInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPaymentRequestsInput = {
    update: XOR<UserUpdateWithoutPaymentRequestsInput, UserUncheckedUpdateWithoutPaymentRequestsInput>
    create: XOR<UserCreateWithoutPaymentRequestsInput, UserUncheckedCreateWithoutPaymentRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPaymentRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPaymentRequestsInput, UserUncheckedUpdateWithoutPaymentRequestsInput>
  }

  export type UserUpdateWithoutPaymentRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    linkedAccounts?: LinkedAccountUpdateManyWithoutUserNestedInput
    routingRules?: RoutingRuleUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPaymentRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    linkedAccounts?: LinkedAccountUncheckedUpdateManyWithoutUserNestedInput
    routingRules?: RoutingRuleUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentTransactionUpsertWithWhereUniqueWithoutPaymentRequestInput = {
    where: PaymentTransactionWhereUniqueInput
    update: XOR<PaymentTransactionUpdateWithoutPaymentRequestInput, PaymentTransactionUncheckedUpdateWithoutPaymentRequestInput>
    create: XOR<PaymentTransactionCreateWithoutPaymentRequestInput, PaymentTransactionUncheckedCreateWithoutPaymentRequestInput>
  }

  export type PaymentTransactionUpdateWithWhereUniqueWithoutPaymentRequestInput = {
    where: PaymentTransactionWhereUniqueInput
    data: XOR<PaymentTransactionUpdateWithoutPaymentRequestInput, PaymentTransactionUncheckedUpdateWithoutPaymentRequestInput>
  }

  export type PaymentTransactionUpdateManyWithWhereWithoutPaymentRequestInput = {
    where: PaymentTransactionScalarWhereInput
    data: XOR<PaymentTransactionUpdateManyMutationInput, PaymentTransactionUncheckedUpdateManyWithoutPaymentRequestInput>
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileCreateNestedOneWithoutUserInput
    linkedAccounts?: LinkedAccountCreateNestedManyWithoutUserInput
    routingRules?: RoutingRuleCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    linkedAccounts?: LinkedAccountUncheckedCreateNestedManyWithoutUserInput
    routingRules?: RoutingRuleUncheckedCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type PaymentRequestCreateWithoutTransactionsInput = {
    id?: string
    amount: number
    currency: string
    targetCurrency?: string | null
    merchantId?: string | null
    merchantName?: string | null
    description?: string | null
    qrCode?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPaymentRequestsInput
  }

  export type PaymentRequestUncheckedCreateWithoutTransactionsInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    targetCurrency?: string | null
    merchantId?: string | null
    merchantName?: string | null
    description?: string | null
    qrCode?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestCreateOrConnectWithoutTransactionsInput = {
    where: PaymentRequestWhereUniqueInput
    create: XOR<PaymentRequestCreateWithoutTransactionsInput, PaymentRequestUncheckedCreateWithoutTransactionsInput>
  }

  export type LinkedAccountCreateWithoutSourceTransactionsInput = {
    id?: string
    accountType: $Enums.AccountType
    provider: $Enums.PaymentProvider
    accountNumber: string
    accountName: string
    currency: string
    balance?: number | null
    isActive?: boolean
    isPrimary?: boolean
    priority?: number
    dailyLimit?: number | null
    monthlyLimit?: number | null
    linkedAt?: Date | string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLinkedAccountsInput
    targetTransactions?: PaymentTransactionCreateNestedManyWithoutTargetAccountInput
  }

  export type LinkedAccountUncheckedCreateWithoutSourceTransactionsInput = {
    id?: string
    userId: string
    accountType: $Enums.AccountType
    provider: $Enums.PaymentProvider
    accountNumber: string
    accountName: string
    currency: string
    balance?: number | null
    isActive?: boolean
    isPrimary?: boolean
    priority?: number
    dailyLimit?: number | null
    monthlyLimit?: number | null
    linkedAt?: Date | string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    targetTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutTargetAccountInput
  }

  export type LinkedAccountCreateOrConnectWithoutSourceTransactionsInput = {
    where: LinkedAccountWhereUniqueInput
    create: XOR<LinkedAccountCreateWithoutSourceTransactionsInput, LinkedAccountUncheckedCreateWithoutSourceTransactionsInput>
  }

  export type LinkedAccountCreateWithoutTargetTransactionsInput = {
    id?: string
    accountType: $Enums.AccountType
    provider: $Enums.PaymentProvider
    accountNumber: string
    accountName: string
    currency: string
    balance?: number | null
    isActive?: boolean
    isPrimary?: boolean
    priority?: number
    dailyLimit?: number | null
    monthlyLimit?: number | null
    linkedAt?: Date | string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLinkedAccountsInput
    sourceTransactions?: PaymentTransactionCreateNestedManyWithoutSourceAccountInput
  }

  export type LinkedAccountUncheckedCreateWithoutTargetTransactionsInput = {
    id?: string
    userId: string
    accountType: $Enums.AccountType
    provider: $Enums.PaymentProvider
    accountNumber: string
    accountName: string
    currency: string
    balance?: number | null
    isActive?: boolean
    isPrimary?: boolean
    priority?: number
    dailyLimit?: number | null
    monthlyLimit?: number | null
    linkedAt?: Date | string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sourceTransactions?: PaymentTransactionUncheckedCreateNestedManyWithoutSourceAccountInput
  }

  export type LinkedAccountCreateOrConnectWithoutTargetTransactionsInput = {
    where: LinkedAccountWhereUniqueInput
    create: XOR<LinkedAccountCreateWithoutTargetTransactionsInput, LinkedAccountUncheckedCreateWithoutTargetTransactionsInput>
  }

  export type RoutingStepCreateWithoutTransactionInput = {
    id?: string
    stepNumber: number
    provider: $Enums.PaymentProvider
    action: $Enums.RoutingAction
    amount: number
    currency: string
    status?: $Enums.StepStatus
    processingTime?: number | null
    externalTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: RoutingStepFeeCreateNestedManyWithoutRoutingStepInput
  }

  export type RoutingStepUncheckedCreateWithoutTransactionInput = {
    id?: string
    stepNumber: number
    provider: $Enums.PaymentProvider
    action: $Enums.RoutingAction
    amount: number
    currency: string
    status?: $Enums.StepStatus
    processingTime?: number | null
    externalTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: RoutingStepFeeUncheckedCreateNestedManyWithoutRoutingStepInput
  }

  export type RoutingStepCreateOrConnectWithoutTransactionInput = {
    where: RoutingStepWhereUniqueInput
    create: XOR<RoutingStepCreateWithoutTransactionInput, RoutingStepUncheckedCreateWithoutTransactionInput>
  }

  export type RoutingStepCreateManyTransactionInputEnvelope = {
    data: RoutingStepCreateManyTransactionInput | RoutingStepCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type TransactionFeeCreateWithoutTransactionInput = {
    id?: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
  }

  export type TransactionFeeUncheckedCreateWithoutTransactionInput = {
    id?: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
  }

  export type TransactionFeeCreateOrConnectWithoutTransactionInput = {
    where: TransactionFeeWhereUniqueInput
    create: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionFeeCreateManyTransactionInputEnvelope = {
    data: TransactionFeeCreateManyTransactionInput | TransactionFeeCreateManyTransactionInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    linkedAccounts?: LinkedAccountUpdateManyWithoutUserNestedInput
    routingRules?: RoutingRuleUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    linkedAccounts?: LinkedAccountUncheckedUpdateManyWithoutUserNestedInput
    routingRules?: RoutingRuleUncheckedUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PaymentRequestUpsertWithoutTransactionsInput = {
    update: XOR<PaymentRequestUpdateWithoutTransactionsInput, PaymentRequestUncheckedUpdateWithoutTransactionsInput>
    create: XOR<PaymentRequestCreateWithoutTransactionsInput, PaymentRequestUncheckedCreateWithoutTransactionsInput>
    where?: PaymentRequestWhereInput
  }

  export type PaymentRequestUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: PaymentRequestWhereInput
    data: XOR<PaymentRequestUpdateWithoutTransactionsInput, PaymentRequestUncheckedUpdateWithoutTransactionsInput>
  }

  export type PaymentRequestUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPaymentRequestsNestedInput
  }

  export type PaymentRequestUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LinkedAccountUpsertWithoutSourceTransactionsInput = {
    update: XOR<LinkedAccountUpdateWithoutSourceTransactionsInput, LinkedAccountUncheckedUpdateWithoutSourceTransactionsInput>
    create: XOR<LinkedAccountCreateWithoutSourceTransactionsInput, LinkedAccountUncheckedCreateWithoutSourceTransactionsInput>
    where?: LinkedAccountWhereInput
  }

  export type LinkedAccountUpdateToOneWithWhereWithoutSourceTransactionsInput = {
    where?: LinkedAccountWhereInput
    data: XOR<LinkedAccountUpdateWithoutSourceTransactionsInput, LinkedAccountUncheckedUpdateWithoutSourceTransactionsInput>
  }

  export type LinkedAccountUpdateWithoutSourceTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    dailyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLinkedAccountsNestedInput
    targetTransactions?: PaymentTransactionUpdateManyWithoutTargetAccountNestedInput
  }

  export type LinkedAccountUncheckedUpdateWithoutSourceTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    dailyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    targetTransactions?: PaymentTransactionUncheckedUpdateManyWithoutTargetAccountNestedInput
  }

  export type LinkedAccountUpsertWithoutTargetTransactionsInput = {
    update: XOR<LinkedAccountUpdateWithoutTargetTransactionsInput, LinkedAccountUncheckedUpdateWithoutTargetTransactionsInput>
    create: XOR<LinkedAccountCreateWithoutTargetTransactionsInput, LinkedAccountUncheckedCreateWithoutTargetTransactionsInput>
    where?: LinkedAccountWhereInput
  }

  export type LinkedAccountUpdateToOneWithWhereWithoutTargetTransactionsInput = {
    where?: LinkedAccountWhereInput
    data: XOR<LinkedAccountUpdateWithoutTargetTransactionsInput, LinkedAccountUncheckedUpdateWithoutTargetTransactionsInput>
  }

  export type LinkedAccountUpdateWithoutTargetTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    dailyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLinkedAccountsNestedInput
    sourceTransactions?: PaymentTransactionUpdateManyWithoutSourceAccountNestedInput
  }

  export type LinkedAccountUncheckedUpdateWithoutTargetTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    dailyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceTransactions?: PaymentTransactionUncheckedUpdateManyWithoutSourceAccountNestedInput
  }

  export type RoutingStepUpsertWithWhereUniqueWithoutTransactionInput = {
    where: RoutingStepWhereUniqueInput
    update: XOR<RoutingStepUpdateWithoutTransactionInput, RoutingStepUncheckedUpdateWithoutTransactionInput>
    create: XOR<RoutingStepCreateWithoutTransactionInput, RoutingStepUncheckedCreateWithoutTransactionInput>
  }

  export type RoutingStepUpdateWithWhereUniqueWithoutTransactionInput = {
    where: RoutingStepWhereUniqueInput
    data: XOR<RoutingStepUpdateWithoutTransactionInput, RoutingStepUncheckedUpdateWithoutTransactionInput>
  }

  export type RoutingStepUpdateManyWithWhereWithoutTransactionInput = {
    where: RoutingStepScalarWhereInput
    data: XOR<RoutingStepUpdateManyMutationInput, RoutingStepUncheckedUpdateManyWithoutTransactionInput>
  }

  export type RoutingStepScalarWhereInput = {
    AND?: RoutingStepScalarWhereInput | RoutingStepScalarWhereInput[]
    OR?: RoutingStepScalarWhereInput[]
    NOT?: RoutingStepScalarWhereInput | RoutingStepScalarWhereInput[]
    id?: StringFilter<"RoutingStep"> | string
    transactionId?: StringFilter<"RoutingStep"> | string
    stepNumber?: IntFilter<"RoutingStep"> | number
    provider?: EnumPaymentProviderFilter<"RoutingStep"> | $Enums.PaymentProvider
    action?: EnumRoutingActionFilter<"RoutingStep"> | $Enums.RoutingAction
    amount?: FloatFilter<"RoutingStep"> | number
    currency?: StringFilter<"RoutingStep"> | string
    status?: EnumStepStatusFilter<"RoutingStep"> | $Enums.StepStatus
    processingTime?: IntNullableFilter<"RoutingStep"> | number | null
    externalTransactionId?: StringNullableFilter<"RoutingStep"> | string | null
    createdAt?: DateTimeFilter<"RoutingStep"> | Date | string
    updatedAt?: DateTimeFilter<"RoutingStep"> | Date | string
  }

  export type TransactionFeeUpsertWithWhereUniqueWithoutTransactionInput = {
    where: TransactionFeeWhereUniqueInput
    update: XOR<TransactionFeeUpdateWithoutTransactionInput, TransactionFeeUncheckedUpdateWithoutTransactionInput>
    create: XOR<TransactionFeeCreateWithoutTransactionInput, TransactionFeeUncheckedCreateWithoutTransactionInput>
  }

  export type TransactionFeeUpdateWithWhereUniqueWithoutTransactionInput = {
    where: TransactionFeeWhereUniqueInput
    data: XOR<TransactionFeeUpdateWithoutTransactionInput, TransactionFeeUncheckedUpdateWithoutTransactionInput>
  }

  export type TransactionFeeUpdateManyWithWhereWithoutTransactionInput = {
    where: TransactionFeeScalarWhereInput
    data: XOR<TransactionFeeUpdateManyMutationInput, TransactionFeeUncheckedUpdateManyWithoutTransactionInput>
  }

  export type TransactionFeeScalarWhereInput = {
    AND?: TransactionFeeScalarWhereInput | TransactionFeeScalarWhereInput[]
    OR?: TransactionFeeScalarWhereInput[]
    NOT?: TransactionFeeScalarWhereInput | TransactionFeeScalarWhereInput[]
    id?: StringFilter<"TransactionFee"> | string
    transactionId?: StringFilter<"TransactionFee"> | string
    type?: EnumFeeTypeFilter<"TransactionFee"> | $Enums.FeeType
    amount?: FloatFilter<"TransactionFee"> | number
    currency?: StringFilter<"TransactionFee"> | string
    description?: StringFilter<"TransactionFee"> | string
    createdAt?: DateTimeFilter<"TransactionFee"> | Date | string
  }

  export type PaymentTransactionCreateWithoutRoutingStepsInput = {
    id?: string
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    paymentRequest?: PaymentRequestCreateNestedOneWithoutTransactionsInput
    sourceAccount: LinkedAccountCreateNestedOneWithoutSourceTransactionsInput
    targetAccount?: LinkedAccountCreateNestedOneWithoutTargetTransactionsInput
    fees?: TransactionFeeCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionUncheckedCreateWithoutRoutingStepsInput = {
    id?: string
    userId: string
    paymentRequestId?: string | null
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    sourceAccountId: string
    targetAccountId?: string | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    fees?: TransactionFeeUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionCreateOrConnectWithoutRoutingStepsInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutRoutingStepsInput, PaymentTransactionUncheckedCreateWithoutRoutingStepsInput>
  }

  export type RoutingStepFeeCreateWithoutRoutingStepInput = {
    id?: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
  }

  export type RoutingStepFeeUncheckedCreateWithoutRoutingStepInput = {
    id?: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
  }

  export type RoutingStepFeeCreateOrConnectWithoutRoutingStepInput = {
    where: RoutingStepFeeWhereUniqueInput
    create: XOR<RoutingStepFeeCreateWithoutRoutingStepInput, RoutingStepFeeUncheckedCreateWithoutRoutingStepInput>
  }

  export type RoutingStepFeeCreateManyRoutingStepInputEnvelope = {
    data: RoutingStepFeeCreateManyRoutingStepInput | RoutingStepFeeCreateManyRoutingStepInput[]
    skipDuplicates?: boolean
  }

  export type PaymentTransactionUpsertWithoutRoutingStepsInput = {
    update: XOR<PaymentTransactionUpdateWithoutRoutingStepsInput, PaymentTransactionUncheckedUpdateWithoutRoutingStepsInput>
    create: XOR<PaymentTransactionCreateWithoutRoutingStepsInput, PaymentTransactionUncheckedCreateWithoutRoutingStepsInput>
    where?: PaymentTransactionWhereInput
  }

  export type PaymentTransactionUpdateToOneWithWhereWithoutRoutingStepsInput = {
    where?: PaymentTransactionWhereInput
    data: XOR<PaymentTransactionUpdateWithoutRoutingStepsInput, PaymentTransactionUncheckedUpdateWithoutRoutingStepsInput>
  }

  export type PaymentTransactionUpdateWithoutRoutingStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    paymentRequest?: PaymentRequestUpdateOneWithoutTransactionsNestedInput
    sourceAccount?: LinkedAccountUpdateOneRequiredWithoutSourceTransactionsNestedInput
    targetAccount?: LinkedAccountUpdateOneWithoutTargetTransactionsNestedInput
    fees?: TransactionFeeUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutRoutingStepsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceAccountId?: StringFieldUpdateOperationsInput | string
    targetAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: TransactionFeeUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type RoutingStepFeeUpsertWithWhereUniqueWithoutRoutingStepInput = {
    where: RoutingStepFeeWhereUniqueInput
    update: XOR<RoutingStepFeeUpdateWithoutRoutingStepInput, RoutingStepFeeUncheckedUpdateWithoutRoutingStepInput>
    create: XOR<RoutingStepFeeCreateWithoutRoutingStepInput, RoutingStepFeeUncheckedCreateWithoutRoutingStepInput>
  }

  export type RoutingStepFeeUpdateWithWhereUniqueWithoutRoutingStepInput = {
    where: RoutingStepFeeWhereUniqueInput
    data: XOR<RoutingStepFeeUpdateWithoutRoutingStepInput, RoutingStepFeeUncheckedUpdateWithoutRoutingStepInput>
  }

  export type RoutingStepFeeUpdateManyWithWhereWithoutRoutingStepInput = {
    where: RoutingStepFeeScalarWhereInput
    data: XOR<RoutingStepFeeUpdateManyMutationInput, RoutingStepFeeUncheckedUpdateManyWithoutRoutingStepInput>
  }

  export type RoutingStepFeeScalarWhereInput = {
    AND?: RoutingStepFeeScalarWhereInput | RoutingStepFeeScalarWhereInput[]
    OR?: RoutingStepFeeScalarWhereInput[]
    NOT?: RoutingStepFeeScalarWhereInput | RoutingStepFeeScalarWhereInput[]
    id?: StringFilter<"RoutingStepFee"> | string
    routingStepId?: StringFilter<"RoutingStepFee"> | string
    type?: EnumFeeTypeFilter<"RoutingStepFee"> | $Enums.FeeType
    amount?: FloatFilter<"RoutingStepFee"> | number
    currency?: StringFilter<"RoutingStepFee"> | string
    description?: StringFilter<"RoutingStepFee"> | string
    createdAt?: DateTimeFilter<"RoutingStepFee"> | Date | string
  }

  export type PaymentTransactionCreateWithoutFeesInput = {
    id?: string
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutTransactionsInput
    paymentRequest?: PaymentRequestCreateNestedOneWithoutTransactionsInput
    sourceAccount: LinkedAccountCreateNestedOneWithoutSourceTransactionsInput
    targetAccount?: LinkedAccountCreateNestedOneWithoutTargetTransactionsInput
    routingSteps?: RoutingStepCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionUncheckedCreateWithoutFeesInput = {
    id?: string
    userId: string
    paymentRequestId?: string | null
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    sourceAccountId: string
    targetAccountId?: string | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    routingSteps?: RoutingStepUncheckedCreateNestedManyWithoutTransactionInput
  }

  export type PaymentTransactionCreateOrConnectWithoutFeesInput = {
    where: PaymentTransactionWhereUniqueInput
    create: XOR<PaymentTransactionCreateWithoutFeesInput, PaymentTransactionUncheckedCreateWithoutFeesInput>
  }

  export type PaymentTransactionUpsertWithoutFeesInput = {
    update: XOR<PaymentTransactionUpdateWithoutFeesInput, PaymentTransactionUncheckedUpdateWithoutFeesInput>
    create: XOR<PaymentTransactionCreateWithoutFeesInput, PaymentTransactionUncheckedCreateWithoutFeesInput>
    where?: PaymentTransactionWhereInput
  }

  export type PaymentTransactionUpdateToOneWithWhereWithoutFeesInput = {
    where?: PaymentTransactionWhereInput
    data: XOR<PaymentTransactionUpdateWithoutFeesInput, PaymentTransactionUncheckedUpdateWithoutFeesInput>
  }

  export type PaymentTransactionUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    paymentRequest?: PaymentRequestUpdateOneWithoutTransactionsNestedInput
    sourceAccount?: LinkedAccountUpdateOneRequiredWithoutSourceTransactionsNestedInput
    targetAccount?: LinkedAccountUpdateOneWithoutTargetTransactionsNestedInput
    routingSteps?: RoutingStepUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceAccountId?: StringFieldUpdateOperationsInput | string
    targetAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routingSteps?: RoutingStepUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type RoutingStepCreateWithoutFeesInput = {
    id?: string
    stepNumber: number
    provider: $Enums.PaymentProvider
    action: $Enums.RoutingAction
    amount: number
    currency: string
    status?: $Enums.StepStatus
    processingTime?: number | null
    externalTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    transaction: PaymentTransactionCreateNestedOneWithoutRoutingStepsInput
  }

  export type RoutingStepUncheckedCreateWithoutFeesInput = {
    id?: string
    transactionId: string
    stepNumber: number
    provider: $Enums.PaymentProvider
    action: $Enums.RoutingAction
    amount: number
    currency: string
    status?: $Enums.StepStatus
    processingTime?: number | null
    externalTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoutingStepCreateOrConnectWithoutFeesInput = {
    where: RoutingStepWhereUniqueInput
    create: XOR<RoutingStepCreateWithoutFeesInput, RoutingStepUncheckedCreateWithoutFeesInput>
  }

  export type RoutingStepUpsertWithoutFeesInput = {
    update: XOR<RoutingStepUpdateWithoutFeesInput, RoutingStepUncheckedUpdateWithoutFeesInput>
    create: XOR<RoutingStepCreateWithoutFeesInput, RoutingStepUncheckedCreateWithoutFeesInput>
    where?: RoutingStepWhereInput
  }

  export type RoutingStepUpdateToOneWithWhereWithoutFeesInput = {
    where?: RoutingStepWhereInput
    data: XOR<RoutingStepUpdateWithoutFeesInput, RoutingStepUncheckedUpdateWithoutFeesInput>
  }

  export type RoutingStepUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    action?: EnumRoutingActionFieldUpdateOperationsInput | $Enums.RoutingAction
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transaction?: PaymentTransactionUpdateOneRequiredWithoutRoutingStepsNestedInput
  }

  export type RoutingStepUncheckedUpdateWithoutFeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    transactionId?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    action?: EnumRoutingActionFieldUpdateOperationsInput | $Enums.RoutingAction
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateWithoutRoutingRulesInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileCreateNestedOneWithoutUserInput
    linkedAccounts?: LinkedAccountCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionCreateNestedManyWithoutUserInput
    sessions?: UserSessionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRoutingRulesInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    linkedAccounts?: LinkedAccountUncheckedCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
    sessions?: UserSessionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRoutingRulesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRoutingRulesInput, UserUncheckedCreateWithoutRoutingRulesInput>
  }

  export type UserUpsertWithoutRoutingRulesInput = {
    update: XOR<UserUpdateWithoutRoutingRulesInput, UserUncheckedUpdateWithoutRoutingRulesInput>
    create: XOR<UserCreateWithoutRoutingRulesInput, UserUncheckedCreateWithoutRoutingRulesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRoutingRulesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRoutingRulesInput, UserUncheckedUpdateWithoutRoutingRulesInput>
  }

  export type UserUpdateWithoutRoutingRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    linkedAccounts?: LinkedAccountUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRoutingRulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    linkedAccounts?: LinkedAccountUncheckedUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
    sessions?: UserSessionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileCreateNestedOneWithoutUserInput
    linkedAccounts?: LinkedAccountCreateNestedManyWithoutUserInput
    routingRules?: RoutingRuleCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    email: string
    phoneNumber: string
    firstName: string
    lastName: string
    countryCode: string
    preferredCurrency?: string
    passwordHash: string
    isEmailVerified?: boolean
    isPhoneVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: UserProfileUncheckedCreateNestedOneWithoutUserInput
    linkedAccounts?: LinkedAccountUncheckedCreateNestedManyWithoutUserInput
    routingRules?: RoutingRuleUncheckedCreateNestedManyWithoutUserInput
    paymentRequests?: PaymentRequestUncheckedCreateNestedManyWithoutUserInput
    transactions?: PaymentTransactionUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUpdateOneWithoutUserNestedInput
    linkedAccounts?: LinkedAccountUpdateManyWithoutUserNestedInput
    routingRules?: RoutingRuleUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phoneNumber?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    countryCode?: StringFieldUpdateOperationsInput | string
    preferredCurrency?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    isEmailVerified?: BoolFieldUpdateOperationsInput | boolean
    isPhoneVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: UserProfileUncheckedUpdateOneWithoutUserNestedInput
    linkedAccounts?: LinkedAccountUncheckedUpdateManyWithoutUserNestedInput
    routingRules?: RoutingRuleUncheckedUpdateManyWithoutUserNestedInput
    paymentRequests?: PaymentRequestUncheckedUpdateManyWithoutUserNestedInput
    transactions?: PaymentTransactionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type LinkedAccountCreateManyUserInput = {
    id?: string
    accountType: $Enums.AccountType
    provider: $Enums.PaymentProvider
    accountNumber: string
    accountName: string
    currency: string
    balance?: number | null
    isActive?: boolean
    isPrimary?: boolean
    priority?: number
    dailyLimit?: number | null
    monthlyLimit?: number | null
    linkedAt?: Date | string
    lastSyncAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoutingRuleCreateManyUserInput = {
    id?: string
    name: string
    conditions: JsonNullValueInput | InputJsonValue
    actions: JsonNullValueInput | InputJsonValue
    priority?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentRequestCreateManyUserInput = {
    id?: string
    amount: number
    currency: string
    targetCurrency?: string | null
    merchantId?: string | null
    merchantName?: string | null
    description?: string | null
    qrCode?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionCreateManyUserInput = {
    id?: string
    paymentRequestId?: string | null
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    sourceAccountId: string
    targetAccountId?: string | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSessionCreateManyUserInput = {
    id?: string
    token: string
    refreshToken: string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LinkedAccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    dailyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceTransactions?: PaymentTransactionUpdateManyWithoutSourceAccountNestedInput
    targetTransactions?: PaymentTransactionUpdateManyWithoutTargetAccountNestedInput
  }

  export type LinkedAccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    dailyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sourceTransactions?: PaymentTransactionUncheckedUpdateManyWithoutSourceAccountNestedInput
    targetTransactions?: PaymentTransactionUncheckedUpdateManyWithoutTargetAccountNestedInput
  }

  export type LinkedAccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountType?: EnumAccountTypeFieldUpdateOperationsInput | $Enums.AccountType
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    accountNumber?: StringFieldUpdateOperationsInput | string
    accountName?: StringFieldUpdateOperationsInput | string
    currency?: StringFieldUpdateOperationsInput | string
    balance?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    priority?: IntFieldUpdateOperationsInput | number
    dailyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    monthlyLimit?: NullableFloatFieldUpdateOperationsInput | number | null
    linkedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingRuleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingRuleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingRuleUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    conditions?: JsonNullValueInput | InputJsonValue
    actions?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: PaymentTransactionUpdateManyWithoutPaymentRequestNestedInput
  }

  export type PaymentRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: PaymentTransactionUncheckedUpdateManyWithoutPaymentRequestNestedInput
  }

  export type PaymentRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    merchantId?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    qrCode?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentRequest?: PaymentRequestUpdateOneWithoutTransactionsNestedInput
    sourceAccount?: LinkedAccountUpdateOneRequiredWithoutSourceTransactionsNestedInput
    targetAccount?: LinkedAccountUpdateOneWithoutTargetTransactionsNestedInput
    routingSteps?: RoutingStepUpdateManyWithoutTransactionNestedInput
    fees?: TransactionFeeUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceAccountId?: StringFieldUpdateOperationsInput | string
    targetAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routingSteps?: RoutingStepUncheckedUpdateManyWithoutTransactionNestedInput
    fees?: TransactionFeeUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceAccountId?: StringFieldUpdateOperationsInput | string
    targetAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    refreshToken?: StringFieldUpdateOperationsInput | string
    deviceInfo?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionCreateManySourceAccountInput = {
    id?: string
    userId: string
    paymentRequestId?: string | null
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    targetAccountId?: string | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionCreateManyTargetAccountInput = {
    id?: string
    userId: string
    paymentRequestId?: string | null
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    sourceAccountId: string
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionUpdateWithoutSourceAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    paymentRequest?: PaymentRequestUpdateOneWithoutTransactionsNestedInput
    targetAccount?: LinkedAccountUpdateOneWithoutTargetTransactionsNestedInput
    routingSteps?: RoutingStepUpdateManyWithoutTransactionNestedInput
    fees?: TransactionFeeUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutSourceAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    targetAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routingSteps?: RoutingStepUncheckedUpdateManyWithoutTransactionNestedInput
    fees?: TransactionFeeUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutSourceAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    targetAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionUpdateWithoutTargetAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    paymentRequest?: PaymentRequestUpdateOneWithoutTransactionsNestedInput
    sourceAccount?: LinkedAccountUpdateOneRequiredWithoutSourceTransactionsNestedInput
    routingSteps?: RoutingStepUpdateManyWithoutTransactionNestedInput
    fees?: TransactionFeeUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutTargetAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceAccountId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routingSteps?: RoutingStepUncheckedUpdateManyWithoutTransactionNestedInput
    fees?: TransactionFeeUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutTargetAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    paymentRequestId?: NullableStringFieldUpdateOperationsInput | string | null
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceAccountId?: StringFieldUpdateOperationsInput | string
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentTransactionCreateManyPaymentRequestInput = {
    id?: string
    userId: string
    amount: number
    currency: string
    targetAmount?: number | null
    targetCurrency?: string | null
    exchangeRate?: number | null
    sourceAccountId: string
    targetAccountId?: string | null
    status?: $Enums.TransactionStatus
    failureReason?: string | null
    merchantName?: string | null
    merchantCategory?: string | null
    merchantLocation?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: Date | string
    completedAt?: Date | string | null
    failedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentTransactionUpdateWithoutPaymentRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTransactionsNestedInput
    sourceAccount?: LinkedAccountUpdateOneRequiredWithoutSourceTransactionsNestedInput
    targetAccount?: LinkedAccountUpdateOneWithoutTargetTransactionsNestedInput
    routingSteps?: RoutingStepUpdateManyWithoutTransactionNestedInput
    fees?: TransactionFeeUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateWithoutPaymentRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceAccountId?: StringFieldUpdateOperationsInput | string
    targetAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    routingSteps?: RoutingStepUncheckedUpdateManyWithoutTransactionNestedInput
    fees?: TransactionFeeUncheckedUpdateManyWithoutTransactionNestedInput
  }

  export type PaymentTransactionUncheckedUpdateManyWithoutPaymentRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    targetAmount?: NullableFloatFieldUpdateOperationsInput | number | null
    targetCurrency?: NullableStringFieldUpdateOperationsInput | string | null
    exchangeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    sourceAccountId?: StringFieldUpdateOperationsInput | string
    targetAccountId?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumTransactionStatusFieldUpdateOperationsInput | $Enums.TransactionStatus
    failureReason?: NullableStringFieldUpdateOperationsInput | string | null
    merchantName?: NullableStringFieldUpdateOperationsInput | string | null
    merchantCategory?: NullableStringFieldUpdateOperationsInput | string | null
    merchantLocation?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    initiatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    failedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingStepCreateManyTransactionInput = {
    id?: string
    stepNumber: number
    provider: $Enums.PaymentProvider
    action: $Enums.RoutingAction
    amount: number
    currency: string
    status?: $Enums.StepStatus
    processingTime?: number | null
    externalTransactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TransactionFeeCreateManyTransactionInput = {
    id?: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
  }

  export type RoutingStepUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    action?: EnumRoutingActionFieldUpdateOperationsInput | $Enums.RoutingAction
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: RoutingStepFeeUpdateManyWithoutRoutingStepNestedInput
  }

  export type RoutingStepUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    action?: EnumRoutingActionFieldUpdateOperationsInput | $Enums.RoutingAction
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    fees?: RoutingStepFeeUncheckedUpdateManyWithoutRoutingStepNestedInput
  }

  export type RoutingStepUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    stepNumber?: IntFieldUpdateOperationsInput | number
    provider?: EnumPaymentProviderFieldUpdateOperationsInput | $Enums.PaymentProvider
    action?: EnumRoutingActionFieldUpdateOperationsInput | $Enums.RoutingAction
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumStepStatusFieldUpdateOperationsInput | $Enums.StepStatus
    processingTime?: NullableIntFieldUpdateOperationsInput | number | null
    externalTransactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFeeUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFeeUncheckedUpdateWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionFeeUncheckedUpdateManyWithoutTransactionInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingStepFeeCreateManyRoutingStepInput = {
    id?: string
    type: $Enums.FeeType
    amount: number
    currency: string
    description: string
    createdAt?: Date | string
  }

  export type RoutingStepFeeUpdateWithoutRoutingStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingStepFeeUncheckedUpdateWithoutRoutingStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoutingStepFeeUncheckedUpdateManyWithoutRoutingStepInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumFeeTypeFieldUpdateOperationsInput | $Enums.FeeType
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LinkedAccountCountOutputTypeDefaultArgs instead
     */
    export type LinkedAccountCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LinkedAccountCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentRequestCountOutputTypeDefaultArgs instead
     */
    export type PaymentRequestCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentRequestCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentTransactionCountOutputTypeDefaultArgs instead
     */
    export type PaymentTransactionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentTransactionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoutingStepCountOutputTypeDefaultArgs instead
     */
    export type RoutingStepCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoutingStepCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserProfileDefaultArgs instead
     */
    export type UserProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserProfileDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LinkedAccountDefaultArgs instead
     */
    export type LinkedAccountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LinkedAccountDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentRequestDefaultArgs instead
     */
    export type PaymentRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentTransactionDefaultArgs instead
     */
    export type PaymentTransactionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentTransactionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoutingStepDefaultArgs instead
     */
    export type RoutingStepArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoutingStepDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TransactionFeeDefaultArgs instead
     */
    export type TransactionFeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TransactionFeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoutingStepFeeDefaultArgs instead
     */
    export type RoutingStepFeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoutingStepFeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoutingRuleDefaultArgs instead
     */
    export type RoutingRuleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoutingRuleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExchangeRateDefaultArgs instead
     */
    export type ExchangeRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExchangeRateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentNetworkStatusDefaultArgs instead
     */
    export type PaymentNetworkStatusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentNetworkStatusDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserSessionDefaultArgs instead
     */
    export type UserSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}